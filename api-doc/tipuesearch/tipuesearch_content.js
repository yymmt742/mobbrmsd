var tipuesearch = {"pages":[{"title":" symRMSD ","text":"symRMSD molecular symmetry corrected RMSD by branch and bound Algorithm Note note Todo todo Bug bug report Developer Info yymmt742","tags":"home","loc":"index.html"},{"title":"d_matrix – symRMSD ","text":"type, public :: d_matrix sequence Contents Variables s m n g Constructor d_matrix Components Type Visibility Attributes Name Initial integer(kind=IK), public :: s integer(kind=IK), public :: m integer(kind=IK), public :: n integer(kind=IK), public :: g Constructor public        interface d_matrix private pure elemental function d_matrix_new(p, d, nk, b) result(res) generator Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: p integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: nk type( mol_block ), intent(in) :: b Return Value type( d_matrix )","tags":"","loc":"type/d_matrix.html"},{"title":"d_matrix_list – symRMSD ","text":"type, public :: d_matrix_list Contents Variables h v c o d l dd nk m Constructor d_matrix_list Finalization Procedures d_matrix_list_destroy Type-Bound Procedures n_depth eval partial_eval memsize clear Components Type Visibility Attributes Name Initial integer(kind=IK), public :: h = 0 integer(kind=IK), public :: v = 0 integer(kind=IK), public :: c = 0 integer(kind=IK), public :: o = 0 integer(kind=IK), public :: d = 0 integer(kind=IK), public :: l = 0 integer(kind=IK), public :: dd = 0 integer(kind=IK), public :: nk type( d_matrix ), public, allocatable :: m (:) Constructor public        interface d_matrix_list private pure function d_matrix_list_new(b, p) result(res) Arguments Type Intent Optional Attributes Name type( mol_block_list ), intent(in) :: b integer(kind=IK), intent(in) :: p Return Value type( d_matrix_list ) Finalization Procedures final :: d_matrix_list_destroy private pure elemental subroutine d_matrix_list_destroy(this) Arguments Type Intent Optional Attributes Name type( d_matrix_list ), intent(inout) :: this Type-Bound Procedures procedure, public,  :: n_depth => d_matrix_list_n_depth private pure elemental function d_matrix_list_n_depth(this) result(res) Arguments Type Intent Optional Attributes Name class( d_matrix_list ), intent(in) :: this Return Value integer(kind=IK) procedure, public,  :: eval => d_matrix_list_eval private pure subroutine d_matrix_list_eval(this, rot, X, Y, W) ! estimate H_fix, V_fix, C_fix. (mol_blocks for g<n or (g=1, s=1))\n! if set is empty, H_fix=0, V_fix=0, C_fix=0. ! estimate floating mol blocks.\n! O is filled by lower bounds for each blocks. ! transform O to accumulated form. Arguments Type Intent Optional Attributes Name class( d_matrix_list ), intent(in) :: this type( mol_symmetry ), intent(in) :: rot (*) real(kind=RK), intent(in) :: X (*) real(kind=RK), intent(in) :: Y (*) real(kind=RK), intent(inout) :: W (*) procedure, public,  :: partial_eval => d_matrix_list_partial_eval private pure subroutine d_matrix_list_partial_eval(this, p, perm, iprm, isym, W, LT, H, C, LF, LB) Arguments Type Intent Optional Attributes Name class( d_matrix_list ), intent(in) :: this integer(kind=IK), intent(in) :: p integer(kind=IK), intent(in) :: perm (*) integer(kind=IK), intent(in) :: iprm integer(kind=IK), intent(in) :: isym real(kind=RK), intent(in) :: W (*) real(kind=RK), intent(inout) :: LT real(kind=RK), intent(inout) :: H real(kind=RK), intent(inout) :: C (*) real(kind=RK), intent(inout), optional :: LF real(kind=RK), intent(inout), optional :: LB procedure, public,  :: memsize => d_matrix_list_memsize private pure function d_matrix_list_memsize(this) result(res) Arguments Type Intent Optional Attributes Name class( d_matrix_list ), intent(in) :: this Return Value integer(kind=IK) procedure, public,  :: clear => d_matrix_list_clear private pure elemental subroutine d_matrix_list_clear(this) Arguments Type Intent Optional Attributes Name class( d_matrix_list ), intent(inout) :: this","tags":"","loc":"type/d_matrix_list.html"},{"title":"tree – symRMSD ","text":"type, public :: tree Contents Variables ubnode memnode memsize upperbound lowerbound Constructor tree Finalization Procedures tree_destroy Type-Bound Procedures n_depth n_breadth current_depth reset set_parent_node set_lowerbound prune nodes_pointer parent_pointer parent_index current_pointer current_index alive_nodes open_node close_node log_ncomb finished unfinished clear Components Type Visibility Attributes Name Initial integer(kind=IK), public :: ubnode = 0 integer(kind=IK), public :: memnode = 0 integer(kind=IK), public :: memsize = 0 integer(kind=IK), public :: upperbound = 0 integer(kind=IK), public :: lowerbound = 0 Constructor public        interface tree private pure function tree_new(pw, memnode, ndepth, n_breadths) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: pw integer(kind=IK), intent(in) :: memnode integer(kind=IK), intent(in) :: ndepth integer(kind=IK), intent(in) :: n_breadths (ndepth) Return Value type( tree ) Finalization Procedures final :: tree_destroy private pure elemental subroutine tree_destroy(this) Arguments Type Intent Optional Attributes Name type( tree ), intent(inout) :: this Type-Bound Procedures procedure, public,  :: n_depth => tree_n_depth private pure elemental function tree_n_depth(this) result(res) Arguments Type Intent Optional Attributes Name class( tree ), intent(in) :: this Return Value integer(kind=IK) procedure, public,  :: n_breadth => tree_n_breadth private pure elemental function tree_n_breadth(this) result(res) Arguments Type Intent Optional Attributes Name class( tree ), intent(in) :: this Return Value integer(kind=IK) procedure, public,  :: current_depth => tree_current_depth private pure elemental function tree_current_depth(this) result(res) Arguments Type Intent Optional Attributes Name class( tree ), intent(in) :: this Return Value integer(kind=IK) procedure, public,  :: reset => tree_reset private pure subroutine tree_reset(this) Arguments Type Intent Optional Attributes Name class( tree ), intent(inout) :: this procedure, public,  :: set_parent_node => tree_set_parent_node private pure subroutine tree_set_parent_node(this, W) Arguments Type Intent Optional Attributes Name class( tree ), intent(inout) :: this real(kind=RK), intent(in) :: W (*) procedure, public,  :: set_lowerbound => tree_set_lowerbound private pure subroutine tree_set_lowerbound(this, W) Arguments Type Intent Optional Attributes Name class( tree ), intent(in) :: this real(kind=RK), intent(inout) :: W (*) procedure, public,  :: prune => tree_prune private pure subroutine tree_prune(this, W) Arguments Type Intent Optional Attributes Name class( tree ), intent(inout) :: this real(kind=RK), intent(in) :: W (*) procedure, public,  :: nodes_pointer => tree_nodes_pointer private pure elemental function tree_nodes_pointer(this) result(res) Arguments Type Intent Optional Attributes Name class( tree ), intent(in) :: this Return Value integer(kind=IK) procedure, public,  :: parent_pointer => tree_parent_pointer private pure elemental function tree_parent_pointer(this) result(res) Arguments Type Intent Optional Attributes Name class( tree ), intent(in) :: this Return Value integer(kind=IK) procedure, public,  :: parent_index => tree_parent_index private pure elemental function tree_parent_index(this) result(res) Arguments Type Intent Optional Attributes Name class( tree ), intent(in) :: this Return Value integer(kind=IK) procedure, public,  :: current_pointer => tree_current_pointer private pure elemental function tree_current_pointer(this) result(res) Arguments Type Intent Optional Attributes Name class( tree ), intent(in) :: this Return Value integer(kind=IK) procedure, public,  :: current_index => tree_current_index private pure elemental function tree_current_index(this) result(res) Arguments Type Intent Optional Attributes Name class( tree ), intent(in) :: this Return Value integer(kind=IK) procedure, public,  :: alive_nodes => tree_alive_nodes private pure function tree_alive_nodes(this) result(res) Arguments Type Intent Optional Attributes Name class( tree ), intent(in) :: this Return Value logical, allocatable, (:) procedure, public,  :: open_node => tree_open_node private pure elemental subroutine tree_open_node(this) Arguments Type Intent Optional Attributes Name class( tree ), intent(inout) :: this procedure, public,  :: close_node => tree_close_node private pure elemental subroutine tree_close_node(this) Arguments Type Intent Optional Attributes Name class( tree ), intent(inout) :: this procedure, public,  :: log_ncomb => tree_log_ncomb private pure elemental function tree_log_ncomb(this) result(res) Arguments Type Intent Optional Attributes Name class( tree ), intent(in) :: this Return Value real(kind=RK) procedure, public,  :: finished => tree_finished private pure elemental function tree_finished(this) result(res) Arguments Type Intent Optional Attributes Name class( tree ), intent(in) :: this Return Value logical procedure, public,  :: unfinished => tree_unfinished private pure elemental function tree_unfinished(this) result(res) Arguments Type Intent Optional Attributes Name class( tree ), intent(in) :: this Return Value logical procedure, public,  :: clear => tree_clear private pure elemental subroutine tree_clear(this) Arguments Type Intent Optional Attributes Name class( tree ), intent(inout) :: this","tags":"","loc":"type/tree.html"},{"title":"group_permutation – symRMSD ","text":"type, public :: group_permutation Contents Constructor group_permutation Finalization Procedures group_permutation_destroy Type-Bound Procedures init nfree free_indices swap reverse clear Constructor public        interface group_permutation private pure function group_permutation_new(prm) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: prm (:) permutation indices Return Value type( group_permutation ) Finalization Procedures final :: group_permutation_destroy private pure elemental subroutine group_permutation_destroy(this) Arguments Type Intent Optional Attributes Name type( group_permutation ), intent(inout) :: this Type-Bound Procedures procedure, public,  :: init => group_permutation_init public pure subroutine group_permutation_init (this, prm) Arguments Type Intent Optional Attributes Name class( group_permutation ), intent(inout) :: this integer(kind=IK), intent(in) :: prm (:) permutation indices procedure, public,  :: nfree => group_permutation_nfree private pure elemental function group_permutation_nfree(this) result(res) Arguments Type Intent Optional Attributes Name class( group_permutation ), intent(in) :: this Return Value integer(kind=IK) procedure, public,  :: free_indices => group_permutation_free_indices private pure function group_permutation_free_indices(this) result(res) Arguments Type Intent Optional Attributes Name class( group_permutation ), intent(in) :: this Return Value integer(kind=IK), (this%nfree()) procedure, public,  :: swap => group_permutation_swap_real private pure subroutine group_permutation_swap_real(this, d, X) Arguments Type Intent Optional Attributes Name class( group_permutation ), intent(in) :: this integer(kind=IK), intent(in) :: d real(kind=RK), intent(inout) :: X (*) procedure, public,  :: reverse => group_permutation_reverse_real private pure subroutine group_permutation_reverse_real(this, d, X) Arguments Type Intent Optional Attributes Name class( group_permutation ), intent(in) :: this integer(kind=IK), intent(in) :: d real(kind=RK), intent(inout) :: X (*) procedure, public,  :: clear => group_permutation_clear private pure elemental subroutine group_permutation_clear(this) Arguments Type Intent Optional Attributes Name class( group_permutation ), intent(inout) :: this","tags":"","loc":"type/group_permutation.html"},{"title":"mol_block – symRMSD ","text":"type, public :: mol_block sequence molecular block indicator\n atomic coordinates vector must be stored in the following format.\n   X(d,m,n)\n   - d :: spatial dimension.\n   - m :: number of atom in a molecule.\n   - n :: number of molecule.\n   - where X(d,:f,:g)     :: Free rotatable.\n   -       X(d,f+1:,g+1:) :: Fixed. Contents Variables p s m n f g Components Type Visibility Attributes Name Initial integer(kind=IK), public :: p = 1 integer(kind=IK), public :: s = 1 integer(kind=IK), public :: m = 1 integer(kind=IK), public :: n = 1 integer(kind=IK), public :: f = 1 integer(kind=IK), public :: g = 1","tags":"","loc":"type/mol_block.html"},{"title":"mol_block_list – symRMSD ","text":"type, public :: mol_block_list Contents Variables d mg mn b Constructor mol_block_list Finalization Procedures mol_block_list_destroy Type-Bound Procedures add_molecule child invalid natom nspatial nspecies ispecies ipointer n_res res_pointer has_child clear Components Type Visibility Attributes Name Initial integer(kind=IK), public :: d = 0 integer(kind=IK), public :: mg = 0 integer(kind=IK), public :: mn = 0 type( mol_block ), public, allocatable :: b (:) Constructor public        interface mol_block_list private pure function mol_block_list_new(d, l, b) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: l type( mol_block ), intent(in) :: b (l) Return Value type( mol_block_list ) Finalization Procedures final :: mol_block_list_destroy private pure elemental subroutine mol_block_list_destroy(this) Arguments Type Intent Optional Attributes Name type( mol_block_list ), intent(inout) :: this Type-Bound Procedures procedure, public,  :: add_molecule => mol_block_list_add_molecule private pure subroutine mol_block_list_add_molecule(this, b) Arguments Type Intent Optional Attributes Name class( mol_block_list ), intent(inout) :: this type( mol_block ), intent(in) :: b procedure, public,  :: child => mol_block_list_child private pure elemental function mol_block_list_child(b) result(res) Arguments Type Intent Optional Attributes Name class( mol_block_list ), intent(in) :: b Return Value type( mol_block_list ) procedure, public,  :: invalid => mol_block_list_invalid private pure elemental function mol_block_list_invalid(this) result(res) Arguments Type Intent Optional Attributes Name class( mol_block_list ), intent(in) :: this Return Value logical procedure, public,  :: natom => mol_block_list_natom private pure elemental function mol_block_list_natom(this) result(res) Arguments Type Intent Optional Attributes Name class( mol_block_list ), intent(in) :: this Return Value integer(kind=IK) procedure, public,  :: nspatial => mol_block_list_nspatial private pure elemental function mol_block_list_nspatial(this) result(res) Arguments Type Intent Optional Attributes Name class( mol_block_list ), intent(in) :: this Return Value integer(kind=IK) procedure, public,  :: nspecies => mol_block_list_nspecies private pure elemental function mol_block_list_nspecies(this) result(res) Arguments Type Intent Optional Attributes Name class( mol_block_list ), intent(in) :: this Return Value integer(kind=IK) procedure, public,  :: ispecies => mol_block_list_ispecies private pure elemental function mol_block_list_ispecies(b) result(res) Arguments Type Intent Optional Attributes Name class( mol_block_list ), intent(in) :: b Return Value integer(kind=IK) procedure, public,  :: ipointer => mol_block_list_ipointer private pure elemental function mol_block_list_ipointer(b, imol) result(res) Arguments Type Intent Optional Attributes Name class( mol_block_list ), intent(in) :: b integer(kind=IK), intent(in) :: imol Return Value integer(kind=IK) procedure, public,  :: n_res => mol_block_list_n_res private pure function mol_block_list_n_res(b) result(res) Arguments Type Intent Optional Attributes Name class( mol_block_list ), intent(in) :: b Return Value integer(kind=IK), (b%nspecies()) procedure, public,  :: res_pointer => mol_block_list_res_pointer private pure elemental function mol_block_list_res_pointer(b, ispc) result(res) Arguments Type Intent Optional Attributes Name class( mol_block_list ), intent(in) :: b integer(kind=IK), intent(in) :: ispc Return Value integer(kind=IK) procedure, public,  :: has_child => mol_block_list_has_child private pure elemental function mol_block_list_has_child(this) result(res) Arguments Type Intent Optional Attributes Name class( mol_block_list ), intent(in) :: this Return Value logical procedure, public,  :: clear => mol_block_list_clear private pure elemental subroutine mol_block_list_clear(this) Arguments Type Intent Optional Attributes Name class( mol_block_list ), intent(inout) :: this","tags":"","loc":"type/mol_block_list.html"},{"title":"mol_symmetry – symRMSD ","text":"type, public :: mol_symmetry Contents Constructor mol_symmetry Finalization Procedures mol_symmetry_destroy Type-Bound Procedures n_atom n_sym swap reverse clear Constructor public        interface mol_symmetry private pure function mol_symmetry_new(sym) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in), optional :: sym (:,:) symmetry indices Return Value type( mol_symmetry ) Finalization Procedures final :: mol_symmetry_destroy private pure elemental subroutine mol_symmetry_destroy(this) Arguments Type Intent Optional Attributes Name type( mol_symmetry ), intent(inout) :: this Type-Bound Procedures procedure, public,  :: n_atom => mol_symmetry_n_atom private pure elemental function mol_symmetry_n_atom(this) result(res) Arguments Type Intent Optional Attributes Name class( mol_symmetry ), intent(in) :: this Return Value integer(kind=IK) procedure, public,  :: n_sym => mol_symmetry_n_sym private pure elemental function mol_symmetry_n_sym(this) result(res) Arguments Type Intent Optional Attributes Name class( mol_symmetry ), intent(in) :: this Return Value integer(kind=IK) procedure, public,  :: swap => mol_symmetry_swap private pure subroutine mol_symmetry_swap(this, d, X, isym) Arguments Type Intent Optional Attributes Name class( mol_symmetry ), intent(in) :: this integer(kind=IK), intent(in) :: d real(kind=RK), intent(inout) :: X (*) integer(kind=IK), intent(in) :: isym procedure, public,  :: reverse => mol_symmetry_reverse private pure subroutine mol_symmetry_reverse(this, d, X, isym) Arguments Type Intent Optional Attributes Name class( mol_symmetry ), intent(in) :: this integer(kind=IK), intent(in) :: d real(kind=RK), intent(inout) :: X (*) integer(kind=IK), intent(in) :: isym procedure, public,  :: clear => mol_symmetry_clear private pure elemental subroutine mol_symmetry_clear(this) Arguments Type Intent Optional Attributes Name class( mol_symmetry ), intent(inout) :: this","tags":"","loc":"type/mol_symmetry.html"},{"title":"branch_and_prune – symRMSD ","text":"type, public :: branch_and_prune Contents Variables mn dmn memsize ratio nsrch lncmb xp yp upperbound lowerbound Constructor branch_and_prune Finalization Procedures branch_and_prune_destroy Type-Bound Procedures setup run clear Components Type Visibility Attributes Name Initial integer(kind=IK), public :: mn integer(kind=IK), public :: dmn integer(kind=IK), public :: memsize integer(kind=IK), public :: ratio integer(kind=IK), public :: nsrch integer(kind=IK), public :: lncmb integer(kind=IK), public :: xp integer(kind=IK), public :: yp integer(kind=IK), public :: upperbound integer(kind=IK), public :: lowerbound Constructor public        interface branch_and_prune private pure function branch_and_prune_new(blk, ms) result(res) generate node instance Arguments Type Intent Optional Attributes Name type( mol_block_list ), intent(in) :: blk type( mol_symmetry ), intent(in), optional :: ms (*) Return Value type( branch_and_prune ) Finalization Procedures final :: branch_and_prune_destroy private pure elemental subroutine branch_and_prune_destroy(this) Arguments Type Intent Optional Attributes Name type( branch_and_prune ), intent(inout) :: this Type-Bound Procedures procedure, public,  :: setup => branch_and_prune_setup private pure subroutine branch_and_prune_setup(this, X, Y, W) Arguments Type Intent Optional Attributes Name class( branch_and_prune ), intent(in) :: this real(kind=RK), intent(in) :: X (*) real(kind=RK), intent(in) :: Y (*) real(kind=RK), intent(inout) :: W (*) procedure, public,  :: run => branch_and_prune_run private pure subroutine branch_and_prune_run(this, W, swap_y) Arguments Type Intent Optional Attributes Name class( branch_and_prune ), intent(in) :: this real(kind=RK), intent(inout) :: W (*) logical, intent(in) :: swap_y procedure, public,  :: clear => branch_and_prune_clear private pure elemental subroutine branch_and_prune_clear(this) Arguments Type Intent Optional Attributes Name class( branch_and_prune ), intent(inout) :: this","tags":"","loc":"type/branch_and_prune.html"},{"title":"symRMSD_input – symRMSD ","text":"type, public :: symRMSD_input Contents Variables blk ms Finalization Procedures symRMSD_input_destroy Type-Bound Procedures add_molecule clear Components Type Visibility Attributes Name Initial type( mol_block_list ), public :: blk type( mol_symmetry ), public, allocatable :: ms (:) Finalization Procedures final :: symRMSD_input_destroy public pure elemental subroutine symRMSD_input_destroy (this) Arguments Type Intent Optional Attributes Name type( symRMSD_input ), intent(inout) :: this Type-Bound Procedures procedure, public,  :: add_molecule => symRMSD_input_add_molecule public pure subroutine symRMSD_input_add_molecule (this, b, s) Arguments Type Intent Optional Attributes Name class( symRMSD_input ), intent(inout) :: this type( mol_block ), intent(in) :: b integer(kind=IK), intent(in) :: s (*) procedure, public,  :: clear => symRMSD_input_clear public pure elemental subroutine symRMSD_input_clear (this) Arguments Type Intent Optional Attributes Name class( symRMSD_input ), intent(inout) :: this","tags":"","loc":"type/symrmsd_input.html"},{"title":"symRMSD – symRMSD ","text":"type, public :: symRMSD Contents Variables nmem ndim natm Constructor symRMSD Finalization Procedures symRMSD_destroy Type-Bound Procedures run sd rmsd search_ratio clear Components Type Visibility Attributes Name Initial integer(kind=IK), public :: nmem = 0 integer(kind=IK), public :: ndim = 0 integer(kind=IK), public :: natm = 0 Constructor public        interface symRMSD public pure function symRMSD_new (inp) result(res) Arguments Type Intent Optional Attributes Name type( symRMSD_input ), intent(in) :: inp Return Value type( symRMSD ) Finalization Procedures final :: symRMSD_destroy public pure elemental subroutine symRMSD_destroy (this) Arguments Type Intent Optional Attributes Name type( symRMSD ), intent(inout) :: this Type-Bound Procedures procedure, public,  :: run => symRMSD_run public pure subroutine symRMSD_run (this, swap_y, x, y, w) Arguments Type Intent Optional Attributes Name class( symRMSD ), intent(in) :: this logical, intent(in) :: swap_y real(kind=RK), intent(in) :: x (*) real(kind=RK), intent(inout) :: y (*) real(kind=RK), intent(inout) :: w (*) procedure, public,  :: sd => symRMSD_sd public pure function symRMSD_sd (this, w) result(res) Arguments Type Intent Optional Attributes Name class( symRMSD ), intent(in) :: this real(kind=RK), intent(in) :: w (*) Return Value real(kind=RK) procedure, public,  :: rmsd => symRMSD_rmsd public pure function symRMSD_rmsd (this, w) result(res) Arguments Type Intent Optional Attributes Name class( symRMSD ), intent(in) :: this real(kind=RK), intent(in) :: w (*) Return Value real(kind=RK) procedure, public,  :: search_ratio => symRMSD_search_ratio public pure function symRMSD_search_ratio (this, w) result(res) Arguments Type Intent Optional Attributes Name class( symRMSD ), intent(in) :: this real(kind=RK), intent(in) :: w (*) Return Value real(kind=RK), (3) procedure, public,  :: clear => symRMSD_clear public pure elemental subroutine symRMSD_clear (this) Arguments Type Intent Optional Attributes Name class( symRMSD ), intent(inout) :: this","tags":"","loc":"type/symrmsd.html"},{"title":"d_matrix_memsize – symRMSD","text":"public pure elemental function d_matrix_memsize(a) result(res) Arguments Type Intent Optional Attributes Name type( d_matrix ), intent(in) :: a Return Value integer(kind=IK) Contents","tags":"","loc":"proc/d_matrix_memsize.html"},{"title":"d_matrix_eval – symRMSD","text":"public pure subroutine d_matrix_eval(a, ms, X, Y, W) Arguments Type Intent Optional Attributes Name type( d_matrix ), intent(in) :: a class( mol_symmetry ), intent(in) :: ms real(kind=RK), intent(in) :: X (*) real(kind=RK), intent(in) :: Y (*) real(kind=RK), intent(inout) :: W (*) Contents","tags":"","loc":"proc/d_matrix_eval.html"},{"title":"d_matrix_partial_eval – symRMSD","text":"public pure subroutine d_matrix_partial_eval(a, p, iprm, isym, ires, W, LT, H, C, LF, LB) Arguments Type Intent Optional Attributes Name type( d_matrix ), intent(in) :: a integer(kind=IK), intent(in) :: p integer(kind=IK), intent(in) :: iprm integer(kind=IK), intent(in) :: isym integer(kind=IK), intent(in) :: ires (*) real(kind=RK), intent(in) :: W (*) real(kind=RK), intent(inout) :: LT real(kind=RK), intent(inout) :: H real(kind=RK), intent(inout) :: C (*) real(kind=RK), intent(inout), optional :: LF real(kind=RK), intent(inout), optional :: LB Contents","tags":"","loc":"proc/d_matrix_partial_eval.html"},{"title":"d_matrix – symRMSD","text":"public interface d_matrix Contents Module Procedures d_matrix_new Module Procedures private pure elemental function d_matrix_new(p, d, nk, b) result(res) generator Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: p integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: nk type( mol_block ), intent(in) :: b Return Value type( d_matrix )","tags":"","loc":"interface/d_matrix.html"},{"title":"d_matrix_list – symRMSD","text":"public interface d_matrix_list Contents Module Procedures d_matrix_list_new Module Procedures private pure function d_matrix_list_new(b, p) result(res) Arguments Type Intent Optional Attributes Name type( mol_block_list ), intent(in) :: b integer(kind=IK), intent(in) :: p Return Value type( d_matrix_list )","tags":"","loc":"interface/d_matrix_list.html"},{"title":"estimate_sdmin – symRMSD","text":"public pure subroutine estimate_sdmin(d, g, cov, w) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d spatial dimension real(kind=RK), intent(in) :: g sum of auto covariance matrix real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize(d). Contents","tags":"","loc":"proc/estimate_sdmin.html"},{"title":"estimate_rotation_matrix – symRMSD","text":"public pure subroutine estimate_rotation_matrix(d, g, cov, rot, w) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d spatial dimension real(kind=RK), intent(in) :: g sum of auto covariance matrix real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: rot (*) rotation d*d matrix real(kind=RK), intent(inout) :: w (*) work array, must be larger than Kabsch_worksize(d)\nif row_major, must be larger than Kabsch_worksize(n) Contents","tags":"","loc":"proc/estimate_rotation_matrix.html"},{"title":"tree – symRMSD","text":"public interface tree Contents Module Procedures tree_new Module Procedures private pure function tree_new(pw, memnode, ndepth, n_breadths) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: pw integer(kind=IK), intent(in) :: memnode integer(kind=IK), intent(in) :: ndepth integer(kind=IK), intent(in) :: n_breadths (ndepth) Return Value type( tree )","tags":"","loc":"interface/tree.html"},{"title":"group_permutation_init – symRMSD","text":"public pure subroutine group_permutation_init(this, prm) Type Bound group_permutation Arguments Type Intent Optional Attributes Name class( group_permutation ), intent(inout) :: this integer(kind=IK), intent(in) :: prm (:) permutation indices Contents","tags":"","loc":"proc/group_permutation_init.html"},{"title":"group_permutation – symRMSD","text":"public interface group_permutation Contents Module Procedures group_permutation_new Module Procedures private pure function group_permutation_new(prm) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: prm (:) permutation indices Return Value type( group_permutation )","tags":"","loc":"interface/group_permutation.html"},{"title":"group_permutation_swap – symRMSD","text":"public interface group_permutation_swap Contents Module Procedures group_permutation_swap_real Module Procedures private pure subroutine group_permutation_swap_real(this, d, X) Arguments Type Intent Optional Attributes Name class( group_permutation ), intent(in) :: this integer(kind=IK), intent(in) :: d real(kind=RK), intent(inout) :: X (*)","tags":"","loc":"interface/group_permutation_swap.html"},{"title":"mol_block_list – symRMSD","text":"public interface mol_block_list Contents Module Procedures mol_block_list_new Module Procedures private pure function mol_block_list_new(d, l, b) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: l type( mol_block ), intent(in) :: b (l) Return Value type( mol_block_list )","tags":"","loc":"interface/mol_block_list.html"},{"title":"Hungarian_value – symRMSD","text":"public pure function Hungarian_value(n, C) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: n matrix dimension real(kind=RK), intent(in) :: C (*) n*n score matrix. Return Value real(kind=RK) Contents","tags":"","loc":"proc/hungarian_value.html"},{"title":"Hungarian – symRMSD","text":"public pure subroutine Hungarian(n, C, W, piv) Hungarian method Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: n matrix dimension real(kind=RK), intent(in) :: C (*) pivot index real(kind=RK), intent(inout) :: W (*) work array integer(kind=IK), intent(inout), optional :: piv (*) n*n score matrix. Contents","tags":"","loc":"proc/hungarian.html"},{"title":"mol_symmetry – symRMSD","text":"public interface mol_symmetry Contents Module Procedures mol_symmetry_new Module Procedures private pure function mol_symmetry_new(sym) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in), optional :: sym (:,:) symmetry indices Return Value type( mol_symmetry )","tags":"","loc":"interface/mol_symmetry.html"},{"title":"branch_and_prune – symRMSD","text":"public interface branch_and_prune Contents Module Procedures branch_and_prune_new Module Procedures private pure function branch_and_prune_new(blk, ms) result(res) generate node instance Arguments Type Intent Optional Attributes Name type( mol_block_list ), intent(in) :: blk type( mol_symmetry ), intent(in), optional :: ms (*) Return Value type( branch_and_prune )","tags":"","loc":"interface/branch_and_prune.html"},{"title":"det – symRMSD","text":"public interface det Contents Module Procedures det_full det_part Module Procedures private pure subroutine det_full(d, x) calculate determinant of square matrix x. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) square matrix, on exit, x(1) is assigned the determinant of x,\nand the other elements are undefined. private pure subroutine det_part(d, x, ld) calculate determinant of square matrix x, with leading dimension.\n& Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) square matrix, on exit, x(1) is assigned the determinant of x,\nand the other elements are undefined. integer(kind=IK), intent(in) :: ld leading dimension","tags":"","loc":"interface/det.html"},{"title":"det_ – symRMSD","text":"public interface det_ Contents Module Procedures det_func Module Procedures private pure function det_func(d, x) result(res) calculate determinant of square matrix x. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(in) :: x (d,d) square matrix, on exit, x(1) is assigned the determinant of x,\nand the other elements are undefined. Return Value real(kind=RK)","tags":"","loc":"interface/det_.html"},{"title":"det_sign – symRMSD","text":"public interface det_sign Contents Module Procedures det_sign_copy det_sign_full det_sign_part Module Procedures private pure subroutine det_sign_copy(d, x, w) calculate determinant sign of square matrix x, with leading dimension. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(in) :: x (*) d * d square matrix. real(kind=RK), intent(inout) :: w (*) work array, on exit, w(1) is assigned the determinant sign of x. private pure subroutine det_sign_full(d, x) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) square matrix, on exit, x(1) is assigned the determinant sign of x, and the other elements are undefined. private pure subroutine det_sign_part(d, x, ld) calculate determinant sign of square matrix x, with leading dimension. & Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) square matrix, on exit, x(1) is assigned the determinant sign of x, and the other elements are undefined. integer(kind=IK), intent(in) :: ld leading dimension","tags":"","loc":"interface/det_sign.html"},{"title":"symRMSD_new – symRMSD","text":"public pure function symRMSD_new(inp) result(res) Arguments Type Intent Optional Attributes Name type( symRMSD_input ), intent(in) :: inp Return Value type( symRMSD ) Contents","tags":"","loc":"proc/symrmsd_new.html"},{"title":"symRMSD_sd – symRMSD","text":"public pure function symRMSD_sd(this, w) result(res) Type Bound symRMSD Arguments Type Intent Optional Attributes Name class( symRMSD ), intent(in) :: this real(kind=RK), intent(in) :: w (*) Return Value real(kind=RK) Contents","tags":"","loc":"proc/symrmsd_sd.html"},{"title":"symRMSD_rmsd – symRMSD","text":"public pure function symRMSD_rmsd(this, w) result(res) Type Bound symRMSD Arguments Type Intent Optional Attributes Name class( symRMSD ), intent(in) :: this real(kind=RK), intent(in) :: w (*) Return Value real(kind=RK) Contents","tags":"","loc":"proc/symrmsd_rmsd.html"},{"title":"symRMSD_search_ratio – symRMSD","text":"public pure function symRMSD_search_ratio(this, w) result(res) Type Bound symRMSD Arguments Type Intent Optional Attributes Name class( symRMSD ), intent(in) :: this real(kind=RK), intent(in) :: w (*) Return Value real(kind=RK), (3) Contents","tags":"","loc":"proc/symrmsd_search_ratio.html"},{"title":"symRMSD_input_add_molecule – symRMSD","text":"public pure subroutine symRMSD_input_add_molecule(this, b, s) Type Bound symRMSD_input Arguments Type Intent Optional Attributes Name class( symRMSD_input ), intent(inout) :: this type( mol_block ), intent(in) :: b integer(kind=IK), intent(in) :: s (*) Contents","tags":"","loc":"proc/symrmsd_input_add_molecule.html"},{"title":"symRMSD_input_clear – symRMSD","text":"public pure elemental subroutine symRMSD_input_clear(this) Type Bound symRMSD_input Arguments Type Intent Optional Attributes Name class( symRMSD_input ), intent(inout) :: this Contents","tags":"","loc":"proc/symrmsd_input_clear.html"},{"title":"symRMSD_input_destroy – symRMSD","text":"public pure elemental subroutine symRMSD_input_destroy(this) Arguments Type Intent Optional Attributes Name type( symRMSD_input ), intent(inout) :: this Contents","tags":"","loc":"proc/symrmsd_input_destroy.html"},{"title":"symRMSD_run – symRMSD","text":"public pure subroutine symRMSD_run(this, swap_y, x, y, w) Type Bound symRMSD Arguments Type Intent Optional Attributes Name class( symRMSD ), intent(in) :: this logical, intent(in) :: swap_y real(kind=RK), intent(in) :: x (*) real(kind=RK), intent(inout) :: y (*) real(kind=RK), intent(inout) :: w (*) Contents","tags":"","loc":"proc/symrmsd_run.html"},{"title":"symRMSD_clear – symRMSD","text":"public pure elemental subroutine symRMSD_clear(this) Type Bound symRMSD Arguments Type Intent Optional Attributes Name class( symRMSD ), intent(inout) :: this Contents","tags":"","loc":"proc/symrmsd_clear.html"},{"title":"symRMSD_destroy – symRMSD","text":"public pure elemental subroutine symRMSD_destroy(this) Arguments Type Intent Optional Attributes Name type( symRMSD ), intent(inout) :: this Contents","tags":"","loc":"proc/symrmsd_destroy.html"},{"title":"symRMSD – symRMSD","text":"public interface symRMSD Contents Module Procedures symRMSD_new Module Procedures public pure function symRMSD_new (inp) result(res) Arguments Type Intent Optional Attributes Name type( symRMSD_input ), intent(in) :: inp Return Value type( symRMSD )","tags":"","loc":"interface/symrmsd.html"},{"title":"swp – symRMSD","text":"pure function swp(d, m, n, per, sym, ms, X) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: m integer(kind=IK), intent(in) :: n integer(kind=IK), intent(in) :: per (:) integer(kind=IK), intent(in) :: sym (:) type( mol_symmetry ), intent(in) :: ms real(kind=RK), intent(in) :: X (d,m,n) Return Value real(kind=RK), (d,m*n) Contents","tags":"","loc":"proc/swp.html"},{"title":"sd – symRMSD","text":"pure function sd(d, X, Y) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d real(kind=RK), intent(in) :: X (:,:) real(kind=RK), intent(in) :: Y (:,:) Return Value real(kind=RK) Contents","tags":"","loc":"proc/sd.html"},{"title":"sample – symRMSD","text":"function sample(d, n) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n Return Value real(kind=RK), (d,n) Contents","tags":"","loc":"proc/sample.html"},{"title":"test1 – symRMSD","text":"subroutine test1() Arguments None Contents None","tags":"","loc":"proc/test1.html"},{"title":"test2 – symRMSD","text":"subroutine test2() Arguments None Contents None","tags":"","loc":"proc/test2.html"},{"title":"SO3 – symRMSD","text":"function SO3() result(res) Arguments None Return Value real(kind=RK), (3,3) Contents None","tags":"","loc":"proc/so3.html"},{"title":"PER3 – symRMSD","text":"function PER3() result(res) Arguments None Return Value real(kind=RK), (3,3) Contents None","tags":"","loc":"proc/per3.html"},{"title":"PER15 – symRMSD","text":"function PER15() result(res) Arguments None Return Value real(kind=RK), (15,15) Contents None","tags":"","loc":"proc/per15.html"},{"title":"eye – symRMSD","text":"pure function eye(d) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d Return Value real(kind=RK), (d,d) Contents","tags":"","loc":"proc/eye.html"},{"title":"sample – symRMSD","text":"function sample(d, n) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n Return Value real(kind=RK), (d,n) Contents","tags":"","loc":"proc/sample~2.html"},{"title":"centroid – symRMSD","text":"pure function centroid(d, n, X) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n real(kind=RK), intent(in) :: X (d,n) Return Value real(kind=RK), (d) Contents","tags":"","loc":"proc/centroid.html"},{"title":"test1 – symRMSD","text":"subroutine test1(fail) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: fail Contents","tags":"","loc":"proc/test1~2.html"},{"title":"centering – symRMSD","text":"pure subroutine centering(d, n, X) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n real(kind=RK), intent(inout) :: X (d,n) Contents","tags":"","loc":"proc/centering.html"},{"title":"test1 – symRMSD","text":"subroutine test1() Arguments None Contents None","tags":"","loc":"proc/test1~3.html"},{"title":"test2 – symRMSD","text":"subroutine test2() Arguments None Contents None","tags":"","loc":"proc/test2~2.html"},{"title":"test3 – symRMSD","text":"subroutine test3() Arguments None Contents None","tags":"","loc":"proc/test3.html"},{"title":"test4 – symRMSD","text":"subroutine test4() Arguments None Contents None","tags":"","loc":"proc/test4.html"},{"title":"test5 – symRMSD","text":"subroutine test5() Arguments None Contents None","tags":"","loc":"proc/test5.html"},{"title":"sample – symRMSD","text":"function sample(d, n, com) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n integer, intent(in) :: com (d) Return Value real(kind=RK), (d,n) Contents","tags":"","loc":"proc/sample~3.html"},{"title":"test0 – symRMSD","text":"subroutine test0() Arguments None Contents None","tags":"","loc":"proc/test0.html"},{"title":"test1 – symRMSD","text":"subroutine test1() Arguments None Contents None","tags":"","loc":"proc/test1~4.html"},{"title":"test1 – symRMSD","text":"subroutine test1() Arguments None Contents None","tags":"","loc":"proc/test1~5.html"},{"title":"pe – symRMSD","text":"function pe(dm, d, l, iper, jper, isym, W) result(res) Arguments Type Intent Optional Attributes Name type( d_matrix_list ), intent(in) :: dm integer, intent(in) :: d integer, intent(in) :: l integer, intent(in) :: iper (l,l) integer, intent(in) :: jper (l) integer, intent(in) :: isym (l) real(kind=RK), intent(in) :: W (*) Return Value real(kind=RK) Contents","tags":"","loc":"proc/pe.html"},{"title":"sample – symRMSD","text":"function sample(d, n) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n Return Value real(kind=RK), (d,n) Contents","tags":"","loc":"proc/sample~4.html"},{"title":"SO3 – symRMSD","text":"function SO3() result(res) Arguments None Return Value real(kind=RK), (3,3) Contents None","tags":"","loc":"proc/so3~2.html"},{"title":"swp – symRMSD","text":"pure function swp(d, m, n, per, sym, ms, X) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: m integer(kind=IK), intent(in) :: n integer(kind=IK), intent(in) :: per (:) integer(kind=IK), intent(in) :: sym (:) type( mol_symmetry ), intent(in) :: ms real(kind=RK), intent(in) :: X (d,m,n) Return Value real(kind=RK), (d,m*n) Contents","tags":"","loc":"proc/swp~2.html"},{"title":"sd – symRMSD","text":"pure function sd(d, X, Y) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d real(kind=RK), intent(in) :: X (:,:) real(kind=RK), intent(in) :: Y (:,:) Return Value real(kind=RK) Contents","tags":"","loc":"proc/sd~2.html"},{"title":"test1 – symRMSD","text":"subroutine test1() Arguments None Contents None","tags":"","loc":"proc/test1~6.html"},{"title":"test2 – symRMSD","text":"subroutine test2() Arguments None Contents None","tags":"","loc":"proc/test2~3.html"},{"title":"test3 – symRMSD","text":"subroutine test3() Arguments None Contents None","tags":"","loc":"proc/test3~2.html"},{"title":"copy – symRMSD","text":"pure subroutine copy(d, source, dest) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d real(kind=RK), intent(in) :: source (*) real(kind=RK), intent(inout) :: dest (*) Contents","tags":"","loc":"proc/copy.html"},{"title":"SP – symRMSD","text":"pure function SP(n, ix, C) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: ix (n) real(kind=RK), intent(in) :: C (n,n) Return Value real(kind=RK) Contents","tags":"","loc":"proc/sp.html"},{"title":"test1 – symRMSD","text":"subroutine test1() Arguments None Contents None","tags":"","loc":"proc/test1~7.html"},{"title":"test2 – symRMSD","text":"subroutine test2() Arguments None Contents None","tags":"","loc":"proc/test2~4.html"},{"title":"SO – symRMSD","text":"recursive function SO(d) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d Return Value real(kind=RK), (d,d) Contents","tags":"","loc":"proc/so.html"},{"title":"eye – symRMSD","text":"pure function eye(d) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d Return Value real(kind=RK), (d,d) Contents","tags":"","loc":"proc/eye~2.html"},{"title":"test1 – symRMSD","text":"subroutine test1(d, n, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n integer, intent(in) :: n_test Contents","tags":"","loc":"proc/test1~8.html"},{"title":"test1 – symRMSD","text":"subroutine test1() Arguments None Contents None","tags":"","loc":"proc/test1~9.html"},{"title":"sample – symRMSD","text":"function sample(d, n, com) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n integer, intent(in) :: com (d) Return Value real(kind=RK), (d,n) Contents","tags":"","loc":"proc/sample~5.html"},{"title":"test1 – symRMSD","text":"subroutine test1() Arguments None Contents None","tags":"","loc":"proc/test1~10.html"},{"title":"add_molecule – symRMSD","text":"public  subroutine add_molecule(m, n, s, sym) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: m integer(kind=ik), intent(in) :: n integer(kind=ik), intent(in) :: s integer(kind=ik), intent(in) :: sym (*) Contents","tags":"","loc":"proc/add_molecule.html"},{"title":"setup – symRMSD","text":"public  subroutine setup() Arguments None Contents None","tags":"","loc":"proc/setup.html"},{"title":"run – symRMSD","text":"public  subroutine run(x, y, n, rmsd, log_ratio, nsearch) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x (*) real(kind=rk), intent(inout) :: y (*) integer(kind=ik), intent(in) :: n real(kind=rk), intent(out) :: rmsd (n) real(kind=rk), intent(out) :: log_ratio (n) integer(kind=ik), intent(out) :: nsearch (n) Contents","tags":"","loc":"proc/run.html"},{"title":"clear – symRMSD","text":"public  subroutine clear() Arguments None Contents None","tags":"","loc":"proc/clear.html"},{"title":"mod_d_matrix – symRMSD","text":"! d_matrix_list ! util Uses mod_params mod_mol_block mod_Hungarian mod_estimate_rotation_matrix mod_mol_symmetry Contents Interfaces d_matrix d_matrix_list Derived Types d_matrix d_matrix_list Functions d_matrix_memsize Subroutines d_matrix_eval d_matrix_partial_eval Interfaces public        interface d_matrix private pure elemental function d_matrix_new(p, d, nk, b) result(res) generator Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: p integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: nk type( mol_block ), intent(in) :: b Return Value type( d_matrix ) public        interface d_matrix_list private pure function d_matrix_list_new(b, p) result(res) Arguments Type Intent Optional Attributes Name type( mol_block_list ), intent(in) :: b integer(kind=IK), intent(in) :: p Return Value type( d_matrix_list ) Derived Types type, public, sequence  :: d_matrix Components Type Visibility Attributes Name Initial integer(kind=IK), public :: s integer(kind=IK), public :: m integer(kind=IK), public :: n integer(kind=IK), public :: g Constructor private\n\n                    pure, elemental\n                    function d_matrix_new (p, d, nk, b) generator type, public :: d_matrix_list Components Type Visibility Attributes Name Initial integer(kind=IK), public :: h = 0 integer(kind=IK), public :: v = 0 integer(kind=IK), public :: c = 0 integer(kind=IK), public :: o = 0 integer(kind=IK), public :: d = 0 integer(kind=IK), public :: l = 0 integer(kind=IK), public :: dd = 0 integer(kind=IK), public :: nk type( d_matrix ), public, allocatable :: m (:) Constructor private\n\n                    pure\n                    function d_matrix_list_new (b, p) Finalizations Procedures final :: d_matrix_list_destroy Type-Bound Procedures procedure\n                    ,                  public\n,                   :: n_depth =>\n                    d_matrix_list_n_depth Function procedure\n                    ,                  public\n,                   :: eval =>\n                    d_matrix_list_eval Subroutine procedure\n                    ,                  public\n,                   :: partial_eval =>\n                    d_matrix_list_partial_eval Subroutine procedure\n                    ,                  public\n,                   :: memsize =>\n                    d_matrix_list_memsize Function procedure\n                    ,                  public\n,                   :: clear =>\n                    d_matrix_list_clear Subroutine Functions public pure elemental function d_matrix_memsize (a) result(res) Arguments Type Intent Optional Attributes Name type( d_matrix ), intent(in) :: a Return Value integer(kind=IK) Subroutines public pure subroutine d_matrix_eval (a, ms, X, Y, W) Arguments Type Intent Optional Attributes Name type( d_matrix ), intent(in) :: a class( mol_symmetry ), intent(in) :: ms real(kind=RK), intent(in) :: X (*) real(kind=RK), intent(in) :: Y (*) real(kind=RK), intent(inout) :: W (*) public pure subroutine d_matrix_partial_eval (a, p, iprm, isym, ires, W, LT, H, C, LF, LB) Arguments Type Intent Optional Attributes Name type( d_matrix ), intent(in) :: a integer(kind=IK), intent(in) :: p integer(kind=IK), intent(in) :: iprm integer(kind=IK), intent(in) :: isym integer(kind=IK), intent(in) :: ires (*) real(kind=RK), intent(in) :: W (*) real(kind=RK), intent(inout) :: LT real(kind=RK), intent(inout) :: H real(kind=RK), intent(inout) :: C (*) real(kind=RK), intent(inout), optional :: LF real(kind=RK), intent(inout), optional :: LB","tags":"","loc":"module/mod_d_matrix.html"},{"title":"mod_estimate_rotation_matrix – symRMSD","text":"Calculate the rotation matrix that minimizes |X-RY|&#94;2 using the Kabsch-Umeyama algorithm.\n Here, RR&#94;T=I and det(R)=1 are satisfied. Uses mod_params mod_det Contents Subroutines estimate_sdmin estimate_rotation_matrix Subroutines public pure subroutine estimate_sdmin (d, g, cov, w) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d spatial dimension real(kind=RK), intent(in) :: g sum of auto covariance matrix real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize(d). public pure subroutine estimate_rotation_matrix (d, g, cov, rot, w) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d spatial dimension real(kind=RK), intent(in) :: g sum of auto covariance matrix real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: rot (*) rotation d*d matrix real(kind=RK), intent(inout) :: w (*) work array, must be larger than Kabsch_worksize(d)\nif row_major, must be larger than Kabsch_worksize(n)","tags":"","loc":"module/mod_estimate_rotation_matrix.html"},{"title":"mod_tree – symRMSD","text":"Uses mod_params Contents Interfaces tree Derived Types tree Interfaces public        interface tree private pure function tree_new(pw, memnode, ndepth, n_breadths) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: pw integer(kind=IK), intent(in) :: memnode integer(kind=IK), intent(in) :: ndepth integer(kind=IK), intent(in) :: n_breadths (ndepth) Return Value type( tree ) Derived Types type, public :: tree Components Type Visibility Attributes Name Initial integer(kind=IK), public :: ubnode = 0 integer(kind=IK), public :: memnode = 0 integer(kind=IK), public :: memsize = 0 integer(kind=IK), public :: upperbound = 0 integer(kind=IK), public :: lowerbound = 0 Constructor private\n\n                    pure\n                    function tree_new (pw, memnode, ndepth, n_breadths) Finalizations Procedures final :: tree_destroy Type-Bound Procedures procedure\n                    ,                  public\n,                   :: n_depth =>\n                    tree_n_depth Function procedure\n                    ,                  public\n,                   :: n_breadth =>\n                    tree_n_breadth Function procedure\n                    ,                  public\n,                   :: current_depth =>\n                    tree_current_depth Function procedure\n                    ,                  public\n,                   :: reset =>\n                    tree_reset Subroutine procedure\n                    ,                  public\n,                   :: set_parent_node =>\n                    tree_set_parent_node Subroutine procedure\n                    ,                  public\n,                   :: set_lowerbound =>\n                    tree_set_lowerbound Subroutine procedure\n                    ,                  public\n,                   :: prune =>\n                    tree_prune Subroutine procedure\n                    ,                  public\n,                   :: nodes_pointer =>\n                    tree_nodes_pointer Function procedure\n                    ,                  public\n,                   :: parent_pointer =>\n                    tree_parent_pointer Function procedure\n                    ,                  public\n,                   :: parent_index =>\n                    tree_parent_index Function procedure\n                    ,                  public\n,                   :: current_pointer =>\n                    tree_current_pointer Function procedure\n                    ,                  public\n,                   :: current_index =>\n                    tree_current_index Function procedure\n                    ,                  public\n,                   :: alive_nodes =>\n                    tree_alive_nodes Function procedure\n                    ,                  public\n,                   :: open_node =>\n                    tree_open_node Subroutine procedure\n                    ,                  public\n,                   :: close_node =>\n                    tree_close_node Subroutine procedure\n                    ,                  public\n,                   :: log_ncomb =>\n                    tree_log_ncomb Function procedure\n                    ,                  public\n,                   :: finished =>\n                    tree_finished Function procedure\n                    ,                  public\n,                   :: unfinished =>\n                    tree_unfinished Function procedure\n                    ,                  public\n,                   :: clear =>\n                    tree_clear Subroutine","tags":"","loc":"module/mod_tree.html"},{"title":"mod_group_permutation – symRMSD","text":"! returns uniq integer list without 1. Uses mod_params Contents Interfaces group_permutation group_permutation_swap Derived Types group_permutation Subroutines group_permutation_init Interfaces public        interface group_permutation private pure function group_permutation_new(prm) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: prm (:) permutation indices Return Value type( group_permutation ) public        interface group_permutation_swap private pure subroutine group_permutation_swap_real(this, d, X) Arguments Type Intent Optional Attributes Name class( group_permutation ), intent(in) :: this integer(kind=IK), intent(in) :: d real(kind=RK), intent(inout) :: X (*) Derived Types type, public :: group_permutation Constructor private\n\n                    pure\n                    function group_permutation_new (prm) Constructer Finalizations Procedures final :: group_permutation_destroy Type-Bound Procedures procedure\n                    ,                  public\n,                   :: init => group_permutation_init Subroutine procedure\n                    ,                  public\n,                   :: nfree =>\n                    group_permutation_nfree Function procedure\n                    ,                  public\n,                   :: free_indices =>\n                    group_permutation_free_indices Function procedure\n                    ,                  public\n,                   :: swap =>\n                    group_permutation_swap_real Subroutine procedure\n                    ,                  public\n,                   :: reverse =>\n                    group_permutation_reverse_real Subroutine procedure\n                    ,                  public\n,                   :: clear =>\n                    group_permutation_clear Subroutine Subroutines public pure subroutine group_permutation_init (this, prm) Arguments Type Intent Optional Attributes Name class( group_permutation ), intent(inout) :: this integer(kind=IK), intent(in) :: prm (:) permutation indices","tags":"","loc":"module/mod_group_permutation.html"},{"title":"mod_mol_block – symRMSD","text":"molecular coodinate block indicator Uses mod_params Contents Interfaces mol_block_list Derived Types mol_block mol_block_list Interfaces public        interface mol_block_list private pure function mol_block_list_new(d, l, b) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: l type( mol_block ), intent(in) :: b (l) Return Value type( mol_block_list ) Derived Types type, public, sequence  :: mol_block molecular block indicator\n atomic coordinates vector must be stored in the following format.\n   X(d,m,n)\n   - d :: spatial dimension.\n   - m :: number of atom in a molecule.\n   - n :: number of molecule.\n   - where X(d,:f,:g)     :: Free rotatable.\n   -       X(d,f+1:,g+1:) :: Fixed. Components Type Visibility Attributes Name Initial integer(kind=IK), public :: p = 1 integer(kind=IK), public :: s = 1 integer(kind=IK), public :: m = 1 integer(kind=IK), public :: n = 1 integer(kind=IK), public :: f = 1 integer(kind=IK), public :: g = 1 type, public :: mol_block_list Components Type Visibility Attributes Name Initial integer(kind=IK), public :: d = 0 integer(kind=IK), public :: mg = 0 integer(kind=IK), public :: mn = 0 type( mol_block ), public, allocatable :: b (:) Constructor private\n\n                    pure\n                    function mol_block_list_new (d, l, b) Finalizations Procedures final :: mol_block_list_destroy Type-Bound Procedures procedure\n                    ,                  public\n,                   :: add_molecule =>\n                    mol_block_list_add_molecule Subroutine procedure\n                    ,                  public\n,                   :: child =>\n                    mol_block_list_child Function procedure\n                    ,                  public\n,                   :: invalid =>\n                    mol_block_list_invalid Function procedure\n                    ,                  public\n,                   :: natom =>\n                    mol_block_list_natom Function procedure\n                    ,                  public\n,                   :: nspatial =>\n                    mol_block_list_nspatial Function procedure\n                    ,                  public\n,                   :: nspecies =>\n                    mol_block_list_nspecies Function procedure\n                    ,                  public\n,                   :: ispecies =>\n                    mol_block_list_ispecies Function procedure\n                    ,                  public\n,                   :: ipointer =>\n                    mol_block_list_ipointer Function procedure\n                    ,                  public\n,                   :: n_res =>\n                    mol_block_list_n_res Function procedure\n                    ,                  public\n,                   :: res_pointer =>\n                    mol_block_list_res_pointer Function procedure\n                    ,                  public\n,                   :: has_child =>\n                    mol_block_list_has_child Function procedure\n                    ,                  public\n,                   :: clear =>\n                    mol_block_list_clear Subroutine","tags":"","loc":"module/mod_mol_block.html"},{"title":"mod_Hungarian – symRMSD","text":"Uses mod_params Contents Functions Hungarian_value Subroutines Hungarian Functions public pure function Hungarian_value (n, C) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: n matrix dimension real(kind=RK), intent(in) :: C (*) n*n score matrix. Return Value real(kind=RK) Subroutines public pure subroutine Hungarian (n, C, W, piv) Hungarian method Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: n matrix dimension real(kind=RK), intent(in) :: C (*) pivot index real(kind=RK), intent(inout) :: W (*) work array integer(kind=IK), intent(inout), optional :: piv (*) n*n score matrix.","tags":"","loc":"module/mod_hungarian.html"},{"title":"mod_mol_symmetry – symRMSD","text":"Uses mod_params mod_group_permutation Contents Interfaces mol_symmetry Derived Types mol_symmetry Interfaces public        interface mol_symmetry private pure function mol_symmetry_new(sym) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in), optional :: sym (:,:) symmetry indices Return Value type( mol_symmetry ) Derived Types type, public :: mol_symmetry Constructor private\n\n                    pure\n                    function mol_symmetry_new (sym) Constructer Finalizations Procedures final :: mol_symmetry_destroy Type-Bound Procedures procedure\n                    ,                  public\n,                   :: n_atom =>\n                    mol_symmetry_n_atom Function procedure\n                    ,                  public\n,                   :: n_sym =>\n                    mol_symmetry_n_sym Function procedure\n                    ,                  public\n,                   :: swap =>\n                    mol_symmetry_swap Subroutine procedure\n                    ,                  public\n,                   :: reverse =>\n                    mol_symmetry_reverse Subroutine procedure\n                    ,                  public\n,                   :: clear =>\n                    mol_symmetry_clear Subroutine","tags":"","loc":"module/mod_mol_symmetry.html"},{"title":"mod_branch_and_prune – symRMSD","text":"! Uses mod_d_matrix mod_params mod_mol_block mod_tree mod_estimate_rotation_matrix mod_mol_symmetry mod_group_permutation Contents Interfaces branch_and_prune Derived Types branch_and_prune Interfaces public        interface branch_and_prune private pure function branch_and_prune_new(blk, ms) result(res) generate node instance Arguments Type Intent Optional Attributes Name type( mol_block_list ), intent(in) :: blk type( mol_symmetry ), intent(in), optional :: ms (*) Return Value type( branch_and_prune ) Derived Types type, public :: branch_and_prune Components Type Visibility Attributes Name Initial integer(kind=IK), public :: mn integer(kind=IK), public :: dmn integer(kind=IK), public :: memsize integer(kind=IK), public :: ratio integer(kind=IK), public :: nsrch integer(kind=IK), public :: lncmb integer(kind=IK), public :: xp integer(kind=IK), public :: yp integer(kind=IK), public :: upperbound integer(kind=IK), public :: lowerbound Constructor private\n\n                    pure\n                    function branch_and_prune_new (blk, ms) generate node instance Finalizations Procedures final :: branch_and_prune_destroy Type-Bound Procedures procedure\n                    ,                  public\n,                   :: setup =>\n                    branch_and_prune_setup Subroutine procedure\n                    ,                  public\n,                   :: run =>\n                    branch_and_prune_run Subroutine procedure\n                    ,                  public\n,                   :: clear =>\n                    branch_and_prune_clear Subroutine","tags":"","loc":"module/mod_branch_and_prune.html"},{"title":"mod_det – symRMSD","text":"Uses mod_params Contents Interfaces det det_ det_sign Interfaces public        interface det private pure subroutine det_full(d, x) calculate determinant of square matrix x. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) square matrix, on exit, x(1) is assigned the determinant of x,\nand the other elements are undefined. private pure subroutine det_part(d, x, ld) calculate determinant of square matrix x, with leading dimension.\n& Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) square matrix, on exit, x(1) is assigned the determinant of x,\nand the other elements are undefined. integer(kind=IK), intent(in) :: ld leading dimension public        interface det_ private pure function det_func(d, x) result(res) calculate determinant of square matrix x. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(in) :: x (d,d) square matrix, on exit, x(1) is assigned the determinant of x,\nand the other elements are undefined. Return Value real(kind=RK) public        interface det_sign private pure subroutine det_sign_copy(d, x, w) calculate determinant sign of square matrix x, with leading dimension. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(in) :: x (*) d * d square matrix. real(kind=RK), intent(inout) :: w (*) work array, on exit, w(1) is assigned the determinant sign of x. private pure subroutine det_sign_full(d, x) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) square matrix, on exit, x(1) is assigned the determinant sign of x, and the other elements are undefined. private pure subroutine det_sign_part(d, x, ld) calculate determinant sign of square matrix x, with leading dimension. & Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) square matrix, on exit, x(1) is assigned the determinant sign of x, and the other elements are undefined. integer(kind=IK), intent(in) :: ld leading dimension","tags":"","loc":"module/mod_det.html"},{"title":"mod_params – symRMSD","text":"Uses iso_fortran_env Contents Variables IK RK LK RZERO RONE RHALF RFOUR RHUGE NEWLINE CNULL CARRET ESCSEQ FS_BOLD FS_WEAK FS_UNDER_LINE FS_INVERT FS_CROSSED_OUT FS_RESET FC_BLACK FC_RED FC_GREEN FC_YELLOW FC_MAGENTA FC_CYAN FC_WHITE Variables Type Visibility Attributes Name Initial integer, public, parameter :: IK = I4 integer, public, parameter :: RK = R8 integer, public, parameter :: LK = KIND(.true.) real(kind=RK), public, parameter :: RZERO = 0.0_RK real(kind=RK), public, parameter :: RONE = 1.0_RK real(kind=RK), public, parameter :: RHALF = 0.5_RK real(kind=RK), public, parameter :: RFOUR = 4.0_RK real(kind=RK), public, parameter :: RHUGE = HUGE(RZERO) character(len=*), public, parameter :: NEWLINE = NEW_LINE(' ') character(len=*), public, parameter :: CNULL = CHAR(0) character(len=*), public, parameter :: CARRET = CHAR(13) character(len=*), public, parameter :: ESCSEQ = CHAR(27) character(len=*), public, parameter :: FS_BOLD = ESCSEQ//'[1m' character(len=*), public, parameter :: FS_WEAK = ESCSEQ//'[2m' character(len=*), public, parameter :: FS_UNDER_LINE = ESCSEQ//'[4m' character(len=*), public, parameter :: FS_INVERT = ESCSEQ//'[7m' character(len=*), public, parameter :: FS_CROSSED_OUT = ESCSEQ//'[9m' character(len=*), public, parameter :: FS_RESET = ESCSEQ//'[0m' character(len=*), public, parameter :: FC_BLACK = ESCSEQ//'[30m' character(len=*), public, parameter :: FC_RED = ESCSEQ//'[31m' character(len=*), public, parameter :: FC_GREEN = ESCSEQ//'[32m' character(len=*), public, parameter :: FC_YELLOW = ESCSEQ//'[33m' character(len=*), public, parameter :: FC_MAGENTA = ESCSEQ//'[35m' character(len=*), public, parameter :: FC_CYAN = ESCSEQ//'[36m' character(len=*), public, parameter :: FC_WHITE = ESCSEQ//'[37m'","tags":"","loc":"module/mod_params.html"},{"title":"mod_symRMSD – symRMSD","text":"! Uses mod_params mod_mol_block mod_mol_symmetry mod_branch_and_prune Contents Interfaces symRMSD Derived Types symRMSD_input symRMSD Functions symRMSD_new symRMSD_sd symRMSD_rmsd symRMSD_search_ratio Subroutines symRMSD_input_add_molecule symRMSD_input_clear symRMSD_input_destroy symRMSD_run symRMSD_clear symRMSD_destroy Interfaces public        interface symRMSD public pure function symRMSD_new (inp) result(res) Arguments Type Intent Optional Attributes Name type( symRMSD_input ), intent(in) :: inp Return Value type( symRMSD ) Derived Types type, public :: symRMSD_input Components Type Visibility Attributes Name Initial type( mol_block_list ), public :: blk type( mol_symmetry ), public, allocatable :: ms (:) Finalizations Procedures final :: symRMSD_input_destroy Type-Bound Procedures procedure\n                    ,                  public\n,                   :: add_molecule => symRMSD_input_add_molecule Subroutine procedure\n                    ,                  public\n,                   :: clear => symRMSD_input_clear Subroutine type, public :: symRMSD Components Type Visibility Attributes Name Initial integer(kind=IK), public :: nmem = 0 integer(kind=IK), public :: ndim = 0 integer(kind=IK), public :: natm = 0 Constructor public\n\n                    pure\n                    function symRMSD_new (inp) Finalizations Procedures final :: symRMSD_destroy Type-Bound Procedures procedure\n                    ,                  public\n,                   :: run => symRMSD_run Subroutine procedure\n                    ,                  public\n,                   :: sd => symRMSD_sd Function procedure\n                    ,                  public\n,                   :: rmsd => symRMSD_rmsd Function procedure\n                    ,                  public\n,                   :: search_ratio => symRMSD_search_ratio Function procedure\n                    ,                  public\n,                   :: clear => symRMSD_clear Subroutine Functions public pure function symRMSD_new (inp) result(res) Arguments Type Intent Optional Attributes Name type( symRMSD_input ), intent(in) :: inp Return Value type( symRMSD ) public pure function symRMSD_sd (this, w) result(res) Arguments Type Intent Optional Attributes Name class( symRMSD ), intent(in) :: this real(kind=RK), intent(in) :: w (*) Return Value real(kind=RK) public pure function symRMSD_rmsd (this, w) result(res) Arguments Type Intent Optional Attributes Name class( symRMSD ), intent(in) :: this real(kind=RK), intent(in) :: w (*) Return Value real(kind=RK) public pure function symRMSD_search_ratio (this, w) result(res) Arguments Type Intent Optional Attributes Name class( symRMSD ), intent(in) :: this real(kind=RK), intent(in) :: w (*) Return Value real(kind=RK), (3) Subroutines public pure subroutine symRMSD_input_add_molecule (this, b, s) Arguments Type Intent Optional Attributes Name class( symRMSD_input ), intent(inout) :: this type( mol_block ), intent(in) :: b integer(kind=IK), intent(in) :: s (*) public pure elemental subroutine symRMSD_input_clear (this) Arguments Type Intent Optional Attributes Name class( symRMSD_input ), intent(inout) :: this public pure elemental subroutine symRMSD_input_destroy (this) Arguments Type Intent Optional Attributes Name type( symRMSD_input ), intent(inout) :: this public pure subroutine symRMSD_run (this, swap_y, x, y, w) Arguments Type Intent Optional Attributes Name class( symRMSD ), intent(in) :: this logical, intent(in) :: swap_y real(kind=RK), intent(in) :: x (*) real(kind=RK), intent(inout) :: y (*) real(kind=RK), intent(inout) :: w (*) public pure elemental subroutine symRMSD_clear (this) Arguments Type Intent Optional Attributes Name class( symRMSD ), intent(inout) :: this public pure elemental subroutine symRMSD_destroy (this) Arguments Type Intent Optional Attributes Name type( symRMSD ), intent(inout) :: this","tags":"","loc":"module/mod_symrmsd.html"},{"title":"driver – symRMSD","text":"Uses mod_params mod_symRMSD mod_mol_block mod_mol_symmetry Contents Variables swap_y Subroutines add_molecule setup run clear Variables Type Visibility Attributes Name Initial logical, public, save :: swap_y = .TRUE. Subroutines public  subroutine add_molecule (m, n, s, sym) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: m integer(kind=ik), intent(in) :: n integer(kind=ik), intent(in) :: s integer(kind=ik), intent(in) :: sym (*) public  subroutine setup () Arguments None public  subroutine run (x, y, n, rmsd, log_ratio, nsearch) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x (*) real(kind=rk), intent(inout) :: y (*) integer(kind=ik), intent(in) :: n real(kind=rk), intent(out) :: rmsd (n) real(kind=rk), intent(out) :: log_ratio (n) integer(kind=ik), intent(out) :: nsearch (n) public  subroutine clear () Arguments None","tags":"","loc":"module/driver.html"},{"title":"main – symRMSD","text":"Uses mod_params mod_mol_block mod_estimate_rotation_matrix mod_mol_symmetry mod_branch_and_prune mod_unittest Contents Variables u NTEST itest Functions swp sd sample Subroutines test1 test2 Variables Type Attributes Name Initial type(unittest) :: u integer, parameter :: NTEST = 25 integer :: itest Functions pure function swp (d, m, n, per, sym, ms, X) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: m integer(kind=IK), intent(in) :: n integer(kind=IK), intent(in) :: per (:) integer(kind=IK), intent(in) :: sym (:) type( mol_symmetry ), intent(in) :: ms real(kind=RK), intent(in) :: X (d,m,n) Return Value real(kind=RK), (d,m*n) pure function sd (d, X, Y) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d real(kind=RK), intent(in) :: X (:,:) real(kind=RK), intent(in) :: Y (:,:) Return Value real(kind=RK) function sample (d, n) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n Return Value real(kind=RK), (d,n) Subroutines subroutine test1 () Arguments None subroutine test2 () Arguments None","tags":"","loc":"program/main.html"},{"title":"main – symRMSD","text":"Uses mod_params mod_rmsd_brute mod_partial_rmsd mod_rmsd mod_unittest Contents Variables u NTEST fail i Functions SO3 PER3 PER15 eye sample centroid Subroutines test1 centering Variables Type Attributes Name Initial type(unittest) :: u integer, parameter :: NTEST = 1000 integer :: fail integer :: i Functions function SO3 () result(res) Arguments None Return Value real(kind=RK), (3,3) function PER3 () result(res) Arguments None Return Value real(kind=RK), (3,3) function PER15 () result(res) Arguments None Return Value real(kind=RK), (15,15) pure function eye (d) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d Return Value real(kind=RK), (d,d) function sample (d, n) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n Return Value real(kind=RK), (d,n) pure function centroid (d, n, X) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n real(kind=RK), intent(in) :: X (d,n) Return Value real(kind=RK), (d) Subroutines subroutine test1 (fail) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: fail pure subroutine centering (d, n, X) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n real(kind=RK), intent(inout) :: X (d,n)","tags":"","loc":"program/main~2.html"},{"title":"main – symRMSD","text":"Uses mod_params mod_det mod_unittest Contents Variables u Subroutines test1 test2 test3 test4 test5 Variables Type Attributes Name Initial type(unittest) :: u Subroutines subroutine test1 () Arguments None subroutine test2 () Arguments None subroutine test3 () Arguments None subroutine test4 () Arguments None subroutine test5 () Arguments None","tags":"","loc":"program/main~3.html"},{"title":"main – symRMSD","text":"Uses mod_params mod_symRMSD mod_mol_block mod_unittest Contents Variables u NTEST itest Functions sample Subroutines test0 test1 Variables Type Attributes Name Initial type(unittest) :: u integer, parameter :: NTEST = 1 integer :: itest Functions function sample (d, n, com) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n integer, intent(in) :: com (d) Return Value real(kind=RK), (d,n) Subroutines subroutine test0 () Arguments None subroutine test1 () Arguments None","tags":"","loc":"program/main~4.html"},{"title":"main – symRMSD","text":"Uses mod_params mod_tree mod_unittest Contents Variables u Subroutines test1 Variables Type Attributes Name Initial type(unittest) :: u Subroutines subroutine test1 () Arguments None","tags":"","loc":"program/main~5.html"},{"title":"main – symRMSD","text":"Uses mod_d_matrix mod_params mod_mol_block mod_estimate_rotation_matrix mod_mol_symmetry mod_unittest Contents Variables u Functions pe sample SO3 swp sd Subroutines test1 test2 test3 copy Variables Type Attributes Name Initial type(unittest) :: u Functions function pe (dm, d, l, iper, jper, isym, W) result(res) Arguments Type Intent Optional Attributes Name type( d_matrix_list ), intent(in) :: dm integer, intent(in) :: d integer, intent(in) :: l integer, intent(in) :: iper (l,l) integer, intent(in) :: jper (l) integer, intent(in) :: isym (l) real(kind=RK), intent(in) :: W (*) Return Value real(kind=RK) function sample (d, n) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n Return Value real(kind=RK), (d,n) function SO3 () result(res) Arguments None Return Value real(kind=RK), (3,3) pure function swp (d, m, n, per, sym, ms, X) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: m integer(kind=IK), intent(in) :: n integer(kind=IK), intent(in) :: per (:) integer(kind=IK), intent(in) :: sym (:) type( mol_symmetry ), intent(in) :: ms real(kind=RK), intent(in) :: X (d,m,n) Return Value real(kind=RK), (d,m*n) pure function sd (d, X, Y) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d real(kind=RK), intent(in) :: X (:,:) real(kind=RK), intent(in) :: Y (:,:) Return Value real(kind=RK) Subroutines subroutine test1 () Arguments None subroutine test2 () Arguments None subroutine test3 () Arguments None pure subroutine copy (d, source, dest) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d real(kind=RK), intent(in) :: source (*) real(kind=RK), intent(inout) :: dest (*)","tags":"","loc":"program/main~6.html"},{"title":"main – symRMSD","text":"Uses mod_params mod_Hungarian mod_unittest Contents Variables u NTEST itest Functions SP Subroutines test1 test2 Variables Type Attributes Name Initial type(unittest) :: u integer(kind=IK), parameter :: NTEST = 25 integer(kind=IK) :: itest Functions pure function SP (n, ix, C) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: ix (n) real(kind=RK), intent(in) :: C (n,n) Return Value real(kind=RK) Subroutines subroutine test1 () Arguments None subroutine test2 () Arguments None","tags":"","loc":"program/main~7.html"},{"title":"main – symRMSD","text":"Uses mod_params mod_estimate_rotation_matrix mod_unittest Contents Variables z E2 E3 E6 Functions SO eye Subroutines test1 Variables Type Attributes Name Initial type(unittest) :: z real(kind=RK) :: E2 (2,2) real(kind=RK) :: E3 (3,3) real(kind=RK) :: E6 (6,6) Functions recursive function SO (d) result(res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d Return Value real(kind=RK), (d,d) pure function eye (d) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d Return Value real(kind=RK), (d,d) Subroutines subroutine test1 (d, n, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n integer, intent(in) :: n_test","tags":"","loc":"program/main~8.html"},{"title":"main – symRMSD","text":"Uses mod_params mod_unittest mod_group_permutation Contents Variables u Subroutines test1 Variables Type Attributes Name Initial type(unittest) :: u Subroutines subroutine test1 () Arguments None","tags":"","loc":"program/main~9.html"},{"title":"main – symRMSD","text":"Uses mod_params driver mod_unittest Contents Variables u NTEST itest Functions sample Subroutines test1 Variables Type Attributes Name Initial type(unittest) :: u integer, parameter :: NTEST = 2 integer :: itest Functions function sample (d, n, com) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n integer, intent(in) :: com (d) Return Value real(kind=RK), (d,n) Subroutines subroutine test1 () Arguments None","tags":"","loc":"program/main~10.html"},{"title":"mod_d_matrix.f90 – symRMSD","text":"Contents Modules mod_d_matrix Source Code mod_d_matrix.f90 Source Code module mod_d_matrix use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO , RHUGE use mod_mol_symmetry use mod_mol_block use mod_estimate_rotation_matrix use mod_Hungarian implicit none private public :: d_matrix public :: d_matrix_list public :: d_matrix_memsize public :: d_matrix_eval public :: d_matrix_partial_eval ! type d_matrix private sequence integer ( IK ), public :: s , m , n , g integer ( IK ) :: d , dd , gg , dm , cb , cl , nw1 , nw2 integer ( IK ) :: x , z , c end type d_matrix ! interface d_matrix module procedure d_matrix_new end interface d_matrix ! type d_matrix_list integer ( IK ) :: h = 0 integer ( IK ) :: v = 0 integer ( IK ) :: c = 0 integer ( IK ) :: o = 0 integer ( IK ) :: d = 0 integer ( IK ) :: l = 0 integer ( IK ) :: dd = 0 integer ( IK ) :: nk type ( d_matrix ), allocatable :: m (:) contains procedure :: n_depth => d_matrix_list_n_depth procedure :: eval => d_matrix_list_eval procedure :: partial_eval => d_matrix_list_partial_eval procedure :: memsize => d_matrix_list_memsize procedure :: clear => d_matrix_list_clear final :: d_matrix_list_destroy end type d_matrix_list ! interface d_matrix_list module procedure d_matrix_list_new end interface d_matrix_list ! interface include 'dgemm.h' include 'ddot.h' include 'dcopy.h' end interface ! contains !| generator pure elemental function d_matrix_new ( p , d , nk , b ) result ( res ) integer ( IK ), intent ( in ) :: p , d , nk type ( mol_block ), intent ( in ) :: b type ( d_matrix ) :: res ! res % d = MAX ( d , 1 ) res % s = MAX ( b % s , 1 ) res % m = MAX ( b % m , 0 ) res % n = MAX ( b % n , 0 ) if ( b % g == 1 . and . res % s == 1 ) then res % g = 0 else res % g = MIN ( res % n , MAX ( b % g , 0 )) end if res % dd = res % d * res % d res % gg = res % g * res % g res % dm = res % d * res % m res % cb = res % dd * res % s + 1 res % cl = res % cb * res % g ! res % x = b % p res % z = p res % c = res % z + res % gg res % nw1 = 3 + res % dm * 2 + res % dd + nk res % nw2 = 1 + res % dd + nk ! end function d_matrix_new ! pure elemental function d_matrix_memsize ( a ) result ( res ) type ( d_matrix ), intent ( in ) :: a integer ( IK ) :: res res = ( a % cb + 1 ) * a % gg end function d_matrix_memsize ! pure subroutine d_matrix_eval ( a , ms , X , Y , W ) type ( d_matrix ), intent ( in ) :: a class ( mol_symmetry ), intent ( in ) :: ms real ( RK ), intent ( in ) :: X ( * ) real ( RK ), intent ( in ) :: Y ( * ) real ( RK ), intent ( inout ) :: W ( * ) ! call eval ( a % d , a % s , a % m , a % g , a % dd , a % dm , a % cb , a % nw1 , ms , X ( a % x ), Y ( a % x ), W ( a % z ), W ( a % c )) ! contains ! pure subroutine eval ( d , s , m , g , dd , dm , cb , nw , r , X , Y , Z , C ) integer ( IK ), intent ( in ) :: d , s , m , g integer ( IK ), intent ( in ) :: dd , dm , cb , nw type ( mol_symmetry ), intent ( in ) :: r real ( RK ), intent ( in ) :: X ( d , m , g ) real ( RK ), intent ( in ) :: Y ( d , m , g ) real ( RK ), intent ( inout ) :: Z ( g , g ) real ( RK ), intent ( inout ) :: C ( cb , g , g ) integer ( IK ), parameter :: ib = 1 integer ( IK ), parameter :: it = 2 integer ( IK ), parameter :: ih = 3 integer ( IK ), parameter :: ix = 4 integer ( IK ) :: iy , ic , iw integer ( IK ) :: j , k , dm2 ! if ( g < 1 ) return ! iy = ix + dm ic = iy + dm iw = ic + dd dm2 = dm + dm ! do concurrent ( j = 1 : g , k = 1 : g ) block integer ( IK ) :: i , ip real ( RK ) :: W ( nw ) ! call dcopy ( dm , X ( 1 , 1 , j ), 1 , W ( ix ), 1 ) call dcopy ( dm , Y ( 1 , 1 , k ), 1 , W ( iy ), 1 ) ! !!!       trace of self correlation matrix w ( ih ) = ddot ( dm2 , W ( ix ), 1 , W ( ix ), 1 ) C ( 1 , j , k ) = w ( ih ) ! ip = 2 call calc_lb ( d , m , dd , dm , w ( ih ), w ( ix ), W ( it ), W ( ic ), W ( iw )) call dcopy ( dd , W ( ic ), 1 , C ( ip , j , k ), 1 ) w ( ib ) = w ( it ) ! do i = 1 , s - 1 call r % swap ( d , W ( iy ), i ) ip = ip + dd call calc_lb ( d , m , dd , dm , W ( ih ), W ( ix ), W ( it ), W ( ic ), W ( iw )) call dcopy ( dd , W ( ic ), 1 , C ( ip , j , k ), 1 ) w ( ib ) = MIN ( w ( ib ), w ( it )) call r % reverse ( d , W ( iy ), i ) end do ! Z ( j , k ) = w ( ib ) ! end block end do ! end subroutine eval ! pure subroutine calc_lb ( d , m , dd , dm , H , XY , T , C , W ) integer ( IK ), intent ( in ) :: d , m , dd , dm real ( RK ), intent ( in ) :: H , XY ( dm , * ) real ( RK ), intent ( inout ) :: T , C ( d , d ), W ( * ) !!!   get correlation matrix C = Y&#94;t@X and optimal rotation R&#94;t call DGEMM ( 'N' , 'T' , d , d , m , ONE , XY ( 1 , 2 ), d , XY ( 1 , 1 ), d , ZERO , C , d ) !!!   get squared displacement call estimate_sdmin ( d , H , C , W ) T = W ( 1 ) end subroutine calc_lb ! end subroutine d_matrix_eval ! pure subroutine d_matrix_partial_eval ( a , p , iprm , isym , ires , W , LT , H , C , LF , LB ) type ( d_matrix ), intent ( in ) :: a integer ( IK ), intent ( in ) :: p , iprm , isym , ires ( * ) real ( RK ), intent ( in ) :: W ( * ) real ( RK ), intent ( inout ) :: LT , H , C ( * ) real ( RK ), intent ( inout ), optional :: LF , LB ! LT = ZERO if ( PRESENT ( LF )) LF = ZERO if ( PRESENT ( LB )) LB = ZERO ! if ( p < 0 . or . a % g < p ) return if ( p < a % g ) call setminus_eval ( a , p , ires , W , LT ) if ( PRESENT ( LB )) LB = LT ! if ( p == 0 ) return if ( iprm < 1 . or . a % g < iprm ) return if ( isym < 0 . or . a % s <= isym ) return ! block integer ( IK ) :: ih , ic ih = a % c + ( iprm - 1 ) * a % cb + ( p - 1 ) * a % cl ic = ih + 1 + a % dd * isym if ( PRESENT ( LF )) then call partial_eval ( a % d , a % s , a % g , a % dd , a % nw2 , p , W ( ih ), W ( ic ), LF , H , C ) LT = LT + LF else call partial_eval ( a % d , a % s , a % g , a % dd , a % nw2 , p , W ( ih ), W ( ic ), LT , H , C ) end if end block ! contains ! pure subroutine setminus_eval ( a , p , ires , W , res ) type ( d_matrix ), intent ( in ) :: a integer ( IK ), intent ( in ) :: p , ires ( * ) real ( RK ), intent ( in ) :: W ( * ) real ( RK ), intent ( inout ) :: res integer ( IK ) :: nw , nr , rr ! if ( p < 0 . or . a % g < p ) then res = ZERO elseif ( p == 0 ) then nw = nwork ( a % g ) block real ( RK ) :: T ( nw ) call Hungarian ( a % g , W ( a % z ), T ( 1 )) res = T ( 1 ) end block else nr = a % g - p rr = nr * nr nw = rr + nwork ( nr ) block integer ( IK ) :: iw , iz real ( RK ) :: T ( nw ) iw = 1 + rr iz = a % z + a % g * ( p - 1 ) call pack_Z ( a % g , nr , ires , W ( a % z ), T ( 1 )) call Hungarian ( nr , T ( 1 ), T ( iw )) res = T ( iw ) end block end if ! end subroutine setminus_eval ! pure subroutine partial_eval ( d , s , n , dd , nw , p , H , C , LF , HP , CP ) integer ( IK ), intent ( in ) :: d , s , n , dd , nw integer ( IK ), intent ( in ) :: p real ( RK ), intent ( in ) :: H , C ( * ) real ( RK ), intent ( inout ) :: LF , HP , CP ( * ) real ( RK ) :: W ( nw ) integer ( IK ), parameter :: it = 1 integer ( IK ), parameter :: ic = 2 integer ( IK ) :: iw ! iw = ic + dd ! !!! update H and C w ( it ) = HP + H HP = w ( it ) call add ( dd , CP , C , W ( ic )) call dcopy ( dd , W ( ic ), 1 , CP , 1 ) ! !!! get squared displacement call estimate_sdmin ( d , w ( it ), w ( ic ), W ( iw )) LF = LF + w ( iw ) ! end subroutine partial_eval ! pure elemental function nwork ( np ) result ( res ) integer ( IK ), intent ( in ) :: np real ( RK ) :: W ( 1 ) integer ( IK ) :: res call Hungarian ( - np , W , W ) res = NINT ( W ( 1 ), IK ) end function nwork ! pure subroutine pack_Z ( n , nr , ires , Z , T ) integer ( IK ), intent ( in ) :: n , nr , ires ( nr ) real ( RK ), intent ( in ) :: Z ( n , * ) real ( RK ), intent ( inout ) :: T ( nr , nr ) integer ( IK ) :: i , j do concurrent ( i = 1 : nr , j = 1 : nr ) T ( i , j ) = Z ( ires ( i ), n - nr + j ) end do end subroutine pack_Z ! end subroutine d_matrix_partial_eval ! !!! d_matrix_list ! pure function d_matrix_list_new ( b , p ) result ( res ) type ( mol_block_list ), intent ( in ) :: b integer ( IK ), intent ( in ) :: p type ( d_matrix_list ) :: res integer ( IK ) :: i , ip real ( RK ) :: dum ( 1 ) ! res % d = b % nspatial () res % l = b % nspecies () res % dd = res % d ** 2 res % h = p ! H(1) res % v = res % h + 1 ! V(1) res % c = res % v + 1 ! C(d*d) res % o = res % c + res % dd ! O(L+1) ip = res % o + res % l + 1 ! call estimate_sdmin ( - res % d , dum ( 1 ), dum ( 1 ), dum ( 1 )) res % nk = NINT ( dum ( 1 )) ! allocate ( res % m ( res % l )) ! do i = 1 , res % l res % m ( i ) = d_matrix ( ip , res % d , res % nk , b % b ( i )) ip = ip + d_matrix_memsize ( res % m ( i )) end do ! end function d_matrix_list_new ! pure function d_matrix_list_memsize ( this ) result ( res ) class ( d_matrix_list ), intent ( in ) :: this integer ( IK ) :: res if ( ALLOCATED ( this % m )) then res = SUM ( d_matrix_memsize ( this % m )) + ( this % l + 1 ) + this % d ** 2 + 2 else res = 0 end if end function d_matrix_list_memsize ! pure elemental function d_matrix_list_n_depth ( this ) result ( res ) class ( d_matrix_list ), intent ( in ) :: this integer ( IK ) :: res if ( ALLOCATED ( this % m )) then res = SUM ( this % m % g ) else res = 0 end if end function d_matrix_list_n_depth ! pure subroutine d_matrix_list_eval ( this , rot , X , Y , W ) class ( d_matrix_list ), intent ( in ) :: this type ( mol_symmetry ), intent ( in ) :: rot ( * ) real ( RK ), intent ( in ) :: X ( * ), Y ( * ) real ( RK ), intent ( inout ) :: W ( * ) integer ( IK ) :: i ! if (. not . ALLOCATED ( this % m )) return ! !!! estimate H_fix, V_fix, C_fix. (mol_blocks for g<n or (g=1, s=1)) !!! if set is empty, H_fix=0, V_fix=0, C_fix=0. ! call fixpoints_eval ( this % d , this % dd , this % nk , this % l , this % m , X , Y , & & W ( this % h ), W ( this % v ), W ( this % c )) ! !!! estimate floating mol blocks. !!! O is filled by lower bounds for each blocks. ! do concurrent ( i = 1 : this % l ) call d_matrix_eval ( this % m ( i ), rot ( i ), X , Y , W ) block integer ( IK ) :: j , ires ( this % m ( i )% g ) do concurrent ( j = 1 : this % m ( i )% g ) ires ( j ) = j end do j = this % o + i - 1 call d_matrix_partial_eval ( this % m ( i ), 0 , 0 , 0 , ires , W , W ( j ), W ( j ), W ( j )) end block end do ! !!! transform O to accumulated form. ! do concurrent ( i = this % l - 1 : 1 : - 1 ) W ( this % o + i - 1 ) = W ( this % o + i - 1 ) + W ( this % o + i ) end do ! W ( this % o + this % l ) = ZERO ! contains ! pure subroutine fixpoints_eval ( d , dd , nk , l , m , X , Y , H , V , C ) integer ( IK ), intent ( in ) :: d , dd , nk , l type ( d_matrix ), intent ( in ) :: m ( l ) real ( RK ), intent ( in ) :: X ( * ), Y ( * ) real ( RK ), intent ( inout ) :: H , V , C ( * ) integer ( IK ) :: t ( l ), p ( l ), q ( l ) integer ( IK ), parameter :: ig = 1 integer ( IK ), parameter :: iv = 2 integer ( IK ), parameter :: ic = 3 integer ( IK ) :: i , iw , ix , iy , mn , dmn , dmn2 , nw ! do concurrent ( i = 1 : l ) t ( i ) = m ( i )% m * ( m ( i )% n - m ( i )% g ) end do ! mn = SUM ( t ) dmn = d * mn dmn2 = dmn + dmn ! iw = ic + dd ix = ic + dd iy = ix + dmn nw = 2 + dd + MAX ( dmn + dmn , dd + nk ) ! do concurrent ( i = 1 : l ) t ( i ) = t ( i ) * d end do p ( 1 ) = 0 do i = 2 , l p ( i ) = p ( i - 1 ) + t ( i - 1 ) end do do concurrent ( i = 1 : l ) q ( i ) = m ( i )% x + m ( i )% dm * m ( i )% g end do ! block real ( RK ) :: W ( nw ) ! do concurrent ( i = 1 : l ) block integer ( IK ) :: px px = p ( i ) + ix call dcopy ( t ( i ), X ( q ( i )), 1 , W ( px ), 1 ) end block end do do concurrent ( i = 1 : l ) block integer ( IK ) :: py py = p ( i ) + iy call dcopy ( t ( i ), Y ( q ( i )), 1 , W ( py ), 1 ) end block end do ! W ( ig ) = ddot ( dmn2 , W ( ix ), 1 , W ( ix ), 1 ) ! if ( mn > 0 ) then call DGEMM ( 'N' , 'T' , d , d , mn , ONE , W ( iy ), d , W ( ix ), d , ZERO , W ( ic ), d ) call estimate_sdmin ( d , W ( ig ), W ( ic ), W ( iw )) w ( iv ) = w ( iw ) else call zfill ( dd , W ( ic )) w ( iv ) = ZERO end if ! H = W ( ig ) V = W ( ig ) - W ( iv ) - W ( iv ) call dcopy ( dd , W ( ic ), 1 , C , 1 ) ! end block ! end subroutine fixpoints_eval ! end subroutine d_matrix_list_eval ! pure subroutine d_matrix_list_partial_eval ( this , p , perm , iprm , isym , W , LT , H , C , LF , LB ) class ( d_matrix_list ), intent ( in ) :: this integer ( IK ), intent ( in ) :: p , perm ( * ), iprm , isym real ( RK ), intent ( in ) :: W ( * ) real ( RK ), intent ( inout ) :: LT , H , C ( * ) real ( RK ), intent ( inout ), optional :: LF , LB integer ( IK ) :: ispc , iofs , nres ! call p_index ( this , p , ispc , iofs ) if ( ispc < 1 ) return ! nres = this % m ( ispc )% g - iofs block integer ( IK ) :: i , jper , ires ( nres ) jper = perm ( p - 1 + iprm ) do concurrent ( i = 1 : iprm - 1 ) ires ( i ) = perm ( p + i - 1 ) end do do concurrent ( i = iprm : nres ) ires ( i ) = perm ( p + i ) end do call d_matrix_partial_eval ( this % m ( ispc ), iofs , jper , isym , ires , W , LT , H , C , LF , LB ) end block ! contains ! pure elemental subroutine p_index ( this , p , ispc , iofs ) type ( d_matrix_list ), intent ( in ) :: this integer ( IK ), intent ( in ) :: p integer ( IK ), intent ( inout ) :: ispc , iofs integer ( IK ) :: i , q , r ! ispc = 0 iofs = 0 r = p q = 1 ! do i = 1 , this % l if ( q > p ) return ispc = i iofs = r r = r - this % m ( i )% g q = q + this % m ( i )% g end do ! if ( q <= p ) ispc = 0 ! end subroutine p_index ! end subroutine d_matrix_list_partial_eval ! pure elemental subroutine d_matrix_list_clear ( this ) class ( d_matrix_list ), intent ( inout ) :: this this % l = 0 this % d = 0 if ( ALLOCATED ( this % m )) deallocate ( this % m ) end subroutine d_matrix_list_clear ! pure elemental subroutine d_matrix_list_destroy ( this ) type ( d_matrix_list ), intent ( inout ) :: this call d_matrix_list_clear ( this ) end subroutine d_matrix_list_destroy ! !!! util ! pure subroutine add ( d , A , B , C ) integer ( IK ), intent ( in ) :: d real ( RK ), intent ( in ) :: A ( * ), B ( * ) real ( RK ), intent ( inout ) :: C ( * ) integer ( IK ) :: i do concurrent ( i = 1 : d ) C ( i ) = A ( i ) + B ( i ) end do end subroutine add ! pure subroutine zfill ( d , x ) integer ( IK ), intent ( in ) :: d real ( RK ), intent ( inout ) :: x ( * ) integer ( IK ) :: i do concurrent ( i = 1 : d ) x ( i ) = ZERO end do end subroutine zfill ! end module mod_d_matrix","tags":"","loc":"sourcefile/mod_d_matrix.f90.html"},{"title":"mod_estimate_rotation_matrix.f90 – symRMSD","text":"Contents Modules mod_estimate_rotation_matrix Source Code mod_estimate_rotation_matrix.f90 Source Code !| Calculate the rotation matrix that minimizes |X-RY|&#94;2 using the Kabsch-Umeyama algorithm. !  Here, RR&#94;T=I and det(R)=1 are satisfied. module mod_estimate_rotation_matrix use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO , HALF => RHALF use mod_det implicit none private public :: estimate_sdmin public :: estimate_rotation_matrix ! interface include 'ddot.h' include 'dcopy.h' include 'dgemm.h' include 'dgesvd.h' end interface ! real ( RK ), parameter :: THRESHOLD = 1E-8_RK ! contains ! pure subroutine estimate_sdmin ( d , g , cov , w ) integer ( IK ), intent ( in ) :: d !! spatial dimension real ( RK ), intent ( in ) :: g !! sum of auto covariance matrix real ( RK ), intent ( in ) :: cov ( * ) !! target d*n array real ( RK ), intent ( inout ) :: w ( * ) !! work array, must be larger than worksize(d). ! if ( d == 0 ) then W ( 1 ) = 1 elseif ( d == - 1 ) then W ( 1 ) = 1 elseif ( d == - 2 ) then W ( 1 ) = 2 elseif ( d == - 3 ) then W ( 1 ) = 10 elseif ( d == 1 ) then W ( 1 ) = g - cov ( 1 ) - cov ( 1 ) elseif ( d == 2 ) then if ( g < THRESHOLD ) then w ( 1 ) = ZERO return end if call quartenion_sdmin_d2 ( g , cov , w ) elseif ( d == 3 ) then if ( g < THRESHOLD ) then w ( 1 ) = ZERO return end if call quartenion_sdmin_d3 ( g , cov , w ) elseif ( d < - 3 ) then call Kabsch ( d , cov , w , w ) w ( 1 ) = w ( 1 ) + d * d + 1 else call Kabsch ( d , cov , w ( 2 ), w ( d * d + 2 )) w ( 1 ) = ddot ( d * d , cov , 1 , w ( 2 ), 1 ) w ( 1 ) = w ( 1 ) + w ( 1 ) w ( 1 ) = g - w ( 1 ) end if ! end subroutine estimate_sdmin ! pure subroutine quartenion_sdmin_d2 ( g , c , w ) real ( RK ), intent ( in ) :: g , c ( * ) real ( RK ), intent ( inout ) :: w ( * ) ! w ( 1 ) = c ( 1 ) + c ( 4 ) w ( 1 ) = w ( 1 ) * w ( 1 ) w ( 2 ) = c ( 2 ) - c ( 3 ) w ( 2 ) = w ( 2 ) * w ( 2 ) w ( 1 ) = SQRT ( w ( 1 ) + w ( 2 )) w ( 1 ) = w ( 1 ) + w ( 1 ) w ( 1 ) = g - w ( 1 ) ! end subroutine quartenion_sdmin_d2 ! pure subroutine quartenion_sdmin_d3 ( g , c , w ) real ( RK ), intent ( in ) :: g , c ( * ) real ( RK ), intent ( inout ) :: w ( * ) integer ( IK ), parameter :: k11 = 1 , k22 = 2 , k33 = 3 , k44 = 4 integer ( IK ), parameter :: k21 = 5 , k31 = 6 , k41 = 7 integer ( IK ), parameter :: k32 = 8 , k42 = 9 , k43 = 10 integer ( IK ), parameter :: a1 = 5 , a2 = 6 , b2 = 7 , b8 = 8 , c1 = 9 integer ( IK ), parameter :: l1 = 1 , l0 = 2 , l2 = 3 , l3 = 4 ! w ( k11 ) = c ( 1 ) + c ( 5 ) + c ( 9 ) w ( k21 ) = c ( 8 ) - c ( 6 ) w ( k31 ) = c ( 3 ) - c ( 7 ) w ( k41 ) = c ( 4 ) - c ( 2 ) w ( k22 ) = c ( 1 ) - c ( 5 ) - c ( 9 ) w ( k32 ) = c ( 4 ) + c ( 2 ) w ( k42 ) = c ( 3 ) + c ( 7 ) w ( k33 ) = - c ( 1 ) + c ( 5 ) - c ( 9 ) w ( k43 ) = c ( 8 ) + c ( 6 ) w ( k44 ) = - c ( 1 ) - c ( 5 ) + c ( 9 ) ! w ( c1 ) = ( w ( k11 ) * w ( k22 ) - w ( k21 ) * w ( k21 )) * ( w ( k33 ) * w ( k44 ) - w ( k43 ) * w ( k43 )) & & + ( w ( k21 ) * w ( k31 ) - w ( k11 ) * w ( k32 )) * ( w ( k32 ) * w ( k44 ) - w ( k43 ) * w ( k42 )) & & + ( w ( k11 ) * w ( k42 ) - w ( k21 ) * w ( k41 )) * ( w ( k32 ) * w ( k43 ) - w ( k33 ) * w ( k42 )) & & + ( w ( k21 ) * w ( k32 ) - w ( k22 ) * w ( k31 )) * ( w ( k31 ) * w ( k44 ) - w ( k43 ) * w ( k41 )) & & + ( w ( k22 ) * w ( k41 ) - w ( k21 ) * w ( k42 )) * ( w ( k31 ) * w ( k43 ) - w ( k41 ) * w ( k33 )) & & + ( w ( k31 ) * w ( k42 ) - w ( k41 ) * w ( k32 )) ** 2 ! w ( a1 ) = c ( 1 ) * c ( 1 ) + c ( 2 ) * c ( 2 ) + c ( 3 ) * c ( 3 ) & & + c ( 4 ) * c ( 4 ) + c ( 5 ) * c ( 5 ) + c ( 6 ) * c ( 6 ) & & + c ( 7 ) * c ( 7 ) + c ( 8 ) * c ( 8 ) + c ( 9 ) * c ( 9 ) w ( a2 ) = w ( a1 ) + w ( a1 ) ! w ( b2 ) = c ( 1 ) * ( c ( 8 ) * c ( 6 ) - c ( 5 ) * c ( 9 )) & & + c ( 4 ) * ( c ( 2 ) * c ( 9 ) - c ( 8 ) * c ( 3 )) & & + c ( 7 ) * ( c ( 5 ) * c ( 3 ) - c ( 2 ) * c ( 6 )) w ( b2 ) = w ( b2 ) + w ( b2 ) w ( b8 ) = w ( b2 ) + w ( b2 ) w ( b8 ) = w ( b8 ) + w ( b8 ) ! if ( ABS ( w ( b8 )) < THRESHOLD ) then w ( l2 ) = w ( c1 ) + w ( c1 ) w ( l2 ) = w ( l2 ) + w ( l2 ) w ( l1 ) = SQRT ( ABS ( HALF * ( SQRT ( ABS ( w ( a2 ) * w ( a2 ) - w ( l2 ))) + w ( a2 )))) else w ( l1 ) = g do w ( l2 ) = w ( l1 ) * w ( l1 ) w ( l3 ) = w ( l2 ) * w ( l1 ) w ( l0 ) = w ( l2 ) * w ( l2 ) w ( l2 ) = w ( l0 ) - w ( a2 ) * w ( l2 ) + w ( b8 ) * w ( l1 ) + w ( c1 ) w ( l3 ) = w ( l3 ) - w ( a1 ) * w ( l1 ) + w ( b2 ) w ( l3 ) = w ( l3 ) + w ( l3 ) w ( l3 ) = w ( l3 ) + w ( l3 ) w ( l0 ) = w ( l1 ) w ( l1 ) = w ( l1 ) - w ( l2 ) / w ( l3 ) if ( ABS ( w ( l0 ) - w ( l1 )) < THRESHOLD ) exit end do end if ! w ( l1 ) = w ( l1 ) + w ( l1 ) w ( l1 ) = g - w ( l1 ) ! end subroutine quartenion_sdmin_d3 ! pure subroutine estimate_rotation_matrix ( d , g , cov , rot , w ) integer ( IK ), intent ( in ) :: d !! spatial dimension real ( RK ), intent ( in ) :: g !! sum of auto covariance matrix real ( RK ), intent ( in ) :: cov ( * ) !! target d*n array real ( RK ), intent ( inout ) :: rot ( * ) !! rotation d*d matrix real ( RK ), intent ( inout ) :: w ( * ) !! work array, must be larger than Kabsch_worksize(d) !! if row_major, must be larger than Kabsch_worksize(n) ! if ( d == 0 ) then W ( 1 ) = 0 elseif ( d == - 1 ) then W ( 1 ) = 0 elseif ( d == - 2 ) then W ( 1 ) = 0 elseif ( d == - 3 ) then W ( 1 ) = 28 elseif ( d == 1 ) then rot ( 1 ) = ONE elseif ( d == 2 ) then if ( g < THRESHOLD ) then rot ( 1 ) = ONE ; rot ( 2 ) = ZERO rot ( 3 ) = ZERO ; rot ( 4 ) = ONE return end if call quartenion_rotmatrix_d2 ( cov , rot ) elseif ( d == 3 ) then if ( g < THRESHOLD ) then rot ( 1 ) = ONE ; rot ( 2 ) = ZERO ; rot ( 3 ) = ZERO rot ( 4 ) = ZERO ; rot ( 5 ) = ONE ; rot ( 6 ) = ZERO rot ( 7 ) = ZERO ; rot ( 8 ) = ZERO ; rot ( 9 ) = ONE return end if w ( 9 ) = ( ONE + ONE ) / g w ( 1 ) = w ( 9 ) * cov ( 1 ); w ( 2 ) = w ( 9 ) * cov ( 2 ); w ( 3 ) = w ( 9 ) * cov ( 3 ) w ( 4 ) = w ( 9 ) * cov ( 4 ); w ( 5 ) = w ( 9 ) * cov ( 5 ); w ( 6 ) = w ( 9 ) * cov ( 6 ) w ( 7 ) = w ( 9 ) * cov ( 7 ); w ( 8 ) = w ( 9 ) * cov ( 8 ); w ( 9 ) = w ( 9 ) * cov ( 9 ) call quartenion_rotmatrix_d3 ( g , w ( 1 ), rot , w ( 10 )) else call Kabsch ( d , cov , rot , w ) end if ! end subroutine estimate_rotation_matrix ! pure subroutine quartenion_rotmatrix_d2 ( c , rot ) real ( RK ), intent ( in ) :: c ( * ) real ( RK ), intent ( inout ) :: rot ( * ) ! rot ( 1 ) = c ( 1 ) + c ( 4 ) rot ( 2 ) = c ( 3 ) - c ( 2 ) rot ( 3 ) = rot ( 1 ) * rot ( 1 ) + rot ( 2 ) * rot ( 2 ) ! if ( rot ( 3 ) < Threshold ) then rot ( 1 ) = ONE ; rot ( 2 ) = ZERO rot ( 3 ) = ZERO ; rot ( 4 ) = ONE return end if ! rot ( 3 ) = SQRT ( ONE / rot ( 3 )) rot ( 1 ) = rot ( 1 ) * rot ( 3 ) ! cos theta rot ( 3 ) = HALF + HALF * rot ( 1 ) ! cos&#94;2 theta/2 rot ( 4 ) = rot ( 3 ) - ONE ! - sin&#94;2 theta/2 rot ( 1 ) = rot ( 4 ) + rot ( 3 ) ! cos&#94;2 theta/2 - sin&#94;2 theta/2 rot ( 4 ) = rot ( 4 ) * rot ( 3 ) ! cos&#94;2 theta/2 * sin&#94;2 theta/2 rot ( 4 ) = rot ( 4 ) + rot ( 4 ) ! 2 * cos&#94;2 theta/2 * sin&#94;2 theta/2 rot ( 4 ) = rot ( 4 ) + rot ( 4 ) ! 4 * cos&#94;2 theta/2 * sin&#94;2 theta/2 rot ( 2 ) = rot ( 4 ) * rot ( 2 ) rot ( 2 ) = SIGN ( ONE , rot ( 2 )) * SQRT ( ABS ( rot ( 4 ))) rot ( 3 ) = - rot ( 2 ) rot ( 4 ) = rot ( 1 ) ! end subroutine quartenion_rotmatrix_d2 ! pure subroutine quartenion_rotmatrix_d3 ( g , s , r , w ) real ( RK ), intent ( in ) :: g , s ( * ) !! target d*n array real ( RK ), intent ( inout ) :: r ( * ) !! rotation d*d matrix real ( RK ), intent ( inout ) :: w ( * ) integer ( IK ), parameter :: k11 = 1 , k22 = 2 , k33 = 3 , k44 = 4 integer ( IK ), parameter :: k21 = 5 , k31 = 6 , k41 = 7 integer ( IK ), parameter :: k32 = 8 , k42 = 9 , k43 = 10 integer ( IK ), parameter :: a1 = 11 , a2 = 12 , b2 = 13 , b8 = 14 , c1 = 15 integer ( IK ), parameter :: l0 = 16 , l1 = 17 , l2 = 18 , l3 = 19 integer ( IK ), parameter :: q0 = 11 , q1 = 12 , q2 = 13 , q3 = 14 , q4 = 15 ! w ( a1 ) = s ( 1 ) * s ( 1 ) + s ( 2 ) * s ( 2 ) + s ( 3 ) * s ( 3 ) & & + s ( 4 ) * s ( 4 ) + s ( 5 ) * s ( 5 ) + s ( 6 ) * s ( 6 ) & & + s ( 7 ) * s ( 7 ) + s ( 8 ) * s ( 8 ) + s ( 9 ) * s ( 9 ) w ( a2 ) = w ( a1 ) + w ( a1 ) ! w ( b2 ) = s ( 1 ) * ( s ( 8 ) * s ( 6 ) - s ( 5 ) * s ( 9 )) & & + s ( 4 ) * ( s ( 2 ) * s ( 9 ) - s ( 8 ) * s ( 3 )) & & + s ( 7 ) * ( s ( 5 ) * s ( 3 ) - s ( 2 ) * s ( 6 )) w ( b2 ) = w ( b2 ) + w ( b2 ) w ( b8 ) = w ( b2 ) + w ( b2 ) w ( b8 ) = w ( b8 ) + w ( b8 ) ! w ( k11 ) = s ( 1 ) + s ( 5 ) + s ( 9 ) w ( k21 ) = s ( 8 ) - s ( 6 ) w ( k31 ) = s ( 3 ) - s ( 7 ) w ( k41 ) = s ( 4 ) - s ( 2 ) w ( k22 ) = s ( 1 ) - s ( 5 ) - s ( 9 ) w ( k32 ) = s ( 4 ) + s ( 2 ) w ( k42 ) = s ( 3 ) + s ( 7 ) w ( k33 ) = - s ( 1 ) + s ( 5 ) - s ( 9 ) w ( k43 ) = s ( 8 ) + s ( 6 ) w ( k44 ) = - s ( 1 ) - s ( 5 ) + s ( 9 ) ! w ( c1 ) = ( w ( k11 ) * w ( k22 ) - w ( k21 ) * w ( k21 )) * ( w ( k33 ) * w ( k44 ) - w ( k43 ) * w ( k43 )) & & + ( w ( k21 ) * w ( k31 ) - w ( k11 ) * w ( k32 )) * ( w ( k32 ) * w ( k44 ) - w ( k43 ) * w ( k42 )) & & + ( w ( k11 ) * w ( k42 ) - w ( k21 ) * w ( k41 )) * ( w ( k32 ) * w ( k43 ) - w ( k33 ) * w ( k42 )) & & + ( w ( k21 ) * w ( k32 ) - w ( k22 ) * w ( k31 )) * ( w ( k31 ) * w ( k44 ) - w ( k43 ) * w ( k41 )) & & + ( w ( k22 ) * w ( k41 ) - w ( k21 ) * w ( k42 )) * ( w ( k31 ) * w ( k43 ) - w ( k41 ) * w ( k33 )) & & + ( w ( k31 ) * w ( k42 ) - w ( k41 ) * w ( k32 )) ** 2 ! if ( ABS ( w ( b8 )) < THRESHOLD ) then w ( l2 ) = w ( c1 ) + w ( c1 ) w ( l2 ) = w ( l2 ) + w ( l2 ) w ( l1 ) = SQRT ( ABS ( HALF * ( SQRT ( ABS ( w ( a2 ) * w ( a2 ) - w ( l2 ))) + w ( a2 )))) else w ( l1 ) = ONE do w ( l2 ) = w ( l1 ) * w ( l1 ) w ( l3 ) = w ( l2 ) * w ( l1 ) w ( l0 ) = w ( l2 ) * w ( l2 ) w ( l2 ) = w ( l0 ) - w ( a2 ) * w ( l2 ) + w ( b8 ) * w ( l1 ) + w ( c1 ) w ( l3 ) = w ( l3 ) - w ( a1 ) * w ( l1 ) + w ( b2 ) w ( l3 ) = w ( l3 ) + w ( l3 ) w ( l3 ) = w ( l3 ) + w ( l3 ) w ( l0 ) = w ( l1 ) w ( l1 ) = w ( l1 ) - w ( l2 ) / w ( l3 ) if ( ABS ( w ( l0 ) - w ( l1 )) < THRESHOLD ) exit end do end if ! w ( k11 ) = w ( k11 ) - w ( l1 ) w ( k22 ) = w ( k22 ) - w ( l1 ) w ( k33 ) = w ( k33 ) - w ( l1 ) w ( k44 ) = w ( k44 ) - w ( l1 ) ! w ( q1 ) = w ( k22 ) * ( w ( k33 ) * w ( k44 ) - w ( k43 ) * w ( k43 )) & & + w ( k32 ) * ( w ( k43 ) * w ( k42 ) - w ( k32 ) * w ( k44 )) & & + w ( k42 ) * ( w ( k32 ) * w ( k43 ) - w ( k33 ) * w ( k42 )) w ( q2 ) = w ( k21 ) * ( w ( k43 ) * w ( k43 ) - w ( k33 ) * w ( k44 )) & & + w ( k31 ) * ( w ( k32 ) * w ( k44 ) - w ( k43 ) * w ( k42 )) & & + w ( k41 ) * ( w ( k33 ) * w ( k42 ) - w ( k32 ) * w ( k43 )) w ( q3 ) = w ( k21 ) * ( w ( k32 ) * w ( k44 ) - w ( k43 ) * w ( k42 )) & & + w ( k22 ) * ( w ( k43 ) * w ( k41 ) - w ( k31 ) * w ( k44 )) & & + w ( k42 ) * ( w ( k31 ) * w ( k42 ) - w ( k32 ) * w ( k41 )) w ( q4 ) = w ( k21 ) * ( w ( k33 ) * w ( k42 ) - w ( k32 ) * w ( k43 )) & & + w ( k22 ) * ( w ( k31 ) * w ( k43 ) - w ( k33 ) * w ( k41 )) & & + w ( k32 ) * ( w ( k32 ) * w ( k41 ) - w ( k31 ) * w ( k42 )) ! w ( k11 ) = w ( q1 ) * w ( q1 ) w ( k22 ) = w ( q2 ) * w ( q2 ) w ( k33 ) = w ( q3 ) * w ( q3 ) w ( k44 ) = w ( q4 ) * w ( q4 ) w ( q0 ) = ONE / ( w ( k11 ) + w ( k22 ) + w ( k33 ) + w ( k44 )) w ( k11 ) = w ( k11 ) * w ( q0 ) w ( k22 ) = w ( k22 ) * w ( q0 ) w ( k33 ) = w ( k33 ) * w ( q0 ) w ( k44 ) = w ( k44 ) * w ( q0 ) w ( q0 ) = w ( q0 ) + w ( q0 ) w ( k21 ) = w ( q1 ) * w ( q2 ) * w ( q0 ) w ( k31 ) = w ( q1 ) * w ( q3 ) * w ( q0 ) w ( k41 ) = w ( q1 ) * w ( q4 ) * w ( q0 ) w ( k32 ) = w ( q2 ) * w ( q3 ) * w ( q0 ) w ( k42 ) = w ( q2 ) * w ( q4 ) * w ( q0 ) w ( k43 ) = w ( q3 ) * w ( q4 ) * w ( q0 ) ! r ( 1 ) = w ( k11 ) + w ( k22 ) - w ( k33 ) - w ( k44 ) r ( 2 ) = w ( k32 ) - w ( k41 ) r ( 3 ) = w ( k42 ) + w ( k31 ) r ( 4 ) = w ( k32 ) + w ( k41 ) r ( 5 ) = w ( k11 ) - w ( k22 ) + w ( k33 ) - w ( k44 ) r ( 6 ) = w ( k43 ) - w ( k21 ) r ( 7 ) = w ( k42 ) - w ( k31 ) r ( 8 ) = w ( k43 ) + w ( k21 ) r ( 9 ) = w ( k11 ) - w ( k22 ) - w ( k33 ) + w ( k44 ) ! end subroutine quartenion_rotmatrix_d3 ! !| Calculate the rotation matrix R&#94;T from covariance matrix. pure subroutine Kabsch ( d , cov , rot , w ) integer ( IK ), intent ( in ) :: d !! matrix collumn dimension. real ( RK ), intent ( in ) :: cov ( * ) !! target d*n array real ( RK ), intent ( inout ) :: rot ( * ) !! rotation d*d matrix real ( RK ), intent ( inout ) :: w ( * ) !! work array, must be larger than Kabsch_worksize(d) !! if row_major, must be larger than Kabsch_worksize(n) integer ( IK ), parameter :: m = 1 integer ( IK ) :: dd , s , u , vt , iw , lw , info ! if ( d == 0 ) then w ( 1 ) = ZERO return elseif ( d == 1 ) then rot ( 1 ) = ONE RETURN elseif ( d < 0 ) then s = ABS ( d ) call DGESVD ( 'A' , 'A' , s , s , w , s , w , w , s , w , s , w , - 1 , info ) w ( 1 ) = w ( 1 ) + s * s * 3 + s return end if ! dd = d * d u = m + dd vt = u + dd s = vt + dd iw = s + d ! call dgesvd ( 'A' , 'A' , d , d , w ( m ), d , w ( s ), w ( u ), d , w ( vt ), d , w ( iw ), - 1 , info ) lw = NINT ( w ( iw )) ! call dcopy ( dd , cov , 1 , w ( m ), 1 ) call dgesvd ( 'A' , 'A' , d , d , w ( m ), d , w ( s ), w ( u ), d , w ( vt ), d , w ( iw ), lw , info ) ! call DGEMM ( 'N' , 'N' , d , d , d , ONE , w ( u ), d , w ( vt ), d , ZERO , w ( s ), d ) call det_sign ( d , w ( s : s + dd - 1 )) if ( w ( s ) < ZERO ) w ( u + dd - d : u + dd - 1 ) = - w ( u + dd - d : u + dd - 1 ) call DGEMM ( 'N' , 'N' , d , d , d , ONE , w ( u ), d , w ( vt ), d , ZERO , w ( s ), d ) ! rot (: dd ) = w ( s : s + dd - 1 ) ! end subroutine Kabsch ! end module mod_estimate_rotation_matrix","tags":"","loc":"sourcefile/mod_estimate_rotation_matrix.f90.html"},{"title":"mod_tree.f90 – symRMSD","text":"Contents Modules mod_tree Source Code mod_tree.f90 Source Code module mod_tree use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO , RHUGE implicit none private public :: tree ! type node private sequence logical :: alive integer ( IK ) :: p end type node ! type breadth private sequence integer ( IK ) :: inod , lowd , uppd end type breadth ! type tree private integer ( IK ) :: iscope = 0 integer ( IK ), public :: ubnode = 0 integer ( IK ), public :: memnode = 0 integer ( IK ), public :: memsize = 0 integer ( IK ), public :: upperbound = 0 integer ( IK ), public :: lowerbound = 0 type ( node ), allocatable :: nodes (:) type ( breadth ), allocatable :: breadthes (:) contains procedure :: n_depth => tree_n_depth procedure :: n_breadth => tree_n_breadth procedure :: current_depth => tree_current_depth procedure :: reset => tree_reset procedure :: set_parent_node => tree_set_parent_node procedure :: set_lowerbound => tree_set_lowerbound procedure :: prune => tree_prune procedure :: nodes_pointer => tree_nodes_pointer procedure :: parent_pointer => tree_parent_pointer procedure :: parent_index => tree_parent_index procedure :: current_pointer => tree_current_pointer procedure :: current_index => tree_current_index procedure :: alive_nodes => tree_alive_nodes procedure :: open_node => tree_open_node procedure :: close_node => tree_close_node procedure :: log_ncomb => tree_log_ncomb procedure :: finished => tree_finished procedure :: unfinished => tree_unfinished procedure :: clear => tree_clear final :: tree_destroy end type tree ! interface tree module procedure tree_new end interface tree ! contains ! pure function tree_new ( pw , memnode , ndepth , n_breadths ) result ( res ) integer ( IK ), intent ( in ) :: pw , memnode , ndepth , n_breadths ( ndepth ) type ( tree ) :: res integer ( IK ) :: pq , n , i , j , k ! n = SUM ( n_breadths ) res % memnode = MAX ( memnode , 1 ) ! pq = pw res % lowerbound = pq ; pq = pq + 1 res % ubnode = pq ; pq = pq + res % memnode res % upperbound = res % ubnode allocate ( res % nodes ( n )) do concurrent ( i = 1 : n ) res % nodes ( i ) = node (. true ., pq + ( i - 1 ) * res % memnode ) end do ! res % memsize = ( n + 1 ) * res % memnode + 1 ! allocate ( res % breadthes ( ndepth )) j = 0 do i = 1 , ndepth k = j + n_breadths ( i ) res % breadthes ( i ) = breadth ( 0 , j , k ) j = k end do ! end function tree_new ! pure elemental function tree_n_depth ( this ) result ( res ) class ( tree ), intent ( in ) :: this integer ( IK ) :: res if ( ALLOCATED ( this % breadthes )) then res = SIZE ( this % breadthes ) else res = 0 end if end function tree_n_depth ! pure elemental function tree_current_depth ( this ) result ( res ) class ( tree ), intent ( in ) :: this integer ( IK ) :: res res = this % iscope end function tree_current_depth ! pure elemental function tree_n_breadth ( this ) result ( res ) class ( tree ), intent ( in ) :: this integer ( IK ) :: res res = 0 if ( ALLOCATED ( this % breadthes )) then if ( this % iscope < 1 ) return res = this % breadthes ( this % iscope )% uppd - this % breadthes ( this % iscope )% lowd end if end function tree_n_breadth ! pure elemental function tree_nodes_pointer ( this ) result ( res ) class ( tree ), intent ( in ) :: this integer ( IK ) :: res res = 0 if ( ALLOCATED ( this % breadthes )) then if ( this % iscope < 1 ) return res = this % nodes ( this % breadthes ( this % iscope )% lowd + 1 )% p end if end function tree_nodes_pointer ! pure elemental function tree_parent_pointer ( this ) result ( res ) class ( tree ), intent ( in ) :: this integer ( IK ) :: ip , res res = 0 if ( ALLOCATED ( this % breadthes )) then if ( this % iscope < 2 ) return ip = this % iscope - 1 ip = this % breadthes ( ip )% inod if ( ip < 1 ) return res = this % nodes ( ip )% p end if end function tree_parent_pointer ! pure elemental function tree_current_pointer ( this ) result ( res ) class ( tree ), intent ( in ) :: this integer ( IK ) :: ip , res res = 0 if ( ALLOCATED ( this % breadthes )) then if ( this % iscope < 1 ) return ip = this % iscope ip = this % breadthes ( ip )% inod if ( ip < 1 ) return res = this % nodes ( ip )% p end if end function tree_current_pointer ! pure elemental function tree_current_index ( this ) result ( res ) class ( tree ), intent ( in ) :: this integer ( IK ) :: ip , res res = 0 if ( ALLOCATED ( this % breadthes )) then if ( this % iscope < 1 ) return ip = this % iscope ip = this % breadthes ( ip )% inod - & & this % breadthes ( ip )% lowd if ( ip > 0 ) res = ip end if end function tree_current_index ! pure function tree_alive_nodes ( this ) result ( res ) class ( tree ), intent ( in ) :: this logical , allocatable :: res (:) integer ( IK ) :: l , u allocate ( res ( 0 )) if ( this % iscope < 1 . or . this % n_depth () < this % iscope ) return l = this % breadthes ( this % iscope )% lowd + 1 u = this % breadthes ( this % iscope )% uppd res = this % nodes ( l : u )% alive end function tree_alive_nodes ! pure elemental function tree_parent_index ( this ) result ( res ) class ( tree ), intent ( in ) :: this integer ( IK ) :: ip , res res = 0 if ( ALLOCATED ( this % breadthes )) then if ( this % iscope < 2 ) return ip = this % iscope - 1 ip = this % breadthes ( ip )% inod - & & this % breadthes ( ip )% lowd if ( ip > 0 ) res = ip end if end function tree_parent_index ! pure subroutine tree_reset ( this ) class ( tree ), intent ( inout ) :: this this % iscope = 0 if ( ALLOCATED ( this % nodes )) this % nodes % alive = . false . call this % open_node () end subroutine tree_reset ! pure subroutine tree_set_parent_node ( this , W ) class ( tree ), intent ( inout ) :: this real ( RK ), intent ( in ) :: W ( * ) real ( RK ) :: lv integer ( IK ) :: i , l , u ! if ( this % iscope < 1 . or . this % n_depth () < this % iscope ) return l = this % breadthes ( this % iscope )% lowd + 1 u = this % breadthes ( this % iscope )% uppd ! this % breadthes ( this % iscope )% inod = l ! lv = RHUGE do i = l , u if ( this % nodes ( i )% alive . and . W ( this % nodes ( i )% p ) < lv ) then this % breadthes ( this % iscope )% inod = i lv = W ( this % nodes ( i )% p ) end if end do ! if ( this % iscope == this % n_depth ()) this % nodes ( l : u )% alive = . false . ! end subroutine tree_set_parent_node ! pure elemental subroutine tree_open_node ( this ) class ( tree ), intent ( inout ) :: this integer ( IK ) :: i , l , u ! if ( this % iscope < 0 . or . this % n_depth () <= this % iscope ) return if ( this % iscope > 0 ) then l = this % breadthes ( this % iscope )% inod if ( l > 0 ) this % nodes ( l )% alive = . false . end if this % iscope = this % iscope + 1 l = this % breadthes ( this % iscope )% lowd + 1 u = this % breadthes ( this % iscope )% uppd ! do concurrent ( i = l : u ) this % nodes ( i )% alive = . true . end do ! this % breadthes ( this % iscope )% inod = l ! end subroutine tree_open_node ! pure subroutine tree_set_lowerbound ( this , W ) class ( tree ), intent ( in ) :: this real ( RK ), intent ( inout ) :: W ( * ) integer ( IK ) :: i , nnod ! w ( this % lowerbound ) = w ( this % upperbound ) if (. not . ALLOCATED ( this % nodes )) return nnod = SIZE ( this % nodes ) do i = 1 , nnod if ( this % nodes ( i )% alive ) w ( this % lowerbound ) = MIN ( w ( this % lowerbound ), w ( this % nodes ( i )% p )) end do ! end subroutine tree_set_lowerbound ! pure elemental subroutine tree_close_node ( this ) class ( tree ), intent ( inout ) :: this integer ( IK ) :: p ! if ( this % iscope <= 1 . or . this % n_depth () < this % iscope ) return this % iscope = this % iscope - 1 p = this % breadthes ( this % iscope )% inod ! end subroutine tree_close_node ! pure elemental function tree_log_ncomb ( this ) result ( res ) class ( tree ), intent ( in ) :: this real ( RK ) :: res if ( ALLOCATED ( this % breadthes )) then res = SUM ( LOG ( REAL ( this % breadthes % uppd - this % breadthes % lowd , RK ))) else res = ZERO end if end function tree_log_ncomb ! pure elemental function tree_finished ( this ) result ( res ) class ( tree ), intent ( in ) :: this logical :: res ! res = . not . this % unfinished () ! end function tree_finished ! pure elemental function tree_unfinished ( this ) result ( res ) class ( tree ), intent ( in ) :: this logical :: res integer ( IK ) :: i , l , u ! res = . true . if ( this % iscope < 1 . or . this % n_depth () < this % iscope ) return l = this % breadthes ( this % iscope )% lowd + 1 u = this % breadthes ( this % iscope )% uppd res = ANY ([( this % nodes ( i )% alive , i = l , u )]) ! end function tree_unfinished ! pure subroutine tree_prune ( this , W ) class ( tree ), intent ( inout ) :: this real ( RK ), intent ( in ) :: W ( * ) integer ( IK ) :: i , l , u ! if ( this % iscope < 1 . or . this % n_depth () < this % iscope ) return l = this % breadthes ( this % iscope )% lowd + 1 u = this % breadthes ( this % iscope )% uppd do concurrent ( i = l : u ) this % nodes ( i )% alive = this % nodes ( i )% alive . and . ( W ( this % nodes ( i )% p ) < W ( this % upperbound )) end do ! end subroutine tree_prune ! pure elemental subroutine tree_clear ( this ) class ( tree ), intent ( inout ) :: this if ( ALLOCATED ( this % nodes )) deallocate ( this % nodes ) if ( ALLOCATED ( this % breadthes )) deallocate ( this % breadthes ) end subroutine tree_clear ! pure elemental subroutine tree_destroy ( this ) type ( tree ), intent ( inout ) :: this call tree_clear ( this ) end subroutine tree_destroy ! end module mod_tree","tags":"","loc":"sourcefile/mod_tree.f90.html"},{"title":"mod_group_permutation.f90 – symRMSD","text":"Contents Modules mod_group_permutation Source Code mod_group_permutation.f90 Source Code module mod_group_permutation use mod_params , only : IK , RK implicit none private public :: group_permutation public :: group_permutation_init public :: group_permutation_swap ! integer ( IK ), parameter :: DEF_n = 1 !! default number of components. ! type :: group_permutation private integer ( IK ), allocatable :: p (:, :) integer ( IK ), allocatable :: q (:) contains procedure :: init => group_permutation_init procedure :: nfree => group_permutation_nfree procedure :: free_indices => group_permutation_free_indices procedure :: swap => group_permutation_swap_real procedure :: reverse => group_permutation_reverse_real procedure :: clear => group_permutation_clear final :: group_permutation_destroy end type group_permutation ! interface group_permutation module procedure group_permutation_new end interface group_permutation ! interface group_permutation_swap module procedure group_permutation_swap_real end interface group_permutation_swap ! contains ! !| Constructer pure function group_permutation_new ( prm ) result ( res ) integer ( IK ), intent ( in ) :: prm (:) !! permutation indices type ( group_permutation ) :: res ! allocate ( res % p ( 0 , 0 )) allocate ( res % q ( 0 )) call decompose_to_cyclic ( SIZE ( prm ), prm , res % p , res % q ) ! end function group_permutation_new ! pure subroutine group_permutation_init ( this , prm ) class ( group_permutation ), intent ( inout ) :: this integer ( IK ), intent ( in ) :: prm (:) !! permutation indices ! call group_permutation_clear ( this ) allocate ( this % p ( 0 , 0 )) allocate ( this % q ( 0 )) call decompose_to_cyclic ( SIZE ( prm ), prm , this % p , this % q ) ! end subroutine group_permutation_init ! pure subroutine decompose_to_cyclic ( n , prm , p , q ) integer ( IK ), intent ( in ) :: n , prm ( n ) integer ( IK ), intent ( inout ), allocatable :: p (:, :), q (:) integer ( IK ) :: w ( 5 * n ) integer ( IK ) :: i , j , k , l ! if ( n < 2 ) return if ( n == 2 ) then if ( prm ( 1 ) == 2 ) then p = RESHAPE ([ 1 , 2 , 1 ], [ 3 , 1 ]) q = [ 2 , 1 ] endif return endif ! w ( 1 ) = - 1 w (: 3 * n ) = - 1 do k = 1 , n if ( prm ( k ) < 1 . or . n < prm ( k )) return w ( k ) = prm ( k ) end do ! i = n + n + 1 j = n + 1 k = 0 ! do l = 1 , n if ( w ( l ) < 0 ) cycle call count_permutation ( n , w , l , w ( i ), w ( j )) if ( w ( j ) < 0 ) then w ( 1 ) = - 1 ; return end if i = i + w ( j ) j = j + 1 enddo ! w ( 1 ) = j - n - 1 do concurrent ( i = 1 : w ( 1 )) w ( i + 1 ) = w ( i + n ) end do do concurrent ( i = 1 : n ) w ( i + w ( 1 ) + 1 ) = w ( n + n + i ) end do ! i = w ( 1 ) + n + 2 j = w ( 1 ) + 2 call uniq ( w ( 1 ), w ( 2 ), w ( i ), w ( i + 1 )) k = i + w ( i ) + w ( i ) + 1 call proc ( n , w ( 1 ), w ( i ), w ( 2 ), w ( j ), w ( i + 1 ), w ( i + w ( i ) + 1 ), w ( k ), w ( 1 )) ! p = header ( w ( 1 ), w ( 2 )) i = 2 * w ( 1 ) + 2 j = i + p ( 1 , w ( 1 )) + p ( 2 , w ( 1 )) * p ( 3 , w ( 1 )) - 2 q = w ( i : j ) ! end subroutine decompose_to_cyclic ! pure function header ( s , w ) result ( res ) integer ( IK ), intent ( in ) :: s , w ( 2 , * ) integer ( IK ) :: res ( 3 , s ) integer ( IK ) :: i do concurrent ( i = 1 : s ) res ( 2 , i ) = w ( 1 , i ) res ( 3 , i ) = w ( 2 , i ) end do res ( 1 , 1 ) = 1 do i = 1 , s - 1 res ( 1 , i + 1 ) = res ( 1 , i ) + res ( 2 , i ) * res ( 3 , i ) end do end function header ! pure subroutine proc ( n , m , s , p , q , u , t , w , res ) integer ( IK ), intent ( in ) :: n , m , s , p ( * ), q ( * ), u ( * ), t ( * ) integer ( IK ), intent ( inout ) :: w ( * ), res ( * ) integer ( IK ) :: i , j , k , l ! do concurrent ( i = 1 : s ) w ( 2 * i - 1 ) = u ( i ) w ( 2 * i ) = t ( i ) end do ! l = s + s + 1 ! do i = 1 , s k = 0 do j = 1 , m k = k + p ( j ) if ( p ( j ) /= u ( i )) cycle w ( l : l + u ( i ) - 1 ) = q ( k - u ( i ) + 1 : k ) l = l + u ( i ) end do end do ! res ( 1 ) = s do concurrent ( i = 1 : s + s + n ) res ( i + 1 ) = w ( i ) end do ! end subroutine proc ! pure subroutine count_permutation ( n , prm , s , l , c ) integer ( IK ), intent ( in ) :: n , s integer ( IK ), intent ( inout ) :: prm ( * ), l ( * ), c integer ( IK ) :: e0 , e ! c = 1 l ( 1 ) = s e0 = s e = prm ( s ) prm ( s ) = - prm ( s ) ! do if ( e < 1 . or . n < e ) then c = - 1 ; return end if if ( e0 == e ) return c = c + 1 l ( c ) = e e = prm ( e ) prm ( l ( c )) = - prm ( l ( c )) end do ! end subroutine count_permutation ! ! pure subroutine group_permutation_swap_int_l1(this, X) !   class(group_permutation), intent(inout) :: this !   integer(IK), intent(inout)              :: X(*) !   integer(IK)                             :: i, j ! !   if (.not. ALLOCATED(this%p)) return ! !   do concurrent(i=1:SIZE(this%p, 2)) !     do concurrent(j=1:this%p(3, i)) !       block !         integer(IK) :: b !         b = this%p(1, i) + this%p(2, i) * (j - 1) !         call cyclic_swap_int(1, this%p(2, i), this%q(b), X) !       end block !     end do !   end do ! ! end subroutine group_permutation_swap_int_l1 ! ! pure subroutine group_permutation_swap_int_l2(this, d, X) !   class(group_permutation), intent(inout) :: this !   integer(IK), intent(in)                 :: d !   integer(IK), intent(inout)              :: X(d, *) !   integer(IK)                             :: i, j ! !   if (.not. ALLOCATED(this%p)) return ! !   do concurrent(i=1:SIZE(this%p, 2)) !     do concurrent(j=1:this%p(3, i)) !       block !         integer(IK) :: b !         b = this%p(1, i) + this%p(2, i) * (j - 1) !         call cyclic_swap_int(d, this%p(2, i), this%q(b), X) !       end block !     end do !   end do ! ! end subroutine group_permutation_swap_int_l2 ! pure subroutine group_permutation_swap_real ( this , d , X ) class ( group_permutation ), intent ( in ) :: this integer ( IK ), intent ( in ) :: d real ( RK ), intent ( inout ) :: X ( * ) integer ( IK ) :: i , j ! if (. not . ALLOCATED ( this % p )) return ! do concurrent ( i = 1 : SIZE ( this % p , 2 )) do concurrent ( j = 1 : this % p ( 3 , i )) block integer ( IK ) :: b b = this % p ( 1 , i ) + this % p ( 2 , i ) * ( j - 1 ) call cyclic_swap_real ( d , this % p ( 2 , i ), this % q ( b ), X ) end block end do end do ! end subroutine group_permutation_swap_real ! pure subroutine group_permutation_reverse_real ( this , d , X ) class ( group_permutation ), intent ( in ) :: this integer ( IK ), intent ( in ) :: d real ( RK ), intent ( inout ) :: X ( * ) integer ( IK ) :: i , j ! if (. not . ALLOCATED ( this % p )) return ! do concurrent ( i = 1 : SIZE ( this % p , 2 )) do concurrent ( j = 1 : this % p ( 3 , i )) block integer ( IK ) :: b b = this % p ( 1 , i ) + this % p ( 2 , i ) * ( j - 1 ) call cyclic_reverse_real ( d , this % p ( 2 , i ), this % q ( b ), X ) end block end do end do ! end subroutine group_permutation_reverse_real ! pure elemental function group_permutation_nfree ( this ) result ( res ) class ( group_permutation ), intent ( in ) :: this integer ( IK ) :: res if ( ALLOCATED ( this % q )) then res = SIZE ( this % q ) else res = 0 end if end function group_permutation_nfree ! pure function group_permutation_free_indices ( this ) result ( res ) class ( group_permutation ), intent ( in ) :: this integer ( IK ) :: res ( this % nfree ()) integer ( IK ) :: i , n if ( ALLOCATED ( this % q )) then n = SIZE ( res ) do concurrent ( i = 1 : n ) res ( i ) = this % q ( i ) end do call qsi ( n , res ) end if end function group_permutation_free_indices ! pure elemental subroutine group_permutation_clear ( this ) class ( group_permutation ), intent ( inout ) :: this if ( ALLOCATED ( this % p )) deallocate ( this % p ) if ( ALLOCATED ( this % q )) deallocate ( this % q ) end subroutine group_permutation_clear ! pure elemental subroutine group_permutation_destroy ( this ) type ( group_permutation ), intent ( inout ) :: this if ( ALLOCATED ( this % p )) deallocate ( this % p ) if ( ALLOCATED ( this % q )) deallocate ( this % q ) end subroutine group_permutation_destroy ! !!! ! ! pure subroutine cyclic_swap_int(d, s, q, X) !   integer(IK), intent(in)    :: d, s, q(*) !   integer(IK), intent(inout) :: X(d, *) !   integer(IK)                :: T(d) !   integer(IK)                :: i, j !   do concurrent(i=1:d) !     T(i) = X(i, q(1)) !   end do !   do j = 1, s - 1 !     do concurrent(i=1:d) !       X(i, q(j)) = X(i, q(j + 1)) !     end do !   end do !   do concurrent(i=1:d) !     X(i, q(s)) = T(i) !   end do ! end subroutine cyclic_swap_int ! pure subroutine cyclic_swap_real ( d , s , q , X ) integer ( IK ), intent ( in ) :: d , s , q ( * ) real ( RK ), intent ( inout ) :: X ( d , * ) real ( RK ) :: T ( d ) integer ( IK ) :: i , j do concurrent ( i = 1 : d ) T ( i ) = X ( i , q ( 1 )) end do do j = 1 , s - 1 do concurrent ( i = 1 : d ) X ( i , q ( j )) = X ( i , q ( j + 1 )) end do end do do concurrent ( i = 1 : d ) X ( i , q ( s )) = T ( i ) end do end subroutine cyclic_swap_real ! pure subroutine cyclic_reverse_real ( d , s , q , X ) integer ( IK ), intent ( in ) :: d , s , q ( * ) real ( RK ), intent ( inout ) :: X ( d , * ) real ( RK ) :: T ( d ) integer ( IK ) :: i , j do concurrent ( i = 1 : d ) T ( i ) = X ( i , q ( s )) end do do j = s - 1 , 1 , - 1 do concurrent ( i = 1 : d ) X ( i , q ( j + 1 )) = X ( i , q ( j )) end do end do do concurrent ( i = 1 : d ) X ( i , q ( 1 )) = T ( i ) end do end subroutine cyclic_reverse_real ! !! returns uniq integer list without 1. pure subroutine uniq ( n , a , u , res ) integer ( IK ), intent ( in ) :: n , a ( * ) integer ( IK ), intent ( inout ) :: u , res ( * ) integer ( IK ) :: i ! u = 0 if ( n < 1 ) return ! do concurrent ( i = 1 : n ) res ( i ) = a ( i ) enddo if ( n > 1 ) call qsi ( n , res ) ! u = 1 res ( n + u ) = 1 do i = 1 , n - 1 if ( res ( i ) == res ( i + 1 )) then res ( n + u ) = res ( n + u ) + 1 cycle endif if ( res ( i ) > 1 ) u = u + 1 res ( u ) = res ( i + 1 ) res ( n + u ) = 1 end do ! do i = 1 , u res ( u + i ) = res ( n + i ) end do ! end subroutine uniq ! pure recursive subroutine qsi ( n , s ) integer ( IK ), intent ( in ) :: n integer ( IK ), intent ( inout ) :: s ( n ) integer ( IK ) :: i , j , p , t ! j = n ; i = 1 ; p = j / 2 ! do ! do while ( s ( i ) < s ( p )); i = i + 1 ; end do do while ( s ( j ) > s ( p )); j = j - 1 ; end do ! if ( i >= j ) exit ! t = s ( i ); s ( i ) = s ( j ); s ( j ) = t if ( i == p ) then ; p = j elseif ( j == p ) then ; p = i end if i = i + 1 ; j = j - 1 ! end do ! if ( 2 < i ) call qsi ( i - 1 , s (: i - 1 )) if ( j + 1 < n ) call qsi ( n - j , s ( j + 1 :)) ! end subroutine qsi ! end module mod_group_permutation","tags":"","loc":"sourcefile/mod_group_permutation.f90.html"},{"title":"mod_mol_block.f90 – symRMSD","text":"Contents Modules mod_mol_block Source Code mod_mol_block.f90 Source Code !| molecular coodinate block indicator module mod_mol_block use mod_params , only : IK , RK , ONE => RONE , FOUR => RFOUR , ZERO => RZERO , RHUGE implicit none private public :: mol_block public :: mol_block_list ! integer ( IK ), parameter :: def_d = 3 ! !| molecular block indicator !  atomic coordinates vector must be stored in the following format. !    X(d,m,n) !    - d :: spatial dimension. !    - m :: number of atom in a molecule. !    - n :: number of molecule. !    - where X(d,:f,:g)     :: Free rotatable. !    -       X(d,f+1:,g+1:) :: Fixed. type mol_block sequence integer ( IK ) :: p = 1 !  p :: pointer to memory integer ( IK ) :: s = 1 !  s :: number of molecular symmetry integer ( IK ) :: m = 1 !  m :: number of atom in a molecule integer ( IK ) :: n = 1 !  n :: number of molecule integer ( IK ) :: f = 1 !  f :: number of free atom in a molecule, must be f<=m. integer ( IK ) :: g = 1 !  g :: number of free molecule, must be g<=n end type mol_block ! type mol_block_list integer ( IK ) :: d = 0 integer ( IK ) :: mg = 0 integer ( IK ) :: mn = 0 !  d :: spatial dimension type ( mol_block ), allocatable :: b (:) !  mol_blocks contains procedure :: add_molecule => mol_block_list_add_molecule procedure :: child => mol_block_list_child procedure :: invalid => mol_block_list_invalid procedure :: natom => mol_block_list_natom procedure :: nspatial => mol_block_list_nspatial procedure :: nspecies => mol_block_list_nspecies procedure :: ispecies => mol_block_list_ispecies procedure :: ipointer => mol_block_list_ipointer procedure :: n_res => mol_block_list_n_res procedure :: res_pointer => mol_block_list_res_pointer procedure :: has_child => mol_block_list_has_child procedure :: clear => mol_block_list_clear final :: mol_block_list_destroy end type mol_block_list ! interface mol_block_list module procedure mol_block_list_new end interface mol_block_list ! contains ! ! Constructer pure function mol_block_list_new ( d , l , b ) result ( res ) integer ( IK ), intent ( in ) :: d !  d :: spatial dimension integer ( IK ), intent ( in ) :: l !  s :: number of species type ( mol_block ), intent ( in ) :: b ( l ) !  molecular block type ( mol_block_list ) :: res integer ( IK ) :: i , p res % d = MAX ( d , 1 ) if ( l < 1 ) then allocate ( res % b ( 0 )) return end if allocate ( res % b ( l )) do concurrent ( i = 1 : l ) res % b ( i ) = b ( i ) res % b ( i )% s = MAX ( 1 , res % b ( i )% s ) res % b ( i )% m = MAX ( 0 , res % b ( i )% m ) res % b ( i )% n = MAX ( 0 , res % b ( i )% n ) res % b ( i )% f = MAX ( 0 , MIN ( res % b ( i )% m , res % b ( i )% f )) res % b ( i )% g = MAX ( 0 , MIN ( res % b ( i )% n , res % b ( i )% g )) end do p = 1 do i = 1 , l res % b ( i )% p = p p = p + res % d * res % b ( i )% n * res % b ( i )% m end do res % mg = SUM ( res % b % m * res % b % g ) res % mn = SUM ( res % b % m * res % b % n ) end function mol_block_list_new ! pure subroutine mol_block_list_add_molecule ( this , b ) class ( mol_block_list ), intent ( inout ) :: this type ( mol_block ), intent ( in ) :: b integer ( IK ) :: nb if ( allocated ( this % b )) then this % b = [ this % b , b ] else this % d = def_d this % mg = 0 this % mn = 0 this % b = [ b ] endif nb = SIZE ( this % b ) this % b ( nb )% s = MAX ( 1 , this % b ( nb )% s ) this % b ( nb )% m = MAX ( 0 , this % b ( nb )% m ) this % b ( nb )% n = MAX ( 0 , this % b ( nb )% n ) this % b ( nb )% f = MAX ( 0 , MIN ( this % b ( nb )% m , this % b ( nb )% f )) this % b ( nb )% g = MAX ( 0 , MIN ( this % b ( nb )% n , this % b ( nb )% g )) this % mg = this % mg + this % b ( nb )% m * this % b ( nb )% g this % mn = this % mn + this % b ( nb )% m * this % b ( nb )% n if ( nb < 2 ) then this % b ( nb )% p = 1 else this % b ( nb )% p = this % b ( nb - 1 )% p + this % d * this % b ( nb - 1 )% n * this % b ( nb - 1 )% m end if end subroutine mol_block_list_add_molecule ! pure elemental function mol_block_list_natom ( this ) result ( res ) class ( mol_block_list ), intent ( in ) :: this integer ( IK ) :: res res = this % mn end function mol_block_list_natom ! pure elemental function mol_block_list_nspatial ( this ) result ( res ) class ( mol_block_list ), intent ( in ) :: this integer ( IK ) :: res res = this % d end function mol_block_list_nspatial ! pure elemental function mol_block_list_child ( b ) result ( res ) class ( mol_block_list ), intent ( in ) :: b type ( mol_block_list ) :: res integer ( IK ) :: i res % d = b % d res % mg = b % mg res % mn = b % mn if (. not . ALLOCATED ( b % b )) then allocate ( res % b ( 0 )) return end if res % b = b % b do i = 1 , SIZE ( res % b ) if ( res % b ( i )% g == 0 ) cycle res % b ( i )% g = res % b ( i )% g - 1 return end do end function mol_block_list_child ! pure elemental function mol_block_list_ispecies ( b ) result ( res ) class ( mol_block_list ), intent ( in ) :: b integer ( IK ) :: i , res if (. not . ALLOCATED ( b % b )) then res = 0 else do i = 1 , SIZE ( b % b ) if ( b % b ( i )% g == 0 ) cycle res = i ; return end do end if end function mol_block_list_ispecies ! pure elemental function mol_block_list_ipointer ( b , imol ) result ( res ) class ( mol_block_list ), intent ( in ) :: b integer ( IK ), intent ( in ) :: imol integer ( IK ) :: i , res res = 0 if ( ALLOCATED ( b % b )) then do i = 1 , SIZE ( b % b ) if ( b % b ( i )% g == 0 ) cycle res = b % b ( i )% p if ( imol < 1 . or . b % b ( i )% n < imol ) return res = res + ( imol - 1 ) * b % d * b % b ( i )% m return end do end if end function mol_block_list_ipointer ! pure function mol_block_list_n_res ( b ) result ( res ) class ( mol_block_list ), intent ( in ) :: b integer ( IK ) :: i , s , res ( b % nspecies ()) res = 0 s = b % nspecies () do i = 1 , s res ( i ) = ( b % b ( i )% n - b % b ( i )% g ) * b % b ( i )% m end do end function mol_block_list_n_res ! pure elemental function mol_block_list_res_pointer ( b , ispc ) result ( res ) class ( mol_block_list ), intent ( in ) :: b integer ( IK ), intent ( in ) :: ispc integer ( IK ) :: res res = 0 if ( ALLOCATED ( b % b )) then if ( ispc < 1 . or . SIZE ( b % b ) < ispc ) return if ( b % b ( ispc )% n <= b % b ( ispc )% g ) return res = b % b ( ispc )% p + b % d * b % b ( ispc )% m * ( b % b ( ispc )% n - b % b ( ispc )% g ); return end if end function mol_block_list_res_pointer ! pure elemental function mol_block_list_nspecies ( this ) result ( res ) class ( mol_block_list ), intent ( in ) :: this integer ( IK ) :: res if (. not . ALLOCATED ( this % b )) then res = 0 else res = SIZE ( this % b ) end if end function mol_block_list_nspecies ! pure elemental function mol_block_list_invalid ( this ) result ( res ) class ( mol_block_list ), intent ( in ) :: this logical :: res if ( this % d < 1 . or . . not . ALLOCATED ( this % b )) then res = . false . else res = ANY ( mol_block_invalid ( this % b )) end if end function mol_block_list_invalid ! pure elemental function mol_block_list_has_child ( this ) result ( res ) class ( mol_block_list ), intent ( in ) :: this logical :: res res = . false . if ( ALLOCATED ( this % b )) res = ANY ( this % b % g > 0 ) end function mol_block_list_has_child ! pure elemental function mol_block_invalid ( b ) result ( res ) type ( mol_block ), intent ( in ) :: b logical :: res res = ( b % m < 1 ) . or . ( b % n < 1 ) . or . ( b % m < b % f ) . or . ( b % n < b % g ) end function mol_block_invalid ! pure elemental subroutine mol_block_list_clear ( this ) class ( mol_block_list ), intent ( inout ) :: this if ( ALLOCATED ( this % b )) deallocate ( this % b ) end subroutine mol_block_list_clear ! pure elemental subroutine mol_block_list_destroy ( this ) type ( mol_block_list ), intent ( inout ) :: this if ( ALLOCATED ( this % b )) deallocate ( this % b ) end subroutine mol_block_list_destroy ! end module mod_mol_block","tags":"","loc":"sourcefile/mod_mol_block.f90.html"},{"title":"mod_Hungarian.f90 – symRMSD","text":"Contents Modules mod_Hungarian Source Code mod_Hungarian.f90 Source Code module mod_Hungarian use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO , RHUGE implicit none private public :: Hungarian , Hungarian_value ! contains ! pure function Hungarian_value ( n , C ) result ( res ) integer ( IK ), intent ( in ) :: n !! matrix dimension real ( RK ), intent ( in ) :: C ( * ) !! n*n score matrix. real ( RK ) :: res if ( n < 1 ) then res = ZERO return elseif ( n == 1 ) then res = C ( 1 ) elseif ( n == 2 ) then if ( C ( 1 ) + C ( 4 ) >= C ( 2 ) + C ( 3 )) then res = C ( 1 ) + C ( 4 ) else res = C ( 2 ) + C ( 3 ) end if else block real ( RK ) :: W ( n + n + 1 ) integer ( IK ) :: iw ( 3 * ( n + 1 )), i , j ! call get_piv ( n , n + 1 , C , iw ( 1 ), iw ( n + 2 ), iw ( n + n + 3 ), W ( 1 ), W ( n + 1 )) res = ZERO do i = 1 , n j = i + n * ( iw ( i ) - 1 ) res = res + C ( j ) end do end block end if end function Hungarian_value ! !| Hungarian method pure  subroutine Hungarian ( n , C , W , piv ) integer ( IK ), intent ( in ) :: n !! matrix dimension real ( RK ), intent ( in ) :: C ( * ) !! pivot index real ( RK ), intent ( inout ) :: W ( * ) !! work array integer ( IK ), intent ( inout ), optional :: piv ( * ) !! n*n score matrix. ! if ( n < 0 ) then ! query work array size W ( 1 ) = ABS ( n + n ) + 1 elseif ( n == 0 ) then return elseif ( n == 1 ) then W ( 1 ) = C ( 1 ) if ( PRESENT ( piv )) piv ( 1 ) = 1 elseif ( n == 2 ) then W ( 1 ) = C ( 1 ) + C ( 4 ) W ( 2 ) = C ( 2 ) + C ( 3 ) if ( W ( 1 ) >= W ( 2 )) then if ( PRESENT ( piv )) then piv ( 1 ) = 1 piv ( 2 ) = 2 end if else W ( 2 ) = W ( 1 ) if ( PRESENT ( piv )) then piv ( 1 ) = 2 piv ( 2 ) = 1 end if endif else block integer ( IK ) :: iw ( n + n + n + 3 ), n1 , i , j ! n1 = n + 1 call get_piv ( n , n1 , C , iw ( 1 ), iw ( n + 2 ), iw ( n + n + 3 ), W ( 1 ), W ( n + 1 )) ! W ( 1 ) = ZERO do i = 1 , n j = i + n * ( iw ( i ) - 1 ) W ( 1 ) = W ( 1 ) + C ( j ) end do ! if ( PRESENT ( piv )) then do concurrent ( i = 1 : n ) piv ( i ) = iw ( i ) end do end if ! end block end if ! end subroutine Hungarian ! pure subroutine get_piv ( n , n1 , C , piv , is_visited , prv , y , cij ) integer ( IK ), intent ( in ) :: n , n1 real ( RK ), intent ( in ) :: C ( n , n ) integer ( IK ), intent ( inout ) :: piv ( n1 ), is_visited ( n1 ), prv ( n1 ) real ( RK ), intent ( inout ) :: y ( * ), cij ( * ) real ( RK ) :: minc , edge , cedg integer ( IK ) :: i , ic , ix , j ! do concurrent ( i = 1 : n1 ) piv ( i ) = - 1 end do ! do concurrent ( i = 1 : n1 ) y ( i ) = ZERO end do ! do j = 1 , n ! do concurrent ( i = 1 : n1 ) is_visited ( i ) = 0 end do ! do concurrent ( i = 1 : n1 ) prv ( i ) = - 1 end do ! do concurrent ( i = 1 : n ) cij ( i ) = RHUGE end do cij ( n1 ) = ZERO ! ic = n1 piv ( ic ) = j ! do while ( piv ( ic ) /= - 1 ) minc = RHUGE is_visited ( ic ) = 1 ix = - 1 do i = 1 , n if ( is_visited ( i ) == 0 ) then edge = C ( i , piv ( ic )) - y ( i ) if ( ic < n1 ) edge = edge - C ( ic , piv ( ic )) + y ( ic ) cedg = cij ( ic ) + edge if ( cij ( i ) > cedg ) then prv ( i ) = ic cij ( i ) = cedg end if if ( minc > cij ( i )) then ix = i minc = cij ( i ) end if end if end do ic = ix end do ! do concurrent ( i = 1 : n ) if ( i /= ic ) cij ( i ) = MIN ( cij ( i ), cij ( ic )) end do do concurrent ( i = 1 : n ) y ( i ) = y ( i ) + cij ( i ) end do ! do while ( ic /= n1 ) i = prv ( ic ) piv ( ic ) = piv ( i ) ic = i end do ! end do ! end subroutine get_piv ! end module mod_Hungarian","tags":"","loc":"sourcefile/mod_hungarian.f90.html"},{"title":"mod_mol_symmetry.f90 – symRMSD","text":"Contents Modules mod_mol_symmetry Source Code mod_mol_symmetry.f90 Source Code module mod_mol_symmetry use mod_params , only : IK , RK use mod_group_permutation use mod_group_permutation implicit none private public :: mol_symmetry ! type mol_symmetry private integer ( IK ) :: m = 0 type ( group_permutation ), allocatable :: p (:) contains procedure :: n_atom => mol_symmetry_n_atom procedure :: n_sym => mol_symmetry_n_sym procedure :: swap => mol_symmetry_swap procedure :: reverse => mol_symmetry_reverse procedure :: clear => mol_symmetry_clear final :: mol_symmetry_destroy end type mol_symmetry ! interface mol_symmetry module procedure mol_symmetry_new end interface mol_symmetry ! contains ! !| Constructer pure function mol_symmetry_new ( sym ) result ( res ) integer ( IK ), intent ( in ), optional :: sym (:, :) !! symmetry indices type ( mol_symmetry ) :: res integer ( IK ) :: i , n ! if ( PRESENT ( sym )) then res % m = SIZE ( sym , 1 ) n = SIZE ( sym , 2 ) ALLOCATE ( res % p ( n )) do concurrent ( i = 1 : n ) res % p ( i ) = group_permutation ( sym (:, i )) enddo end if ! end function mol_symmetry_new ! pure elemental function mol_symmetry_n_atom ( this ) result ( res ) class ( mol_symmetry ), intent ( in ) :: this integer ( IK ) :: res res = this % m end function mol_symmetry_n_atom ! pure elemental function mol_symmetry_n_sym ( this ) result ( res ) class ( mol_symmetry ), intent ( in ) :: this integer ( IK ) :: res if ( ALLOCATED ( this % p )) then res = SIZE ( this % p ) else res = 0 end if end function mol_symmetry_n_sym ! pure subroutine mol_symmetry_swap ( this , d , X , isym ) class ( mol_symmetry ), intent ( in ) :: this integer ( IK ), intent ( in ) :: d , isym real ( RK ), intent ( inout ) :: X ( * ) if ( isym < 1 . or . this % n_sym () < isym ) return call this % p ( isym )% swap ( d , X ) end subroutine mol_symmetry_swap ! pure subroutine mol_symmetry_reverse ( this , d , X , isym ) class ( mol_symmetry ), intent ( in ) :: this integer ( IK ), intent ( in ) :: d , isym real ( RK ), intent ( inout ) :: X ( * ) if ( isym < 1 . or . this % n_sym () < isym ) return call this % p ( isym )% reverse ( d , X ) end subroutine mol_symmetry_reverse ! pure elemental subroutine mol_symmetry_clear ( this ) class ( mol_symmetry ), intent ( inout ) :: this this % m = 0 if ( ALLOCATED ( this % p )) deallocate ( this % p ) end subroutine mol_symmetry_clear ! pure elemental subroutine mol_symmetry_destroy ( this ) type ( mol_symmetry ), intent ( inout ) :: this call this % clear () end subroutine mol_symmetry_destroy ! end module mod_mol_symmetry","tags":"","loc":"sourcefile/mod_mol_symmetry.f90.html"},{"title":"mod_branch_and_prune.f90 – symRMSD","text":"Contents Modules mod_branch_and_prune Source Code mod_branch_and_prune.f90 Source Code module mod_branch_and_prune use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO , RHUGE use mod_mol_block use mod_group_permutation use mod_mol_symmetry use mod_d_matrix use mod_estimate_rotation_matrix use mod_tree implicit none private public :: branch_and_prune ! type breadth_indicator sequence private integer ( IK ) :: ispc integer ( IK ) :: iper integer ( IK ) :: jper integer ( IK ) :: isym integer ( IK ) :: jsym integer ( IK ) :: nper integer ( IK ) :: nsym integer ( IK ) :: nnod end type breadth_indicator ! type branch_and_prune private integer ( IK ) :: bs , nd , mem integer ( IK ), public :: mn , dmn , memsize integer ( IK ), public :: ratio , nsrch , lncmb , xp , yp integer ( IK ), public :: upperbound , lowerbound integer ( IK ), allocatable :: p (:), q (:) type ( d_matrix_list ) :: dx type ( tree ) :: tr type ( breadth_indicator ), allocatable :: bi (:) type ( mol_symmetry ), allocatable :: ms (:) contains procedure :: setup => branch_and_prune_setup procedure :: run => branch_and_prune_run procedure :: clear => branch_and_prune_clear final :: branch_and_prune_destroy end type branch_and_prune ! interface branch_and_prune module procedure branch_and_prune_new end interface branch_and_prune ! interface include 'dgemm.h' include 'dcopy.h' end interface ! contains ! !| generate node instance pure function branch_and_prune_new ( blk , ms ) result ( res ) type ( mol_block_list ), intent ( in ) :: blk type ( mol_symmetry ), intent ( in ), optional :: ms ( * ) type ( branch_and_prune ) :: res integer ( IK ) :: i , j , pi ! res % mn = blk % mn res % dmn = blk % d * blk % mn res % mem = res % dmn * 2 + 3 ! pi = 1 res % ratio = pi ; pi = pi + 1 res % nsrch = pi ; pi = pi + 1 res % lncmb = pi ; pi = pi + 1 res % xp = pi ; pi = pi + res % dmn res % yp = pi ; pi = pi + res % dmn ! res % dx = d_matrix_list ( blk , pi ); pi = pi + res % dx % memsize () ! res % nd = res % dx % n_depth () res % bs = res % dx % dd + 2 ! allocate ( res % bi ( res % nd )) ! do concurrent ( j = 1 : res % dx % l ) block integer ( IK ) :: k k = SUM ( res % dx % m (: j - 1 )% g ) do concurrent ( i = 1 : res % dx % m ( j )% g ) block integer ( IK ) :: ib , nper , nnod nper = res % dx % m ( j )% g - i + 1 nnod = nper * res % dx % m ( j )% s ib = k + i res % bi ( ib ) = breadth_indicator ( j , i , i , 0 , 0 , nper , res % dx % m ( j )% s , nnod ) end block end do end block end do ! res % tr = tree ( pi , res % bs , res % nd + 1 , [ 1 , res % bi % nnod ]); pi = pi + res % tr % memsize ! res % upperbound = res % tr % upperbound res % lowerbound = res % tr % lowerbound ! allocate ( res % p ( res % dx % l )) res % p ( 1 ) = 1 do i = 2 , res % dx % l res % p ( i ) = res % p ( i - 1 ) + res % dx % m ( i - 1 )% g end do ! allocate ( res % q ( res % dx % l )) res % q ( 1 ) = res % yp do i = 2 , res % dx % l res % q ( i ) = res % q ( i - 1 ) + res % dx % d * res % dx % m ( i - 1 )% m * res % dx % m ( i - 1 )% n end do ! allocate ( res % ms ( res % dx % l )) if ( PRESENT ( ms )) then do concurrent ( i = 1 : res % dx % l ) res % ms ( i ) = ms ( i ) end do end if ! call res % tr % reset () ! res % memsize = pi ! end function branch_and_prune_new ! pure subroutine branch_and_prune_setup ( this , X , Y , W ) class ( branch_and_prune ), intent ( in ) :: this real ( RK ), intent ( in ) :: X ( * ) real ( RK ), intent ( in ) :: Y ( * ) real ( RK ), intent ( inout ) :: W ( * ) integer ( IK ) :: p ! call DCOPY ( this % dmn , X , 1 , W ( this % xp ), 1 ) call DCOPY ( this % dmn , Y , 1 , W ( this % yp ), 1 ) call this % dx % eval ( this % ms , X , Y , W ) ! p = this % tr % nodes_pointer () W ( p ) = W ( this % dx % o ) p = p + 1 W ( p ) = W ( this % dx % h ) p = p + 1 call DCOPY ( this % dx % dd , W ( this % dx % c ), 1 , W ( p ), 1 ) ! W ( this % tr % upperbound ) = RHUGE W ( this % tr % lowerbound ) = W ( this % dx % o ) W ( this % lncmb ) = this % tr % log_ncomb () ! end subroutine branch_and_prune_setup ! pure subroutine branch_and_prune_run ( this , W , swap_y ) class ( branch_and_prune ), intent ( in ) :: this real ( RK ), intent ( inout ) :: W ( * ) logical , intent ( in ) :: swap_y type ( tree ) :: tr type ( breadth_indicator ), allocatable :: bi (:) integer ( IK ) :: cur , pp , cix , ncount ! tr = this % tr bi = this % bi ncount = 0 ! call tr % set_parent_node ( W ) ! do do call tr % open_node () cur = tr % current_depth () - 1 call set_hc ( this % dx , tr , bi , cur , this % nd , this % bs , W ) call tr % prune ( W ) ! if ( tr % finished ()) exit ! call tr % set_parent_node ( W ) cix = tr % current_index () bi ( cur )% isym = ( cix - 1 ) / bi ( cur )% nper call swap_iper ( this % nd , cur , cix , bi ) if ( cur == this % nd ) then ncount = ncount + 1 pp = tr % current_pointer () if ( W ( tr % upperbound ) > W ( pp )) then call breadth_indicator_save ( bi ) call DCOPY ( tr % memnode , W ( pp ), 1 , W ( tr % ubnode ), 1 ) end if exit end if end do ! call tr % set_lowerbound ( W ) ! do while ( tr % finished () . and . cur > 0 ) call tr % close_node () call paws_iper ( this % nd , cur , bi ) call tr % prune ( W ) cur = cur - 1 end do ! if ( cur == 0 ) exit ! call tr % set_parent_node ( W ) block integer ( IK ) :: cix cix = tr % current_index () bi ( cur )% isym = ( cix - 1 ) / bi ( cur )% nper call swap_iper ( this % nd , cur , cix , bi ) end block end do ! W ( this % nsrch ) = REAL ( ncount , RK ) if ( ncount < 1 ) then W ( this % ratio ) = - RHUGE else W ( this % ratio ) = LOG ( W ( this % nsrch )) - W ( this % lncmb ) end if ! if (. not . swap_y ) return ! block integer ( IK ) :: ig , ic ig = tr % ubnode + 1 ic = tr % ubnode + 2 call rotation ( this % dx % d , this % dx % dd , this % mn , this % dmn , W ( ig ), W ( ic ), W ( this % yp )) end block ! block integer ( IK ) :: i do concurrent ( i = 1 : this % dx % l ) call swap ( this % dx % d , this % dx % m ( i )% m , this % dx % m ( i )% g , & & bi ( this % p ( i ): this % p ( i ) + this % dx % m ( i )% g - 1 )% jper , & & bi ( this % p ( i ): this % p ( i ) + this % dx % m ( i )% g - 1 )% jsym , & & this % ms ( i ), W ( this % q ( i ))) end do end block ! contains ! pure subroutine swap_iper ( nd , cur , inod , b ) integer ( IK ), intent ( in ) :: nd , cur , inod type ( breadth_indicator ), intent ( inout ) :: b ( nd ) integer ( IK ) :: ip , sw , i ip = MODULO ( inod - 1 , b ( cur )% nper ) sw = b ( cur + ip )% iper do i = cur + ip - 1 , cur , - 1 b ( i + 1 )% iper = b ( i )% iper end do b ( cur )% iper = sw end subroutine swap_iper ! pure subroutine paws_iper ( nd , cur , bi ) integer ( IK ), intent ( in ) :: nd , cur type ( breadth_indicator ), intent ( inout ) :: bi ( nd ) integer ( IK ) :: sw , i if ( cur < 2 ) return do i = cur , nd if ( bi ( i - 1 )% ispc /= bi ( i )% ispc . or . bi ( i - 1 )% iper < bi ( i )% iper ) return sw = bi ( i - 1 )% iper bi ( i - 1 )% iper = bi ( i )% iper bi ( i )% iper = sw end do end subroutine paws_iper ! pure subroutine set_hc ( dm , tr , bi , cur , nd , bs , W ) integer ( IK ), intent ( in ) :: cur , nd , bs type ( d_matrix_list ), intent ( in ) :: dm type ( tree ), intent ( in ) :: tr type ( breadth_indicator ), intent ( in ) :: bi ( nd ) real ( RK ), intent ( inout ) :: W ( * ) integer ( IK ) :: iper ( nd ) integer ( IK ) :: i , j , p , q , ph , nx ! p = tr % parent_pointer () ph = p + 1 q = tr % nodes_pointer () - bs iper = bi % iper nx = dm % dd + 1 ! do concurrent ( i = 1 : bi ( cur )% nper , j = 0 : bi ( cur )% nsym - 1 ) block integer ( IK ) :: t , h , c t = q + bs * ( i + bi ( cur )% nper * j ) h = t + 1 c = t + 2 call DCOPY ( nx , W ( ph ), 1 , W ( h ), 1 ) call dm % partial_eval ( cur , iper , i , j , W , W ( t ), W ( h ), W ( c )) end block end do ! end subroutine set_hc ! pure subroutine swap ( d , m , g , iper , isym , ms , X ) integer ( IK ), intent ( in ) :: d , m , g integer ( IK ), intent ( in ) :: iper ( g ), isym ( g ) type ( mol_symmetry ), intent ( in ) :: ms real ( RK ), intent ( inout ) :: X ( d , m , g ) type ( group_permutation ) :: gp integer ( IK ) :: i gp = group_permutation ( iper ) do concurrent ( i = 1 : g ) call ms % swap ( d , X ( 1 , 1 , i ), isym ( i )) end do call gp % reverse ( d * m , X ) end subroutine swap ! pure subroutine rotation ( d , dd , mn , dmn , H , C , Y ) integer ( IK ), intent ( in ) :: d , dd , mn , dmn real ( RK ), intent ( in ) :: H , C ( d , d ) real ( RK ), intent ( inout ) :: Y ( d , mn ) real ( RK ) :: V ( 1 ) integer ( IK ) :: nw ! call estimate_rotation_matrix ( - d , V ( 1 ), V , V , V ) nw = dd + MAX ( dmn , NINT ( V ( 1 ))) ! block real ( RK ) :: WL ( nw ) call estimate_rotation_matrix ( d , H , C , WL ( 1 ), WL ( dd + 1 )) call DGEMM ( 'T' , 'N' , d , mn , d , ONE , WL , d , Y , d , ZERO , WL ( dd + 1 ), d ) call DCOPY ( dmn , WL ( dd + 1 ), 1 , Y , 1 ) end block ! end subroutine rotation ! end subroutine branch_and_prune_run ! pure elemental subroutine branch_and_prune_clear ( this ) class ( branch_and_prune ), intent ( inout ) :: this call this % dx % clear () call this % tr % clear () if ( ALLOCATED ( this % p )) deallocate ( this % p ) if ( ALLOCATED ( this % q )) deallocate ( this % q ) if ( ALLOCATED ( this % ms )) deallocate ( this % ms ) end subroutine branch_and_prune_clear ! pure elemental subroutine branch_and_prune_destroy ( this ) type ( branch_and_prune ), intent ( inout ) :: this call branch_and_prune_clear ( this ) end subroutine branch_and_prune_destroy ! !!! ! pure elemental subroutine breadth_indicator_save ( this ) type ( breadth_indicator ), intent ( inout ) :: this this % jper = this % iper this % jsym = this % isym end subroutine breadth_indicator_save ! end module mod_branch_and_prune","tags":"","loc":"sourcefile/mod_branch_and_prune.f90.html"},{"title":"mod_det.f90 – symRMSD","text":"Contents Modules mod_det Source Code mod_det.f90 Source Code module mod_det use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO implicit none private public :: det , det_ , det_sign ! interface include 'dgetrf.h' end interface ! interface det module procedure :: det_full , det_part end interface det ! interface det_ module procedure :: det_func end interface det_ ! interface det_sign module procedure :: det_sign_copy , det_sign_full , det_sign_part end interface det_sign ! contains ! !| calculate determinant of square matrix x. pure function det_func ( d , x ) result ( res ) integer ( IK ), intent ( in ) :: d !! matrix dimension real ( RK ), intent ( in ) :: x ( d , d ) !! square matrix, on exit, x(1) is assigned the determinant of x, !! and the other elements are undefined. real ( RK ) :: y ( d * d ) real ( RK ) :: res y = [ x ] call det_full ( d , y ) res = y ( 1 ) end function det_func ! !| calculate determinant of square matrix x. pure subroutine det_full ( d , x ) integer ( IK ), intent ( in ) :: d !! matrix dimension real ( RK ), intent ( inout ) :: x ( * ) !! square matrix, on exit, x(1) is assigned the determinant of x, !! and the other elements are undefined. ! if ( d <= 1 ) then ! return ! elseif ( d == 2 ) then ! x ( 1 ) = x ( 1 ) * x ( 4 ) - x ( 2 ) * x ( 3 ) ! elseif ( d == 3 ) then ! x ( 1 ) = x ( 1 ) * ( x ( 5 ) * x ( 9 ) - x ( 8 ) * x ( 6 )) + & & x ( 4 ) * ( x ( 8 ) * x ( 3 ) - x ( 2 ) * x ( 9 )) + & & x ( 7 ) * ( x ( 2 ) * x ( 6 ) - x ( 5 ) * x ( 3 )) ! else ! call det_part ( d , x , d ) ! end if ! end subroutine det_full ! !| calculate determinant of square matrix x, with leading dimension. pure subroutine det_part ( d , x , ld ) integer ( IK ), intent ( in ) :: d !! matrix dimension real ( RK ), intent ( inout ) :: x ( * ) !! square matrix, on exit, x(1) is assigned the determinant of x, !! and the other elements are undefined. integer ( IK ), intent ( in ) :: ld !! leading dimension ! if ( d <= 1 ) then ! return ! elseif ( d == 2 ) then block integer ( IK ) :: l2 l2 = MAX ( d , ld ) + 1 x ( 1 ) = x ( 1 ) * x ( l2 + 1 ) - x ( 2 ) * x ( l2 ) end block elseif ( d == 3 ) then block integer ( IK ) :: l2 , l3 l2 = MAX ( d , ld ) l3 = l2 + l2 l2 = l2 + 1 l3 = l3 + 1 !&< x ( 1 ) = x ( 1 ) * ( x ( 1 + l2 ) * x ( 2 + l3 ) - x ( 1 + l3 ) * x ( 2 + l2 )) + & & x ( l2 ) * ( x ( 1 + l3 ) * x ( 2 + 1 ) - x ( 1 + 1 ) * x ( 2 + l3 )) + & & x ( l3 ) * ( x ( 1 + 1 ) * x ( 2 + l2 ) - x ( 1 + l2 ) * x ( 2 + 1 )) !>& end block else block integer ( IK ) :: i , j , k , ipiv ( d ) k = MAX ( d , ld ) call DGETRF ( d , d , x , k , ipiv ( 1 : d ), j ) if ( MODULO ( COUNT ([( ipiv ( i ) == i , i = 1 , d )]), 2 ) == 1 ) x ( 1 ) = - x ( 1 ) ipiv ( 1 ) = k + 1 k = k * d do i = 2 , d j = k - ipiv ( 1 ) x ( j ) = x ( j ) * x ( k ) k = j end do end block end if ! end subroutine det_part ! !| calculate determinant sign of square matrix x, with leading dimension. ! pure subroutine det_sign_copy ( d , x , w ) integer ( IK ), intent ( in ) :: d !! matrix dimension real ( RK ), intent ( in ) :: x ( * ) !! d * d square matrix. real ( RK ), intent ( inout ) :: w ( * ) !! work array, on exit, w(1) is assigned the determinant sign of x. w (: d * d ) = x (: d * d ) call det_sign_full ( d , w ) end subroutine det_sign_copy ! pure subroutine det_sign_full ( d , x ) integer ( IK ), intent ( in ) :: d !! matrix dimension real ( RK ), intent ( inout ) :: x ( * ) !! square matrix, on exit, x(1) is assigned the determinant sign of x, <br> !! and the other elements are undefined. ! if ( d < 1 ) then ! return ! elseif ( d == 1 ) then ! x ( 1 ) = SIGN ( ONE , x ( 1 )) ! elseif ( d == 2 ) then ! x ( 1 ) = SIGN ( ONE , x ( 1 ) * x ( 4 ) - x ( 2 ) * x ( 3 )) ! elseif ( d == 3 ) then ! x ( 1 ) = SIGN ( ONE , x ( 1 ) * ( x ( 5 ) * x ( 9 ) - x ( 8 ) * x ( 6 )) + & & x ( 4 ) * ( x ( 8 ) * x ( 3 ) - x ( 2 ) * x ( 9 )) + & & x ( 7 ) * ( x ( 2 ) * x ( 6 ) - x ( 5 ) * x ( 3 )) ) ! else ! call det_sign_part ( d , x , d ) end if ! end subroutine det_sign_full ! !| calculate determinant sign of square matrix x, with leading dimension. ! pure subroutine det_sign_part ( d , x , ld ) integer ( IK ), intent ( in ) :: d !! matrix dimension real ( RK ), intent ( inout ) :: x ( * ) !! square matrix, on exit, x(1) is assigned the determinant sign of x, <br> !! and the other elements are undefined. integer ( IK ), intent ( in ) :: ld !! leading dimension ! if ( d < 1 ) then ! return ! elseif ( d == 1 ) then ! x ( 1 ) = SIGN ( ONE , x ( 1 )) ! elseif ( d == 2 ) then ! block integer ( IK ) :: l2 l2 = MAX ( d , ld ) + 1 x ( 1 ) = SIGN ( ONE , x ( 1 ) * x ( l2 + 1 ) - x ( 2 ) * x ( l2 )) end block ! elseif ( d == 3 ) then ! block integer ( IK ) :: l2 , l3 l2 = MAX ( d , ld ) l3 = l2 + l2 l2 = l2 + 1 l3 = l3 + 1 !&< x ( 1 ) = SIGN ( ONE , x ( 1 ) * ( x ( 1 + l2 ) * x ( 2 + l3 ) - x ( 1 + l3 ) * x ( 2 + l2 )) + & & x ( l2 ) * ( x ( 1 + l3 ) * x ( 2 + 1 ) - x ( 1 + 1 ) * x ( 2 + l3 )) + & & x ( l3 ) * ( x ( 1 + 1 ) * x ( 2 + l2 ) - x ( 1 + l2 ) * x ( 2 + 1 ))) !>& end block ! else ! block integer ( IK ) :: i , j , k , ipiv ( d ) k = MAX ( d , ld ) call DGETRF ( d , d , x , k , ipiv , j ) ipiv ( 1 ) = COUNT ([( ipiv ( i ) == i , i = 1 , d )]) j = 1 k = k + 1 do i = 1 , d if ( x ( j ) <= ZERO ) ipiv ( 1 ) = ipiv ( 1 ) + 1 j = j + k end do if ( MODULO ( ipiv ( 1 ), 2 ) == 0 ) then x ( 1 ) = ONE else x ( 1 ) = - ONE endif end block ! end if ! end subroutine det_sign_part ! end module mod_det","tags":"","loc":"sourcefile/mod_det.f90.html"},{"title":"mod_params.f90 – symRMSD","text":"Contents Modules mod_params Source Code mod_params.f90 Source Code module mod_params use , intrinsic :: ISO_FORTRAN_ENV , only : & & STDIN => INPUT_UNIT , & & STDOUT => OUTPUT_UNIT , & & STDERR => ERROR_UNIT , & & R4 => REAL32 , & & R8 => REAL64 , & & RQ => REAL128 , & & I1 => INT8 , & & I2 => INT16 , & & I4 => INT32 , & & I8 => INT64 implicit none private public :: R4 , R8 , RQ public :: I1 , I2 , I4 , I8 public :: RK , IK , LK public :: STDIN , STDOUT , STDERR public :: RZERO , RONE , RHALF , RFOUR , RHUGE public :: NEWLINE , CNULL , CARRET , ESCSEQ public :: FS_BOLD , FS_WEAK , FS_UNDER_LINE , FS_INVERT , FS_CROSSED_OUT , FS_RESET public :: FC_BLACK , FC_RED , FC_GREEN , FC_YELLOW public :: FC_MAGENTA , FC_CYAN , FC_WHITE ! !&< ! integer , parameter :: IK = I4 integer , parameter :: RK = R8 integer , parameter :: LK = KIND (. true .) ! real ( RK ), parameter :: RZERO = 0.0_RK real ( RK ), parameter :: RONE = 1.0_RK real ( RK ), parameter :: RHALF = 0.5_RK real ( RK ), parameter :: RFOUR = 4.0_RK ! real ( RK ), parameter :: RHUGE = HUGE ( RZERO ) ! character ( * ), parameter :: NEWLINE = NEW_LINE ( ' ' ) character ( * ), parameter :: CNULL = CHAR ( 0 ) character ( * ), parameter :: CARRET = CHAR ( 13 ) character ( * ), parameter :: ESCSEQ = CHAR ( 27 ) ! character ( * ), parameter :: FS_BOLD = ESCSEQ // '[1m' character ( * ), parameter :: FS_WEAK = ESCSEQ // '[2m' character ( * ), parameter :: FS_UNDER_LINE = ESCSEQ // '[4m' character ( * ), parameter :: FS_INVERT = ESCSEQ // '[7m' character ( * ), parameter :: FS_CROSSED_OUT = ESCSEQ // '[9m' character ( * ), parameter :: FS_RESET = ESCSEQ // '[0m' ! character ( * ), parameter :: FC_BLACK = ESCSEQ // '[30m' character ( * ), parameter :: FC_RED = ESCSEQ // '[31m' character ( * ), parameter :: FC_GREEN = ESCSEQ // '[32m' character ( * ), parameter :: FC_YELLOW = ESCSEQ // '[33m' character ( * ), parameter :: FC_BLUE = ESCSEQ // '[34m' character ( * ), parameter :: FC_MAGENTA = ESCSEQ // '[35m' character ( * ), parameter :: FC_CYAN = ESCSEQ // '[36m' character ( * ), parameter :: FC_WHITE = ESCSEQ // '[37m' ! !&> ! end module mod_params","tags":"","loc":"sourcefile/mod_params.f90.html"},{"title":"mod_symRMSD.f90 – symRMSD","text":"Contents Modules mod_symRMSD Source Code mod_symRMSD.f90 Source Code module mod_symRMSD use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO , RHUGE use mod_branch_and_prune use mod_mol_block use mod_mol_symmetry implicit none public :: symRMSD public :: symRMSD_input ! type symRMSD_input type ( mol_block_list ) :: blk type ( mol_symmetry ), allocatable :: ms (:) contains procedure :: add_molecule => symRMSD_input_add_molecule procedure :: clear => symRMSD_input_clear final :: symRMSD_input_destroy end type symRMSD_input ! type symRMSD private integer ( IK ), public :: nmem = 0 integer ( IK ), public :: ndim = 0 integer ( IK ), public :: natm = 0 type ( branch_and_prune ) :: bra contains procedure :: run => symRMSD_run procedure :: sd => symRMSD_sd procedure :: rmsd => symRMSD_rmsd procedure :: search_ratio => symRMSD_search_ratio procedure :: clear => symRMSD_clear final :: symRMSD_destroy end type symRMSD ! interface symRMSD module procedure symRMSD_new end interface symRMSD ! interface include 'dcopy.h' end interface ! contains ! pure subroutine symRMSD_input_add_molecule ( this , b , s ) class ( symRMSD_input ), intent ( inout ) :: this type ( mol_block ), intent ( in ) :: b integer ( IK ), intent ( in ) :: s ( * ) type ( mol_symmetry ), allocatable :: ms (:) integer ( IK ) :: l , i , n , h ( 2 ) ! call this % blk % add_molecule ( b ) ! l = this % blk % nspecies () h ( 1 ) = this % blk % b ( l )% m h ( 2 ) = this % blk % b ( l )% s - 1 n = h ( 1 ) * h ( 2 ) ! allocate ( ms ( l )) do concurrent ( i = 1 : l - 1 ) ms ( i ) = this % ms ( i ) end do ms ( l ) = mol_symmetry ( RESHAPE ( s (: n ), h )) call move_alloc ( from = ms , to = this % ms ) ! end subroutine symRMSD_input_add_molecule pure elemental subroutine symRMSD_input_clear ( this ) class ( symRMSD_input ), intent ( inout ) :: this call this % blk % clear () if ( ALLOCATED ( this % ms )) deallocate ( this % ms ) end subroutine symRMSD_input_clear ! pure elemental subroutine symRMSD_input_destroy ( this ) type ( symRMSD_input ), intent ( inout ) :: this call symRMSD_input_clear ( this ) end subroutine symRMSD_input_destroy ! !!! ! pure function symRMSD_new ( inp ) result ( res ) type ( symRMSD_input ), intent ( in ) :: inp type ( symRMSD ) :: res ! if ( ALLOCATED ( inp % ms )) then res % bra = branch_and_prune ( inp % blk , inp % ms ) else res % bra = branch_and_prune ( inp % blk ) end if ! res % nmem = res % bra % memsize res % ndim = inp % blk % d res % natm = inp % blk % mn ! end function symRMSD_new ! pure subroutine symRMSD_run ( this , swap_y , x , y , w ) class ( symRMSD ), intent ( in ) :: this logical , intent ( in ) :: swap_y real ( RK ), intent ( in ) :: x ( * ) real ( RK ), intent ( inout ) :: y ( * ) real ( RK ), intent ( inout ) :: w ( * ) ! call this % bra % setup ( x , y , w ) call this % bra % run ( w , swap_y ) if ( swap_y ) call dcopy ( this % bra % dmn , w ( this % bra % yp ), 1 , y , 1 ) ! end subroutine symRMSD_run ! pure function symRMSD_sd ( this , W ) result ( res ) class ( symRMSD ), intent ( in ) :: this real ( RK ), intent ( in ) :: w ( * ) real ( RK ) :: res res = W ( this % bra % upperbound ) end function symRMSD_sd ! pure function symRMSD_rmsd ( this , W ) result ( res ) class ( symRMSD ), intent ( in ) :: this real ( RK ), intent ( in ) :: w ( * ) real ( RK ) :: res if ( this % natm > 0 ) then res = SQRT ( W ( this % bra % upperbound ) / this % natm ) else res = ZERO end if end function symRMSD_rmsd ! pure function symRMSD_search_ratio ( this , W ) result ( res ) class ( symRMSD ), intent ( in ) :: this real ( RK ), intent ( in ) :: w ( * ) real ( RK ) :: res ( 3 ) res ( 1 ) = w ( this % bra % ratio ) res ( 2 ) = w ( this % bra % lncmb ) res ( 3 ) = w ( this % bra % nsrch ) end function symRMSD_search_ratio ! pure elemental subroutine symRMSD_clear ( this ) class ( symRMSD ), intent ( inout ) :: this this % nmem = 0 call this % bra % clear () end subroutine symRMSD_clear ! pure elemental subroutine symRMSD_destroy ( this ) type ( symRMSD ), intent ( inout ) :: this call symRMSD_clear ( this ) end subroutine symRMSD_destroy ! end module mod_symRMSD","tags":"","loc":"sourcefile/mod_symrmsd.f90.html"},{"title":"test_branch_and_prune.f90 – symRMSD","text":"Contents Programs main Source Code test_branch_and_prune.f90 Source Code program main use mod_params , only : RK , IK , ONE => RONE , ZERO => RZERO use mod_mol_block use mod_estimate_rotation_matrix use mod_mol_symmetry use mod_branch_and_prune use mod_unittest implicit none type ( unittest ) :: u integer , parameter :: NTEST = 25 integer :: itest ! call u % init ( 'test branch_and_prune' ) do itest = 1 , NTEST call test1 () end do ! call test2 () ! call u % finish_and_terminate () ! contains ! subroutine test1 () integer , parameter :: d = 3 integer , parameter :: l = 1 integer , parameter :: s = 2 integer , parameter :: m = 5 , n = 8 , f = 5 , g = 3 integer , parameter :: mn = m * n type ( mol_block ) :: b = mol_block ( 0 , s , m , n , f , g ) type ( branch_and_prune ) :: bra type ( mol_block_list ) :: blk type ( mol_symmetry ) :: ms ( l ) real ( RK ) :: X ( d , mn ), Y ( d , mn ), isd , msd real ( RK ), allocatable :: W (:) integer :: i , j , k ! ms ( 1 ) = mol_symmetry ( RESHAPE ([ 2 , 3 , 1 , 4 , 5 ], [ m , 1 ])) blk = mol_block_list ( d , l , [ b ]) ! X = sample ( d , mn ) Y = sample ( d , mn ) ! bra = branch_and_prune ( blk , ms ) ! allocate ( W ( bra % memsize )) call bra % setup ( X , Y , W ) call bra % run ( W , . true .) print '(*(f16.9))' , w ( bra % lncmb ), w ( bra % nsrch ), w ( bra % ratio ) ! msd = 999 D0 do k = 0 , s - 1 do j = 0 , s - 1 do i = 0 , s - 1 isd = sd ( d , X , swp ( d , m , n , [ 1 , 2 , 3 ], [ i , j , k ], ms ( 1 ), Y )) ; msd = MIN ( msd , isd ) isd = sd ( d , X , swp ( d , m , n , [ 1 , 3 , 2 ], [ i , j , k ], ms ( 1 ), Y )) ; msd = MIN ( msd , isd ) isd = sd ( d , X , swp ( d , m , n , [ 2 , 1 , 3 ], [ i , j , k ], ms ( 1 ), Y )) ; msd = MIN ( msd , isd ) isd = sd ( d , X , swp ( d , m , n , [ 2 , 3 , 1 ], [ i , j , k ], ms ( 1 ), Y )) ; msd = MIN ( msd , isd ) isd = sd ( d , X , swp ( d , m , n , [ 3 , 1 , 2 ], [ i , j , k ], ms ( 1 ), Y )) ; msd = MIN ( msd , isd ) isd = sd ( d , X , swp ( d , m , n , [ 3 , 2 , 1 ], [ i , j , k ], ms ( 1 ), Y )) ; msd = MIN ( msd , isd ) enddo enddo enddo ! Y = RESHAPE ( W ( bra % yp : bra % yp + d * mn ), [ d , mn ]) ! call u % assert_almost_equal ( msd , W ( bra % upperbound ), 'branchcut vs brute' ) call u % assert_almost_equal ( SUM (( X - Y ) ** 2 ), W ( bra % upperbound ), 'swap a            ' ) call u % assert_almost_equal ( sd ( d , X , Y ), W ( bra % upperbound ), 'swap b            ' ) ! end subroutine test1 ! subroutine test2 () integer , parameter :: d = 3 integer , parameter :: s = 3 integer , parameter :: m1 = 5 , n1 = 3 , f1 = 3 , g1 = 2 integer , parameter :: m2 = 3 , n2 = 4 , f2 = 2 , g2 = 4 integer , parameter :: m3 = 7 , n3 = 6 , f3 = 7 , g3 = 5 integer , parameter :: mn = m1 * n1 + m2 * n2 + m3 * n3 type ( mol_block ) :: b ( 3 ) = [ mol_block ( 0 , 3 , m1 , n1 , f1 , g1 ), & & mol_block ( 0 , 1 , m2 , n2 , f2 , g2 ), & & mol_block ( 0 , 2 , m3 , n3 , f3 , g3 )] type ( branch_and_prune ) :: bra type ( mol_block_list ) :: blk type ( mol_symmetry ) :: ms ( s ) real ( RK ) :: X ( d , mn ), Y ( d , mn ) real ( RK ), allocatable :: W (:) integer :: i ! ms ( 1 ) = mol_symmetry ( RESHAPE ([ 2 , 3 , 1 , 4 , 5 , 3 , 1 , 2 , 4 , 5 ], [ m1 , 2 ])) ms ( 2 ) = mol_symmetry ( RESHAPE ([( i , i = 1 , 0 )], [ 0 , 1 ])) ms ( 3 ) = mol_symmetry ( RESHAPE ([ 7 , 6 , 5 , 4 , 3 , 2 , 1 ], [ m3 , 1 ])) blk = mol_block_list ( d , s , b ) ! X = sample ( d , mn ) Y = sample ( d , mn ) ! bra = branch_and_prune ( blk , ms ) allocate ( W ( bra % memsize )) call bra % setup ( X , Y , W ) call bra % run ( W , . true .) print '(*(f16.9))' , w ( bra % lncmb ), w ( bra % nsrch ), w ( bra % ratio ) Y = RESHAPE ( W ( bra % yp : bra % yp + d * mn ), [ d , mn ]) call u % assert_almost_equal ( sd ( d , X , Y ), W ( bra % upperbound ), 'multiple swap' ) ! end subroutine test2 ! pure function swp ( d , m , n , per , sym , ms , X ) result ( res ) integer ( IK ), intent ( in ) :: d , m , n , per (:), sym (:) type ( mol_symmetry ), intent ( in ) :: ms real ( RK ), intent ( in ) :: X ( d , m , n ) real ( RK ) :: tmp ( d , m , n ), res ( d , m * n ) integer ( IK ) :: i tmp = X do i = 1 , SIZE ( per ) tmp (:, :, per ( i )) = X (:, :, i ) call ms % swap ( d , tmp (:, :, per ( i )), sym ( i )) end do res = RESHAPE ( tmp , [ d , m * n ]) end function swp ! pure function sd ( d , X , Y ) result ( res ) integer ( IK ), intent ( in ) :: d real ( RK ), intent ( in ) :: X (:, :), Y (:, :) real ( RK ) :: C ( d , d ), R ( d , d ), W ( 100 ), res C = MATMUL ( Y , TRANSPOSE ( X )) call estimate_rotation_matrix ( d , SUM ( X * X ) + SUM ( Y * Y ), C , R , W ) res = SUM ( X ** 2 ) + SUM ( Y ** 2 ) - 2 * SUM ( C * R ) end function sd ! function sample ( d , n ) result ( res ) integer , intent ( in ) :: d , n real ( RK ) :: cnt ( d ) real ( RK ) :: res ( d , n ) integer :: i call RANDOM_NUMBER ( res ) cnt = SUM ( res , 2 ) / n do concurrent ( i = 1 : n ) res (:, i ) = res (:, i ) - cnt enddo end function sample ! end program main","tags":"","loc":"sourcefile/test_branch_and_prune.f90.html"},{"title":"test_partial_rmsd.f90 – symRMSD","text":"Contents Programs main Source Code test_partial_rmsd.f90 Source Code program main use mod_params , only : RK , IK , ONE => RONE , ZERO => RZERO use mod_rmsd use mod_rmsd_brute use mod_partial_rmsd use mod_unittest implicit none type ( unittest ) :: u integer , parameter :: NTEST = 1000 integer :: fail integer :: i ! call u % init ( 'test block_lower_bound' ) fail = 0 ! do i = 1, NTEST call test1 ( fail ) ! end do ! print*,fail,'/',NTEST ! ! fail = 0 ! do i = 1, NTEST !   call test2(i, fail) ! end do ! print *, fail, '/', NTEST ! ! fail = 0 ! do i = 1, NTEST !   call test3(fail) ! enddo ! print*,fail,'/',NTEST ! ! call test4() ! call u % finish_and_terminate () ! contains ! subroutine test1 ( fail ) integer , intent ( inout ) :: fail integer , parameter :: d = 3 integer , parameter :: n = 15 type ( partial_rmsd ) :: pr , pr2 , pr3 real ( RK ) :: X ( d * n ), Y ( d * n ) ! X = [ sample ( d , n )] Y = [ MATMUL ( SO3 (), RESHAPE ( X , [ d , n ]))] !Y = [MATMUL(MATMUL(SO3(), RESHAPE(X, [d, n])), PER15())] ! pr = partial_rmsd ( d , 5 , X (: 15 ), Y (: 15 )) print * , pr % sd (), sd ( d , 5 , X , Y ) pr2 = pr % append ( 5 , X ( 16 ), Y ( 16 )) print * , pr2 % sd (), sd ( d , 10 , X , Y ) pr3 = pr2 % append ( 5 , X ( 31 ), Y ( 31 )) print * , pr3 % sd (), sd ( d , n , X , Y ) ! !   if (w(1) > 0.0001D0) then !     fail = fail + 1 !     print'(I8,F9.6)', fail, w(1) !   end if ! end subroutine test1 ! ! subroutine test2(itest, fail) !   integer, intent(in)    :: itest !   integer, intent(inout) :: fail !   integer, parameter     :: d = 3 !   integer, parameter     :: m = 15 !   integer, parameter     :: n = 15 !   integer, parameter     :: f = 3 !   integer, parameter     :: g = 8 !   real(RK), parameter    :: lambda = 2.0_RK !   type(mol_block_list)   :: b !   real(RK)               :: X(d * m * n), Y(d * m * n) !   real(RK), allocatable  :: w(:) !   integer                :: i ! !   b = mol_block_list(d, 1, [m], [n], [f]) ! g = n !   b%b(1)%g = g !   allocate (w(block_lower_bound_worksize(b))) !   X = [([lambda * i + sample(d, m)], i=1, n)] !   call centering(d, m * n, X) !   Y = [MATMUL(MATMUL(SO3(), RESHAPE(X, [d, m * n])), PER25(m, n, g))] !   call centering(d, m * n, Y) ! !   call block_lower_bound(b, X, Y, w, nrand=5) ! !   if (w(1) > 0.01D0) then !     fail = fail + 1 !     print'(I8,A,I8,2F9.4)', fail, '/', itest, w(1), real(fail, RK) / real(itest, RK) !   end if ! ! end subroutine test2 ! ! subroutine test3(fail) !   integer, intent(inout) :: fail !   integer, parameter     :: d = 3 !   integer, parameter     :: m = 5 !   integer, parameter     :: n = 12 !   integer, parameter     :: f = 3 !   integer, parameter     :: g = 2 !   real(RK), parameter    :: lambda = 2.0_RK !   real(RK)               :: X(d * m * n * 2), Y(d * m * n * 2) !   type(mol_block_list)   :: b !   real(RK), allocatable  :: w(:) !   integer                :: i, j, k ! !   b = mol_block_list(d, 2, [m, m], [n, n], [f, f]) ! g = n !   b%b(1)%g = g !   b%b(2)%g = g ! !   X = [([([lambda * RESHAPE([([i, j, 0], k=1, m)], [d, m]) + sample(d, m)], i=1, n)], j=0, 1)] !   call centering(d, 2 * m * n, X) !   Y = [MATMUL(SO3(), RESHAPE([(MATMUL(RESHAPE(X(d * m * n * j + 1:d * m * n * (j + 1)), [d, m * n]), & !     & PER25(m, n, g)), j=0, 1)], [d, m * n * 2]))] !   call centering(d, 2 * m * n, Y) ! !   allocate (w(block_lower_bound_worksize(b))) !   call block_lower_bound(b, X, Y, w, nrand=5) ! !   if (w(1) > 0.01D0) then !     fail = fail + 1 !     print'(I8,F9.4)', fail, w(1) !   end if ! ! end subroutine test3 ! ! subroutine test4() !   integer, parameter     :: d = 3 !   integer, parameter     :: m = 5 !   integer, parameter     :: n = 5 !   integer, parameter     :: f = 3 !   integer, parameter     :: g = 2 !   real(RK), parameter    :: lambda = 5.0_RK !   real(RK)               :: X(d, m * n * 2), Y(d, m * n * 2) !   type(mol_block_list)   :: b !   real(RK), allocatable  :: w(:) !   integer                :: i, j, k ! !   b = mol_block_list(d, 2, [m, m], [n, n], [f, f]) ! g = n !   b%b(1)%g = g !   b%b(2)%g = 0 ! !   X = RESHAPE([([([lambda * RESHAPE([([i, j, 0], k=1, m)], [d, m]) + sample(d, m)], i=1, n)], j=0, 1)], [d, m * n * 2]) !   call centering(d, 2 * m * n, X) !   Y = MATMUL(SO3(), X) !   Y(:, :m * n) = MATMUL(Y(:, :m * n), PER25(m, n, g)) !   call centering(d, 2 * m * n, Y) ! !   allocate (w(block_lower_bound_worksize(b))) !   call block_lower_bound(b, X, Y, w, nrand=5) !   print *, w(1) ! ! end subroutine test4 ! function SO3 () result ( res ) real ( RK ) :: a ( 3 ), res ( 3 , 3 ) call RANDOM_NUMBER ( a ) a = a / SQRT ( DOT_PRODUCT ( a , a )) res (:, 1 ) = [ a ( 1 ) * a ( 1 ), a ( 1 ) * a ( 2 ) - a ( 3 ), a ( 1 ) * a ( 3 ) + a ( 2 )] res (:, 2 ) = [ a ( 1 ) * a ( 2 ) + a ( 3 ), a ( 2 ) * a ( 2 ), a ( 2 ) * a ( 3 ) - a ( 1 )] res (:, 3 ) = [ a ( 1 ) * a ( 3 ) - a ( 2 ), a ( 2 ) * a ( 3 ) + a ( 1 ), a ( 3 ) * a ( 3 )] end function SO3 ! function PER3 () result ( res ) real ( RK ) :: res ( 3 , 3 ) integer :: r ( 3 ) integer :: i , j call RANDOM_NUMBER ( res (:, 1 )) r ( 1 ) = MAXLOC ( res (:, 1 ), 1 ) r ( 2 ) = MAXLOC ([ res (: r ( 1 ) - 1 , 1 ), - 100 D0 , res ( r ( 1 ) + 1 :, 1 )], 1 ) r ( 3 ) = MINLOC ( res (:, 1 ), 1 ) do concurrent ( i = 1 : 3 , j = 1 : 3 ) res ( i , j ) = MERGE ( 1 , 0 , r ( i ) == j ) end do end function PER3 ! function PER15 () result ( res ) real ( RK ) :: res ( 15 , 15 ), a ! call RANDOM_NUMBER ( a ) res = 0 D0 ! if ( a < 0.5D0 ) then res ( 1 : 3 , 1 : 3 ) = PER3 () res ( 4 : 5 , 4 : 5 ) = eye ( 2 ) res ( 6 : 8 , 6 : 8 ) = PER3 () res ( 9 : 10 , 9 : 10 ) = eye ( 2 ) else res ( 1 : 3 , 6 : 8 ) = PER3 () res ( 4 : 5 , 9 : 10 ) = eye ( 2 ) res ( 6 : 8 , 1 : 3 ) = PER3 () res ( 9 : 10 , 4 : 5 ) = eye ( 2 ) end if ! res ( 11 : 15 , 11 : 15 ) = eye ( 5 ) ! end function PER15 ! ! function PER25(m, n, g) result(res) !   integer(IK), intent(in) :: m, n, g !   real(RK) :: res(m * n, m * n) !   integer(IK) :: i ! !   res = eye(m * n) ! !   do i = 0, g - 1 !     res(i * m + 1:i * m + 3, i * m + 1:i * m + 3) = PER3() !   end do ! ! end function PER25 ! pure function eye ( d ) result ( res ) integer , intent ( in ) :: d real ( RK ) :: res ( d , d ) integer :: i , j do concurrent ( j = 1 : d , i = 1 : d ) res ( i , j ) = MERGE ( 1 D0 , 0 D0 , i == j ) end do end function eye ! function sample ( d , n ) result ( res ) integer , intent ( in ) :: d , n real ( RK ) :: cnt ( d ) real ( RK ) :: res ( d , n ) integer :: i call RANDOM_NUMBER ( res ) cnt = centroid ( d , n , res ) do concurrent ( i = 1 : n ) res (:, i ) = res (:, i ) - cnt end do end function sample ! pure subroutine centering ( d , n , X ) integer , intent ( in ) :: d , n real ( RK ), intent ( inout ) :: X ( d , n ) real ( RK ) :: c ( d ) integer ( IK ) :: i c = centroid ( d , n , X ) do concurrent ( i = 1 : n ) X (:, i ) = X (:, i ) - c end do end subroutine centering ! pure function centroid ( d , n , X ) result ( res ) integer , intent ( in ) :: d , n real ( RK ), intent ( in ) :: X ( d , n ) real ( RK ) :: res ( d ) res = SUM ( X , 2 ) / n end function centroid ! end program main","tags":"","loc":"sourcefile/test_partial_rmsd.f90.html"},{"title":"test_det.f90 – symRMSD","text":"Contents Programs main Source Code test_det.f90 Source Code program main use mod_params , only : RK , IK , ONE => RONE , ZERO => RZERO use mod_det use mod_unittest implicit none type ( unittest ) :: u ! call test1 () call test2 () call test3 () call test4 () call test5 () ! call u % finish_and_terminate () ! contains ! subroutine test1 () integer , parameter :: N_TEST = 10 real ( RK ) :: W ( 1 ), X ( 1 ) integer :: i ! call u % init ( 'test det d=1' ) ! do i = 1 , N_TEST call random_number ( X ) W = X ; call det ( 1 , W ) call u % assert_almost_equal ( W ( 1 ), X ( 1 ), 'det d=1' ) W = X ; call det_sign ( 1 , W ) call u % assert_almost_equal ( W ( 1 ), SIGN ( ONE , X ( 1 )), 'det_sign d=1' ) enddo ! end subroutine test1 ! subroutine test2 () integer , parameter :: N_TEST = 10 real ( RK ) :: W ( 4 ), X ( 4 ) real ( RK ) :: da integer :: i ! call u % init ( 'test det d=2' ) ! do i = 1 , N_TEST call random_number ( X ) da = X ( 1 ) * X ( 4 ) - X ( 2 ) * X ( 3 ) W = X ; call det ( 2 , W ) call u % assert_almost_equal ( W ( 1 ), da , 'det d=2' ) W = X ; call det_sign ( 2 , W ) call u % assert_almost_equal ( W ( 1 ), SIGN ( ONE , da ), 'det_sign d=2' ) enddo ! end subroutine test2 ! subroutine test3 () integer , parameter :: N_TEST = 10 real ( RK ) :: W ( 9 ), X ( 9 ) real ( RK ) :: da integer :: i ! call u % init ( 'test det d=3' ) ! do i = 1 , N_TEST call random_number ( X ) da = X ( 1 ) * X ( 5 ) * X ( 9 ) + X ( 2 ) * X ( 6 ) * X ( 7 ) + X ( 3 ) * X ( 4 ) * X ( 8 ) & - X ( 3 ) * X ( 5 ) * X ( 7 ) - X ( 2 ) * X ( 4 ) * X ( 9 ) - X ( 1 ) * X ( 6 ) * X ( 8 ) W = X ; call det ( 3 , W ) call u % assert_almost_equal ( W ( 1 ), da , 'det d=3' ) W = X ; call det_sign ( 3 , W ) call u % assert_almost_equal ( W ( 1 ), SIGN ( ONE , da ), 'det_sign d=3' ) enddo ! end subroutine test3 ! subroutine test4 () integer , parameter :: N_TEST = 20 real ( RK ) :: W ( 16 ), Y ( 16 ), X ( 16 ) integer :: i ! call u % init ( 'test det d=4' ) ! do i = 1 , N_TEST call random_number ( X ) W = X ; call det ( 4 , W ) Y = X ; call det_sign ( 4 , Y ) call u % assert_almost_equal ( Y ( 1 ), SIGN ( ONE , W ( 1 )), 'det_sign d=4' ) enddo ! end subroutine test4 ! subroutine test5 () integer , parameter :: N_TEST = 20 integer , parameter :: d = 100 real ( RK ) :: W ( d * d ), Y ( d * d ), X ( d * d ) integer :: i ! call u % init ( 'test det d=100' ) ! do i = 1 , N_TEST call random_number ( X ) W = X ; call det ( d , W ) Y = X ; call det_sign ( d , Y ) call u % assert_almost_equal ( Y ( 1 ), SIGN ( ONE , W ( 1 )), 'det_sign d=100' ) enddo ! end subroutine test5 ! end program main","tags":"","loc":"sourcefile/test_det.f90.html"},{"title":"test_symRMSD.f90 – symRMSD","text":"Contents Programs main Source Code test_symRMSD.f90 Source Code program main use mod_params , only : RK , IK , ONE => RONE , ZERO => RZERO use mod_mol_block use mod_symRMSD use mod_unittest implicit none type ( unittest ) :: u integer , parameter :: NTEST = 1 integer :: itest ! call u % init ( 'test symRMSD' ) call test0 () ! do itest = 1 , NTEST call test1 () end do ! call u % finish_and_terminate () ! contains ! subroutine test0 () type ( symRMSD_input ) :: inp integer ( IK ), parameter :: s ( 10 ) = [ 1 , 3 , 4 , 5 , 2 , 2 , 3 , 5 , 4 , 1 ] call inp % add_molecule ( mol_block ( 0 , 1 , 5 , 4 , 5 , 4 ), s ) call inp % add_molecule ( mol_block ( 0 , 2 , 5 , 4 , 5 , 4 ), s ) call inp % add_molecule ( mol_block ( 0 , 3 , 5 , 4 , 5 , 4 ), s ) print '(6i4)' , inp % blk % b print * , size ( inp % ms ) end subroutine test0 ! subroutine test1 () integer , parameter :: d = 3 integer , parameter :: s = 1 integer , parameter :: m = 5 , n = 18 , f = 12 , g = 18 type ( mol_block ), parameter :: b = mol_block ( 0 , s , m , n , f , g ) type ( symRMSD_input ) :: inp type ( symRMSD ) :: sr real ( RK ) :: X ( d , m , n ), Y ( d , m , n ) real ( RK ), allocatable :: W (:) integer :: i , j , k ! inp % blk = mol_block_list ( d , 1 , [ b ]) ! do k = - 1 , 1 , 2 do j = - 1 , 1 do i = - 1 , 1 X (:, :, ( i + 1 ) * 6 + ( j + 1 ) * 2 + ( k + 1 ) / 2 + 1 ) = sample ( d , m , [ i , j , k ]) Y (:, :, ( k + 1 ) / 2 * 9 + ( j + 1 ) * 3 + ( i + 1 ) + 1 ) = sample ( d , m , [ i , j , k ]) end do end do end do ! Y = 0.2 * X + 0.8 * Y sr = symRMSD ( inp ) allocate ( w ( sr % nmem )) call sr % run (. true ., X , Y , w ) print * , SQRT ( SUM (( X - Y ) ** 2 ) / ( m * n )), sr % sd ( W ), sr % rmsd ( W ) print * , sr % search_ratio ( W ) ! end subroutine test1 ! function sample ( d , n , com ) result ( res ) integer , intent ( in ) :: d , n , com ( d ) real ( RK ) :: res ( d , n ) integer :: i call RANDOM_NUMBER ( res ) do concurrent ( i = 1 : n ) res (:, i ) = res (:, i ) + 6 * com enddo end function sample ! end program main","tags":"","loc":"sourcefile/test_symrmsd.f90.html"},{"title":"test_tree.f90 – symRMSD","text":"Contents Programs main Source Code test_tree.f90 Source Code program main use mod_params , only : RK , IK , ONE => RONE , ZERO => RZERO use mod_unittest use mod_tree implicit none type ( unittest ) :: u ! call u % init ( 'test tree' ) call test1 () ! call u % finish_and_terminate () ! contains ! subroutine test1 () type ( tree ) :: t real ( RK ), allocatable :: W (:) integer ( IK ) :: i ! t = tree ( 1 , 1 , 4 , [ 1 , 5 , 3 , 2 ]) print * , t % memsize allocate ( W ( t % memsize )) do i = 1 , t % memsize W ( i ) = COS ( i ** 2 * 3 D0 ) end do print '(10f9.3)' , W call t % open_node () call t % set_parent_node ( W ) print * , t % nodes_pointer (), t % parent_pointer (), t % unfinished () call t % open_node () call t % set_parent_node ( W ) print * , t % nodes_pointer (), t % parent_pointer (), t % unfinished () call t % open_node () call t % set_parent_node ( W ) print * , t % nodes_pointer (), t % parent_pointer (), t % unfinished () call t % open_node () call t % set_parent_node ( W ) print * , t % nodes_pointer (), t % parent_pointer (), t % unfinished () W ( t % upperbound ) = W ( t % parent_pointer ()) call t % prune ( W ) print * , t % nodes_pointer (), t % parent_pointer (), t % unfinished () call t % close_node () print * , t % nodes_pointer (), t % parent_pointer (), t % unfinished () call t % prune ( W ) print * , t % nodes_pointer (), t % parent_pointer (), t % unfinished () ! end subroutine test1 ! end program main","tags":"","loc":"sourcefile/test_tree.f90.html"},{"title":"test_d_matrix.f90 – symRMSD","text":"Contents Programs main Source Code test_d_matrix.f90 Source Code program main use mod_params , only : RK , IK , ONE => RONE , ZERO => RZERO use mod_mol_block use mod_mol_symmetry use mod_estimate_rotation_matrix use mod_d_matrix use mod_unittest implicit none type ( unittest ) :: u ! call u % init ( 'test d_matrix' ) call test1 () call test2 () call test3 () ! call u % finish_and_terminate () ! contains ! subroutine test1 () integer , parameter :: d = 3 integer , parameter :: s = 2 integer , parameter :: m = 5 integer , parameter :: n = 7 integer , parameter :: f = 3 integer , parameter :: g = 5 integer , parameter :: mn = m * n integer , parameter :: swp ( m , s - 1 ) = RESHAPE ([ 1 , 2 , 3 , 4 , 5 ], [ m , s - 1 ]) type ( mol_block ), parameter :: b = mol_block ( 1 , s , m , n , f , g ) type ( mol_symmetry ) :: ms type ( d_matrix ) :: a real ( RK ) :: X ( d , mn ), Y ( d , mn ) real ( RK ) :: LT , LF , LB , H , C ( d , d ) real ( RK ), allocatable :: w (:) ! ms = mol_symmetry ( swp ) C = 0 D0 H = 0 D0 a = d_matrix ( 1 , d , 28 , b ) X = sample ( d , mn ) Y = 0.9D0 * MATMUL ( SO3 (), X ) + 0.1D0 * sample ( d , mn ) print * , d_matrix_memsize ( a ) allocate ( w ( d_matrix_memsize ( a ))) call d_matrix_eval ( a , ms , X , Y , W ) call d_matrix_partial_eval ( a , 1 , 1 , 1 , [ 2 , 3 , 4 , 5 ], W , LT , H , C , LF , LB ) print '(4f9.3)' , LF , LB , LF + LB , LT call d_matrix_partial_eval ( a , 2 , 2 , 1 , [ 3 , 4 , 5 ], W , LT , H , C , LF , LB ) print '(4f9.3)' , LF , LB , LF + LB , LT call d_matrix_partial_eval ( a , 3 , 3 , 1 , [ 4 , 5 ], W , LT , H , C , LF , LB ) print '(4f9.3)' , LF , LB , LF + LB , LT call d_matrix_partial_eval ( a , 4 , 4 , 1 , [ 5 ], W , LT , H , C , LF , LB ) print '(4f9.3)' , LF , LB , LF + LB , LT call d_matrix_partial_eval ( a , 5 , 5 , 1 , [ 5 ], W , LT , H , C , LF , LB ) print '(4f9.3)' , LF , LB , LF + LB , LT print * call d_matrix_partial_eval ( a , 1 , 1 , 2 , [ 2 , 3 , 4 , 5 ], W , LT , H , C , LF , LB ) print '(4f9.3)' , LF , LB , LF + LB , LT call d_matrix_partial_eval ( a , 1 , 2 , 1 , [ 1 , 3 , 4 , 5 ], W , LT , H , C , LF , LB ) print '(4f9.3)' , LF , LB , LF + LB , LT call d_matrix_partial_eval ( a , 1 , 2 , 2 , [ 1 , 3 , 4 , 5 ], W , LT , H , C , LF , LB ) print '(4f9.3)' , LF , LB , LF + LB , LT ! end subroutine test1 ! subroutine test2 () integer , parameter :: l = 3 integer , parameter :: d = 3 integer , parameter :: s = 3 integer , parameter :: m = 5 integer , parameter :: n = 7 integer , parameter :: f = 3 integer , parameter :: g = 5 integer , parameter :: mnl = ( 3 * m + 6 ) * n integer , parameter :: swp ( m , s - 1 ) = RESHAPE ([ 2 , 3 , 1 , 4 , 5 , 3 , 1 , 2 , 4 , 5 ], [ m , s - 1 ]) integer :: perm ( 3 * g - 6 ) type ( mol_block_list ) :: blk type ( mol_block ) :: b ( l ) type ( mol_symmetry ) :: ms ( l ) type ( d_matrix_list ) :: a real ( RK ) :: X ( d , mnl ), Y ( d , mnl ) real ( RK ), allocatable :: w (:) real ( RK ) :: C ( d * d ), H , LT , LF , LB integer :: i , j , k ! do concurrent ( i = 1 : l ) ms ( i ) = mol_symmetry ( swp (:, : i - 1 )) end do ! do i = 1 , l b ( i ) = mol_block ( 0 , ms ( i )% n_sym () + 1 , m + i , n , f , g - i ) end do ! k = 0 do j = 1 , l do i = 1 , b ( j )% g k = k + 1 perm ( k ) = i end do end do print '(10I4)' , perm ! blk = mol_block_list ( d , l , b ) a = d_matrix_list ( blk , 1 ) ! X = sample ( d , mnl ) Y = 0.99D0 * MATMUL ( SO3 (), X ) + 0.01D0 * sample ( d , mnl ) print * , a % memsize () print * , d_matrix_memsize ( a % m ) ! allocate ( w ( a % memsize ())) ! call a % eval ( ms , X , Y , W ) print * , W ( 1 ) print '(3f9.3)' , W ( 2 : 10 ) print '(*(f9.3))' , W ( a % o : a % o + l - 1 ) print * ! H = W ( a % h ) C = W ( a % c : a % c + a % dd - 1 ) call a % partial_eval ( 1 , perm , 1 , 1 , W , LT , H , C , LF , LB ) print '(3f9.3)' , H , LT call a % partial_eval ( 2 , perm , 1 , 1 , W , LT , H , C , LF , LB ) print '(3f9.3)' , H , LT call a % partial_eval ( 3 , perm , 1 , 1 , W , LT , H , C , LF , LB ) print '(3f9.3)' , H , LT call a % partial_eval ( 4 , perm , 1 , 1 , W , LT , H , C , LF , LB ) print '(3f9.3)' , H , LT call a % partial_eval ( 5 , perm , 1 , 1 , W , LT , H , C , LF , LB ) print '(3f9.3)' , H , LT call a % partial_eval ( 6 , perm , 1 , 1 , W , LT , H , C , LF , LB ) print '(3f9.3)' , H , LT call a % partial_eval ( 7 , perm , 1 , 1 , W , LT , H , C , LF , LB ) print '(3f9.3)' , H , LT call a % partial_eval ( 8 , perm , 1 , 1 , W , LT , H , C , LF , LB ) print '(3f9.3)' , H , LT call a % partial_eval ( 9 , perm , 1 , 1 , W , LT , H , C , LF , LB ) print '(3f9.3)' , H , LT print * ! H = W ( a % h ) C = W ( a % c : a % c + a % dd - 1 ) call a % partial_eval ( 1 , perm , 4 , 1 , W , LT , H , C , LF , LB ) perm (: 4 ) = [ 4 , 1 , 2 , 3 ] print '(3f9.3)' , H , LT call a % partial_eval ( 2 , perm , 3 , 1 , W , LT , H , C , LF , LB ) perm (: 4 ) = [ 4 , 3 , 1 , 2 ] print '(3f9.3)' , H , LT call a % partial_eval ( 3 , perm , 2 , 1 , W , LT , H , C , LF , LB ) perm (: 4 ) = [ 4 , 3 , 2 , 1 ] print '(3f9.3)' , H , LT call a % partial_eval ( 4 , perm , 1 , 1 , W , LT , H , C , LF , LB ) print '(3f9.3)' , H , LT call a % partial_eval ( 5 , perm , 3 , 1 , W , LT , H , C , LF , LB ) perm ( 5 : 7 ) = [ 3 , 1 , 2 ] print '(3f9.3)' , H , LT call a % partial_eval ( 6 , perm , 2 , 1 , W , LT , H , C , LF , LB ) perm ( 5 : 7 ) = [ 3 , 2 , 1 ] print '(3f9.3)' , H , LT call a % partial_eval ( 7 , perm , 1 , 1 , W , LT , H , C , LF , LB ) print '(3f9.3)' , H , LT call a % partial_eval ( 8 , perm , 2 , 1 , W , LT , H , C , LF , LB ) perm ( 8 : 9 ) = [ 2 , 1 ] print '(3f9.3)' , H , LT call a % partial_eval ( 9 , perm , 1 , 1 , W , LT , H , C , LF , LB ) print '(3f9.3)' , H , LT ! end subroutine test2 ! subroutine test3 () integer , parameter :: d = 3 integer , parameter :: s = 1 integer , parameter :: m = 5 , n = 5 , f = 3 , g = 3 integer , parameter :: mn = m * n type ( mol_block ) :: b = mol_block ( 0 , 2 , m , n , f , g ) type ( d_matrix_list ) :: dm type ( mol_block_list ) :: blk type ( mol_symmetry ) :: ms ( s ) real ( RK ) :: X ( d , mn ), Y ( d , mn ) real ( RK ) :: R1 ( 6 , 2 , 2 , 2 ), R2 ( 6 , 2 , 2 , 2 ) real ( RK ), allocatable :: W (:) integer :: i , j , k ! ms ( 1 ) = mol_symmetry ( RESHAPE ([ 2 , 1 , 3 , 4 , 5 ], [ m , 1 ])) blk = mol_block_list ( d , s , [ b ]) dm = d_matrix_list ( blk , 1 ) allocate ( w ( dm % memsize ())) W (:) = 999 ! X = sample ( d , mn ) Y = sample ( d , mn ) ! call dm % eval ( ms , X , Y , W ) ! do k = 1 , 2 do j = 1 , 2 do i = 1 , 2 R1 ( 1 , i , j , k ) = sd ( d , X , swp ( d , m , n , [ 1 , 2 , 3 ], [ i , j , k ] - 1 , ms ( 1 ), Y )) R1 ( 2 , i , j , k ) = sd ( d , X , swp ( d , m , n , [ 1 , 3 , 2 ], [ i , j , k ] - 1 , ms ( 1 ), Y )) R1 ( 3 , i , j , k ) = sd ( d , X , swp ( d , m , n , [ 2 , 1 , 3 ], [ i , j , k ] - 1 , ms ( 1 ), Y )) R1 ( 4 , i , j , k ) = sd ( d , X , swp ( d , m , n , [ 2 , 3 , 1 ], [ i , j , k ] - 1 , ms ( 1 ), Y )) R1 ( 5 , i , j , k ) = sd ( d , X , swp ( d , m , n , [ 3 , 1 , 2 ], [ i , j , k ] - 1 , ms ( 1 ), Y )) R1 ( 6 , i , j , k ) = sd ( d , X , swp ( d , m , n , [ 3 , 2 , 1 ], [ i , j , k ] - 1 , ms ( 1 ), Y )) R2 ( 1 , i , j , k ) = pe ( dm , d , 3 , [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ], [ 1 , 1 , 1 ], [ i , j , k ] - 1 , W ) R2 ( 2 , i , j , k ) = pe ( dm , d , 3 , [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 3 , 2 ], [ 1 , 2 , 1 ], [ i , j , k ] - 1 , W ) R2 ( 3 , i , j , k ) = pe ( dm , d , 3 , [ 1 , 2 , 3 , 2 , 1 , 3 , 2 , 1 , 3 ], [ 2 , 1 , 1 ], [ i , j , k ] - 1 , W ) R2 ( 4 , i , j , k ) = pe ( dm , d , 3 , [ 1 , 2 , 3 , 2 , 1 , 3 , 2 , 3 , 1 ], [ 2 , 2 , 1 ], [ i , j , k ] - 1 , W ) R2 ( 5 , i , j , k ) = pe ( dm , d , 3 , [ 1 , 2 , 3 , 3 , 1 , 2 , 3 , 1 , 2 ], [ 3 , 1 , 1 ], [ i , j , k ] - 1 , W ) R2 ( 6 , i , j , k ) = pe ( dm , d , 3 , [ 1 , 2 , 3 , 3 , 1 , 2 , 3 , 2 , 1 ], [ 3 , 2 , 1 ], [ i , j , k ] - 1 , W ) end do end do end do call u % assert_almost_equal ([ R1 - R2 ], ZERO , 'R1 - R2' ) ! end subroutine test3 ! function pe ( dm , d , l , iper , jper , isym , W ) result ( res ) type ( d_matrix_list ), intent ( in ) :: dm integer , intent ( in ) :: d , l , iper ( l , l ), jper ( l ), isym ( l ) real ( RK ), intent ( in ) :: W ( * ) real ( RK ) :: C ( d , d ), H , T , LF , LB , res integer :: i H = W ( dm % h ) call copy ( d * d , W ( dm % c ), C ) do i = 1 , l call dm % partial_eval ( i , iper ( 1 , i ), jper ( i ), isym ( i ), W , T , H , C , LF = LF , LB = LB ) end do res = LF !res = T end function pe ! function sample ( d , n ) result ( res ) integer , intent ( in ) :: d , n real ( RK ) :: cnt ( d ) real ( RK ) :: res ( d , n ) integer :: i call RANDOM_NUMBER ( res ) cnt = SUM ( res , 2 ) / n do concurrent ( i = 1 : n ) res (:, i ) = res (:, i ) - cnt enddo end function sample ! function SO3 () result ( res ) real ( RK ) :: a ( 3 ), res ( 3 , 3 ) call RANDOM_NUMBER ( a ) a = a / SQRT ( DOT_PRODUCT ( a , a )) res (:, 1 ) = [ a ( 1 ) * a ( 1 ), a ( 1 ) * a ( 2 ) - a ( 3 ), a ( 1 ) * a ( 3 ) + a ( 2 )] res (:, 2 ) = [ a ( 1 ) * a ( 2 ) + a ( 3 ), a ( 2 ) * a ( 2 ), a ( 2 ) * a ( 3 ) - a ( 1 )] res (:, 3 ) = [ a ( 1 ) * a ( 3 ) - a ( 2 ), a ( 2 ) * a ( 3 ) + a ( 1 ), a ( 3 ) * a ( 3 )] end function SO3 ! pure function swp ( d , m , n , per , sym , ms , X ) result ( res ) integer ( IK ), intent ( in ) :: d , m , n , per (:), sym (:) type ( mol_symmetry ), intent ( in ) :: ms real ( RK ), intent ( in ) :: X ( d , m , n ) real ( RK ) :: tmp ( d , m , n ), res ( d , m * n ) integer ( IK ) :: i tmp = X do i = 1 , SIZE ( per ) tmp (:, :, per ( i )) = X (:, :, i ) call ms % swap ( d , tmp (:, :, per ( i )), sym ( i )) end do res = RESHAPE ( tmp , [ d , m * n ]) end function swp ! pure function sd ( d , X , Y ) result ( res ) integer ( IK ), intent ( in ) :: d real ( RK ), intent ( in ) :: X (:, :), Y (:, :) real ( RK ) :: C ( d , d ), R ( d , d ), W ( 100 ), res C = MATMUL ( Y , TRANSPOSE ( X )) call estimate_rotation_matrix ( d , SUM ( X * X ) + SUM ( Y * Y ), C , R , W ) res = SUM ( X ** 2 ) + SUM ( Y ** 2 ) - 2 * SUM ( C * R ) end function sd ! pure subroutine copy ( d , source , dest ) integer ( IK ), intent ( in ) :: d real ( RK ), intent ( in ) :: source ( * ) real ( RK ), intent ( inout ) :: dest ( * ) integer ( IK ) :: i do concurrent ( i = 1 : d ) dest ( i ) = source ( i ) end do end subroutine copy ! end program main","tags":"","loc":"sourcefile/test_d_matrix.f90.html"},{"title":"test_Hungarian.f90 – symRMSD","text":"Contents Programs main Source Code test_Hungarian.f90 Source Code program main use mod_params , only : RK , IK , ONE => RONE , ZERO => RZERO use mod_Hungarian use mod_unittest implicit none type ( unittest ) :: u integer ( IK ), parameter :: NTEST = 25 integer ( IK ) :: itest ! call u % init ( 'test Hungarian' ) do itest = 1 , NTEST call test1 () enddo do itest = 1 , NTEST call test2 () enddo ! call u % finish_and_terminate () ! contains ! subroutine test1 () integer ( IK ), parameter :: N_TEST = 10 integer ( IK ), parameter :: d = 3 integer ( IK ), parameter :: n = 3 real ( RK ) :: X ( d , n ), Y ( d , n ), C ( n , n ), P ( n , n ) real ( RK ) :: minsp integer :: piv ( n ), i , j ! call random_number ( X ) call random_number ( Y ) C = MATMUL ( TRANSPOSE ( X ), Y ) call Hungarian ( n , C , P , piv ) do concurrent ( i = 1 : n , j = 1 : n ) P ( i , j ) = MERGE ( ONE , ZERO , piv ( i ) == j ) end do minsp = 999 minsp = MIN ( minsp , SP ( n , [ 1_IK , 2_IK , 3_IK ], C )) minsp = MIN ( minsp , SP ( n , [ 1_IK , 3_IK , 2_IK ], C )) minsp = MIN ( minsp , SP ( n , [ 2_IK , 1_IK , 3_IK ], C )) minsp = MIN ( minsp , SP ( n , [ 2_IK , 3_IK , 1_IK ], C )) minsp = MIN ( minsp , SP ( n , [ 3_IK , 1_IK , 2_IK ], C )) minsp = MIN ( minsp , SP ( n , [ 3_IK , 2_IK , 1_IK ], C )) call u % assert_almost_equal ( SUM ( C * P ), Hungarian_value ( n , C ), 'CP = X    ' ) call u % assert_almost_equal ( Hungarian_value ( n , C ), minsp , 'X  = minsp' ) ! end subroutine test1 ! subroutine test2 () integer , parameter :: N_TEST = 10 integer , parameter :: n = 1000 real ( RK ) :: C ( n , n ), P ( n , n ) integer :: i , j , piv ( n ) ! call RANDOM_NUMBER ( C ) call Hungarian ( n , C , P , piv ) do concurrent ( i = 1 : n , j = 1 : n ) P ( i , j ) = MERGE ( ONE , ZERO , piv ( i ) == j ) end do call u % assert_almost_equal ( SUM ( C * P ), Hungarian_value ( n , C ), 'CP = X    ' ) ! end subroutine test2 ! pure function SP ( n , ix , C ) result ( res ) integer , intent ( in ) :: n , ix ( n ) real ( RK ), intent ( in ) :: C ( n , n ) integer :: i real ( RK ) :: res res = 0 D0 do i = 1 , n res = res + C ( i , ix ( i )) end do end function SP ! end program main","tags":"","loc":"sourcefile/test_hungarian.f90.html"},{"title":"test_estimate_rotation_matrix.f90 – symRMSD","text":"Contents Programs main Source Code test_estimate_rotation_matrix.f90 Source Code program main use mod_params , only : RK , IK , ONE => RONE , ZERO => RZERO use mod_estimate_rotation_matrix use mod_unittest implicit none type ( unittest ) :: z real ( RK ) :: E2 ( 2 , 2 ), E3 ( 3 , 3 ), E6 ( 6 , 6 ) ! E2 = eye ( 2 ) E3 = eye ( 3 ) E6 = eye ( 6 ) ! call z % init ( 'test quartanion d=2' ) call test1 ( 2 , 10 , 10 ) call test1 ( 2 , 20 , 10 ) call test1 ( 2 , 100 , 10 ) ! call z % init ( 'test quartanion d=3' ) call test1 ( 3 , 3 , 10 ) call test1 ( 3 , 5 , 10 ) call test1 ( 3 , 10 , 10 ) call test1 ( 3 , 100 , 10 ) ! call z % init ( 'test kabsch d=6' ) call test1 ( 6 , 1 , 2 ) call test1 ( 6 , 2 , 2 ) call test1 ( 6 , 3 , 2 ) call test1 ( 6 , 5 , 4 ) call test1 ( 6 , 100 , 10 ) ! call z % finish_and_terminate () ! contains ! subroutine test1 ( d , n , n_test ) integer , intent ( in ) :: d , n , n_test real ( RK ) :: Y ( d , n ), X ( d , n ), cov ( d , d ), g real ( RK ) :: rot ( d , d ), krot ( d , d ), sd , kd real ( RK ), allocatable :: w (:) integer :: i ! call estimate_rotation_matrix ( - d , g , x , x , x ) call estimate_sdmin ( - d , g , x , x ( 2 , 1 )) allocate ( w ( NINT ( MAX ( x ( 1 , 1 ), x ( 2 , 1 ))))) ! call RANDOM_NUMBER ( X ) ! do i = 1 , N_TEST rot = SO ( d ) Y = MATMUL ( rot , X ) g = SUM ( X * X ) + SUM ( Y * Y ) cov = MATMUL ( X , TRANSPOSE ( Y )) call estimate_rotation_matrix ( d , g , cov , krot , w ) call z % assert_almost_equal ([ X - MATMUL ( krot , Y )], ZERO , 'X = YR   ' ) if ( d <= n ) call z % assert_almost_equal ([ MATMUL ( rot , krot ) - eye ( d )], ZERO , 'S@RT = I ' ) call z % assert_almost_equal ([ MATMUL ( krot , TRANSPOSE ( krot )) - eye ( d )], ZERO , 'R@RT = I ' ) call estimate_sdmin ( d , g , cov , w ) call z % assert_almost_equal ( w ( 1 ), ZERO , 'sdmin=0  ' ) end do ! do i = 1 , N_TEST ! call RANDOM_NUMBER ( Y ) cov = MATMUL ( X , TRANSPOSE ( Y )) g = SUM ( X ** 2 ) + SUM ( Y ** 2 ) call estimate_rotation_matrix ( d , g , cov , krot , w ) call z % assert_greater_equal ( SUM ( cov * krot ), SUM ( cov * SO ( d )), 'CR >= CQ ' ) call estimate_sdmin ( d , g , cov , w ) ! sd = SUM (( X - MATMUL ( krot , Y )) ** 2 ) kd = SUM ( cov * krot ) kd = g - kd - kd ! call z % assert_almost_equal ( w ( 1 ) / sd , ONE , 'sdmin-sd ' , place = 4 ) call z % assert_almost_equal ( w ( 1 ) / kd , ONE , 'sdmin-kd ' , place = 4 ) call z % assert_almost_equal ([ MATMUL ( krot , TRANSPOSE ( krot )) - eye ( d )], ZERO , 'R@RT = I ' ) ! end do ! end subroutine test1 ! recursive function SO ( d ) result ( res ) integer ( IK ), intent ( in ) :: d real ( RK ) :: res ( d , d ) ! if ( d == 2 ) then block real ( RK ) :: a ( 1 ) call RANDOM_NUMBER ( a ) res (:, 1 ) = [ COS ( a ( 1 )), - SIN ( a ( 1 ))] res (:, 2 ) = [ SIN ( a ( 1 )), COS ( a ( 1 ))] end block elseif ( d == 3 ) then block real ( RK ) :: a ( 3 ) call RANDOM_NUMBER ( a ) a = a / SQRT ( DOT_PRODUCT ( a , a )) res (:, 1 ) = [ a ( 1 ) * a ( 1 ), a ( 1 ) * a ( 2 ) - a ( 3 ), a ( 1 ) * a ( 3 ) + a ( 2 )] res (:, 2 ) = [ a ( 1 ) * a ( 2 ) + a ( 3 ), a ( 2 ) * a ( 2 ), a ( 2 ) * a ( 3 ) - a ( 1 )] res (:, 3 ) = [ a ( 1 ) * a ( 3 ) - a ( 2 ), a ( 2 ) * a ( 3 ) + a ( 1 ), a ( 3 ) * a ( 3 )] end block elseif ( d == 6 ) then block real ( RK ) :: tmp ( d , d ) res = ZERO res ( 1 : 2 , 3 : 4 ) = SO ( 2 ) res ( 3 : 4 , 1 : 2 ) = SO ( 2 ) res ( 5 : 6 , 5 : 6 ) = SO ( 2 ) ! tmp = 0 D0 tmp ( 4 : 6 , 1 : 3 ) = SO ( 3 ) tmp ( 1 : 3 , 4 : 6 ) = - SO ( 3 ) ! res = MATMUL ( res , tmp ) end block else res = ZERO end if ! end function SO ! pure function eye ( d ) result ( res ) integer , intent ( in ) :: d real ( RK ) :: res ( d , d ) integer :: i , j do concurrent ( j = 1 : d , i = 1 : d ) res ( i , j ) = MERGE ( 1 D0 , 0 D0 , i == j ) enddo end function eye ! end program main","tags":"","loc":"sourcefile/test_estimate_rotation_matrix.f90.html"},{"title":"test_group_permutation.f90 – symRMSD","text":"Contents Programs main Source Code test_group_permutation.f90 Source Code program main use mod_params , only : RK , IK , ONE => RONE , ZERO => RZERO use mod_group_permutation use mod_unittest implicit none type ( unittest ) :: u ! call u % init ( 'test group_permutation' ) call test1 () ! call u % finish_and_terminate () ! contains ! subroutine test1 () type ( group_permutation ) :: g integer ( IK ), parameter :: n = 13 real ( RK ) :: X ( n ), Y ( 2 , n ) integer :: s ( n ) integer :: i s = [ 2 , 4 , 6 , 1 , 3 , 5 , 9 , 8 , 7 , 11 , 13 , 10 , 12 ] g = group_permutation ( s ) do concurrent ( i = 1 : n ) X ( i ) = i Y (:, i ) = i end do call g % swap ( 1 , X ) call g % swap ( 2 , Y ) call u % assert_almost_equal ( real ( s , RK ), X , 's = X' ) call u % assert_almost_equal ( real ( s , RK ), Y ( 1 , :), 's = Y1' ) call u % assert_almost_equal ( real ( s , RK ), Y ( 2 , :), 's = Y2' ) call u % assert_equal ( g % nfree (), 12 , 'nfree' ) call u % assert_equal ( g % free_indices (), [[( i , i = 1 , 7 )],[( i , i = 9 , 13 )]], 'free_indices' ) ! s = [ 3 , 2 , 1 , 6 , 5 , 4 , 8 , 7 , 9 , 10 , 11 , 13 , 12 ] g = group_permutation ( s ) do concurrent ( i = 1 : n ) X ( i ) = i Y (:, i ) = i end do call g % swap ( 1 , X ) call g % swap ( 2 , Y ) call u % assert_almost_equal ( real ( s , RK ), X , 's = X' ) call u % assert_almost_equal ( real ( s , RK ), Y ( 1 , :), 's = Y1' ) call u % assert_almost_equal ( real ( s , RK ), Y ( 2 , :), 's = Y2' ) call u % assert_equal ( g % nfree (), 8 , 'nfree' ) call u % assert_equal ( g % free_indices (), [ 1 , 3 , 4 , 6 , 7 , 8 , 12 , 13 ], 'free_indices' ) ! end subroutine test1 ! end program main","tags":"","loc":"sourcefile/test_group_permutation.f90.html"},{"title":"test_driver.f90 – symRMSD","text":"Contents Programs main Source Code test_driver.f90 Source Code program main use mod_params , only : RK , IK , ONE => RONE , ZERO => RZERO use driver use mod_unittest implicit none type ( unittest ) :: u integer , parameter :: NTEST = 2 integer :: itest ! call u % init ( 'test python_driver' ) ! do itest = 1 , NTEST call test1 () end do ! call u % finish_and_terminate () ! contains ! subroutine test1 () integer ( IK ), parameter :: d = 3 integer ( IK ), parameter :: s = 1 integer ( IK ), parameter :: threads = 2 integer ( IK ), parameter :: m = 52 , n = 8 , f = 12 , g = 8 real ( RK ) :: X ( d , m , n ), Y ( d , m , n , threads ) real ( RK ) :: res ( threads ), ratio ( threads ) integer ( IK ) :: nsearch ( threads ) integer ( IK ) :: i , j , k , l ! call add_molecule ( m , n , s , [[ 5 , 6 , 7 , 8 , 1 , 2 , 3 , 4 ], [( i , i = 9 , m )]]) call setup () ! do k = - 1 , 1 , 2 do j = - 1 , 1 , 2 do i = - 1 , 1 , 2 X (:, :, ( i + 1 ) * 2 + ( j + 1 ) + ( k + 1 ) / 2 + 1 ) = sample ( d , m , [ i , j , k ]) end do end do end do ! do l = 1 , threads do k = - 1 , 1 , 2 do j = - 1 , 1 , 2 do i = - 1 , 1 , 2 Y (:, :, ( k + 1 ) * 2 + ( i + 1 ) + ( j + 1 ) / 2 + 1 , l ) = sample ( d , m , [ i , j , k ]) end do end do end do Y (:, :, :, l ) = 0.8 * X + 0.2 * Y (:, :, :, l ) end do ! call run ( X , Y , threads , res , ratio , nsearch ) print '(5f9.3)' , res print '(5f9.3)' , ratio call clear () ! end subroutine test1 ! function sample ( d , n , com ) result ( res ) integer , intent ( in ) :: d , n , com ( d ) real ( RK ) :: res ( d , n ) integer :: i call RANDOM_NUMBER ( res ) do concurrent ( i = 1 : n ) res (:, i ) = res (:, i ) + 8 * com enddo end function sample ! end program main","tags":"","loc":"sourcefile/test_driver.f90.html"},{"title":"python_driver.f90 – symRMSD","text":"Contents Modules driver Source Code python_driver.f90 Source Code module driver !$ use omp_lib use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO use mod_symRMSD use mod_mol_block use mod_mol_symmetry implicit none private public swap_y public add_molecule public setup public run public clear ! integer ( kind = ik ), save :: dmn = 0 integer ( kind = ik ), save :: nmem = 0 integer ( kind = ik ), save :: njob = 0 logical , save :: swap_y = . TRUE . type ( symRMSD_input ), save :: inp type ( symRMSD ), allocatable :: sym (:) ! contains ! subroutine add_molecule ( m , n , s , sym ) integer ( kind = ik ), intent ( in ) :: m integer ( kind = ik ), intent ( in ) :: n integer ( kind = ik ), intent ( in ) :: s integer ( kind = ik ), intent ( in ) :: sym ( * ) type ( mol_block ) :: b_ b_ = mol_block ( 1 , s , m , n , m , n ) call inp % add_molecule ( b_ , sym ) dmn = inp % blk % mn * inp % blk % d end subroutine add_molecule ! subroutine setup () integer ( kind = ik ) :: i if ( ALLOCATED ( sym )) then deallocate ( sym ) end if !$omp parallel njob = MAX ( omp_get_num_threads (), 1 ) !$omp end parallel ALLOCATE ( sym ( njob )) do concurrent ( i = 1 : njob ) sym ( i ) = symRMSD ( inp ) end do nmem = sym ( 1 )% nmem end subroutine setup ! subroutine run ( x , y , n , rmsd , log_ratio , nsearch ) real ( kind = rk ), intent ( in ) :: x ( * ) real ( kind = rk ), intent ( inout ) :: y ( * ) integer ( kind = ik ), intent ( in ) :: n real ( kind = rk ), intent ( out ) :: rmsd ( n ) real ( kind = rk ), intent ( out ) :: log_ratio ( n ) integer ( kind = ik ), intent ( out ) :: nsearch ( n ) real ( kind = rk ) :: w ( nmem , njob ) integer ( kind = ik ) :: i ! !$omp parallel do do i = 1 , n block integer ( kind = ik ) :: ijob , pnt real ( kind = rk ) :: rat ( 3 ) ! pnt = ( i - 1 ) * dmn + 1 ijob = omp_get_thread_num () + 1 call sym ( ijob )% run ( swap_y , x , y ( pnt ), w ( 1 , ijob )) ! rmsd ( i ) = sym ( ijob )% rmsd ( w ( 1 , ijob )) rat = sym ( ijob )% search_ratio ( w ( 1 , ijob )) log_ratio ( i ) = rat ( 1 ) nsearch ( i ) = NINT ( rat ( 3 )) ! end block end do !$omp end parallel do end subroutine run ! subroutine clear () call inp % clear () if ( ALLOCATED ( sym )) then call sym % clear () deallocate ( sym ) end if nmem = 0 njob = 0 dmn = 0 end subroutine clear ! end module driver","tags":"","loc":"sourcefile/python_driver.f90.html"}]}