var tipuesearch = {"pages":[{"title":" symRMSD ","text":"symRMSD molecular symmetry corrected RMSD by branch and plune @warning\nWork in progress\n@endwarning Algorithm now loading @note\nnote\n@endnote @todo\ntodo\n@endtodo @bug\nbug report\n@endbug Developer Info yymmt742","tags":"home","loc":"index.html"},{"title":"cov – symRMSD","text":"pure subroutine cov(d, n, x, y, res) Uses iso_fortran_env Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: x (d,n) real(kind=RK), intent(in) :: y (d,n) real(kind=RK), intent(inout) :: res (d,d)","tags":"","loc":"proc/cov.html"},{"title":"cov – symRMSD","text":"pure subroutine cov(d, n, x, y, res) Uses iso_fortran_env Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: x (d,n) real(kind=RK), intent(in) :: y (d,n) real(kind=RK), intent(inout) :: res (d,d)","tags":"","loc":"proc/cov~2.html"},{"title":"cov – symRMSD","text":"pure subroutine cov(d, n, x, y, res) Uses iso_fortran_env Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: x (d,n) real(kind=RK), intent(in) :: y (d,n) real(kind=RK), intent(inout) :: res (d,d)","tags":"","loc":"proc/cov~3.html"},{"title":"cov – symRMSD","text":"public interface cov Module Procedures private pure subroutine cov_full(d, n, x, y, res, reset) Calculate the covariance matrix, X@YT. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. integer(kind=IK), intent(in) :: n matrix row dimension. real(kind=RK), intent(in) :: x (*) d*n array real(kind=RK), intent(in) :: y (*) d*n array real(kind=RK), intent(inout) :: res (*) returns d*d covariance matrix logical, intent(in), optional :: reset reset flag private pure subroutine cov_part(d, nlist, x, y, res, reset) Calculate the covariance matrix, X@YT, with mask. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. integer(kind=IK), intent(in) :: nlist (:) matrix row index list. real(kind=RK), intent(in) :: x (*) d*n array real(kind=RK), intent(in) :: y (*) d*n array real(kind=RK), intent(inout) :: res (*) returns d*d covariance matrix logical, intent(in), optional :: reset reset flag","tags":"","loc":"interface/cov.html"},{"title":"cov_row_major – symRMSD","text":"public interface cov_row_major Module Procedures private pure subroutine cov_row_major_full(d, n, x, y, res, reset) Calculate the covariance matrix, XT@Y. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. integer(kind=IK), intent(in) :: n matrix row dimension. real(kind=RK), intent(in) :: x (*) d*n array real(kind=RK), intent(in) :: y (*) d*n array real(kind=RK), intent(inout) :: res (*) returns n*n covariance matrix logical, intent(in), optional :: reset reset flag private pure subroutine cov_row_major_part(d, nlist, x, y, res, reset) Calculate the covariance matrix, XT@Y, with mask. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. integer(kind=IK), intent(in) :: nlist (:) matrix row index list. real(kind=RK), intent(in) :: x (*) d*n array real(kind=RK), intent(in) :: y (*) d*n array real(kind=RK), intent(inout) :: res (*) returns d*d covariance matrix logical, intent(in), optional :: reset reset flag","tags":"","loc":"interface/cov_row_major.html"},{"title":"svd_worksize – symRMSD","text":"public pure function svd_worksize(d) result(res) Calculates the optimal size of the WORK array Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension Return Value integer(kind=IK)","tags":"","loc":"proc/svd_worksize.html"},{"title":"svd – symRMSD","text":"public pure subroutine svd(d, x, s, u, vt, w) singular value decomposition of square matrix x. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) d*d square matrix, on exit, x is destroyed. real(kind=RK), intent(inout) :: s (*) d vector, returns singular value. real(kind=RK), intent(inout) :: u (*) d*d square matrix, returns left eigen vector. real(kind=RK), intent(inout) :: vt (*) d*d square matrix, returns transpose right eigen vector. real(kind=RK), intent(inout) :: w (*) work array, must be greater than svd_worksize(d).","tags":"","loc":"proc/svd.html"},{"title":"SO2 – symRMSD","text":"function SO2() result(res) Arguments None Return Value real(kind=RK), (2,2)","tags":"","loc":"proc/so2.html"},{"title":"SO3 – symRMSD","text":"function SO3() result(res) Arguments None Return Value real(kind=RK), (3,3)","tags":"","loc":"proc/so3.html"},{"title":"SO6 – symRMSD","text":"function SO6() result(res) Arguments None Return Value real(kind=RK), (6,6)","tags":"","loc":"proc/so6.html"},{"title":"eye – symRMSD","text":"pure function eye(d) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d Return Value real(kind=RK), (d,d)","tags":"","loc":"proc/eye.html"},{"title":"test1 – symRMSD","text":"subroutine test1(n, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: n_test","tags":"","loc":"proc/test1.html"},{"title":"test2 – symRMSD","text":"subroutine test2(n, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: n_test","tags":"","loc":"proc/test2.html"},{"title":"test3 – symRMSD","text":"subroutine test3(d, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n_test","tags":"","loc":"proc/test3.html"},{"title":"test4 – symRMSD","text":"subroutine test4(d, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n_test","tags":"","loc":"proc/test4.html"},{"title":"wallclock_time – symRMSD","text":"subroutine wallclock_time(N, D, M, DX, DY, RET, time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: D integer, intent(in) :: M real(kind=REAL64), intent(in) :: DX (N,D,M) real(kind=REAL64), intent(in) :: DY (N,D,M) real(kind=REAL64), intent(inout) :: RET real(kind=REAL64), intent(inout) :: time","tags":"","loc":"proc/wallclock_time.html"},{"title":"cov – symRMSD","text":"interface pure subroutine cov(d, n, x, y, res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n real(kind=REAL64), intent(in) :: x (d,n) real(kind=REAL64), intent(in) :: y (d,n) real(kind=REAL64), intent(inout) :: res (d,d)","tags":"","loc":"interface/cov~2.html"},{"title":"test1 – symRMSD","text":"subroutine test1() Arguments None","tags":"","loc":"proc/test1~2.html"},{"title":"det – symRMSD","text":"public interface det Module Procedures private pure subroutine det_full(d, x) calculate determinant of square matrix x. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) square matrix, on exit, x(1) is assigned the determinant of x,\nand the other elements are undefined. private pure subroutine det_part(d, x, ld) calculate determinant of square matrix x, with leading dimension.\n& Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) square matrix, on exit, x(1) is assigned the determinant of x,\nand the other elements are undefined. integer(kind=IK), intent(in) :: ld leading dimension","tags":"","loc":"interface/det.html"},{"title":"det_sign – symRMSD","text":"public interface det_sign Module Procedures private pure subroutine det_sign_copy(d, x, w) calculate determinant sign of square matrix x, with leading dimension. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(in) :: x (*) d * d square matrix. real(kind=RK), intent(inout) :: w (*) work array, on exit, w(1) is assigned the determinant sign of x. private pure subroutine det_sign_full(d, x) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) square matrix, on exit, x(1) is assigned the determinant sign of x, and the other elements are undefined. private pure subroutine det_sign_part(d, x, ld) calculate determinant sign of square matrix x, with leading dimension. & Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) square matrix, on exit, x(1) is assigned the determinant sign of x, and the other elements are undefined. integer(kind=IK), intent(in) :: ld leading dimension","tags":"","loc":"interface/det_sign.html"},{"title":"rot – symRMSD","text":"public pure subroutine rot(d, n, u, x, res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: u (d,d) real(kind=RK), intent(in) :: x (d,n) real(kind=RK), intent(inout) :: res (d,n)","tags":"","loc":"proc/rot.html"},{"title":"SO2 – symRMSD","text":"function SO2() result(res) Arguments None Return Value real(kind=RK), (2,2)","tags":"","loc":"proc/so2~2.html"},{"title":"SO3 – symRMSD","text":"function SO3() result(res) Arguments None Return Value real(kind=RK), (3,3)","tags":"","loc":"proc/so3~2.html"},{"title":"test1 – symRMSD","text":"subroutine test1() Arguments None","tags":"","loc":"proc/test1~3.html"},{"title":"test1 – symRMSD","text":"subroutine test1() Arguments None","tags":"","loc":"proc/test1~4.html"},{"title":"test2 – symRMSD","text":"subroutine test2(d) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d","tags":"","loc":"proc/test2~2.html"},{"title":"test3 – symRMSD","text":"subroutine test3(d, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n","tags":"","loc":"proc/test3~2.html"},{"title":"RI – symRMSD","text":"pure function RI(R) result(res) Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: R (6,6) Return Value real(kind=RK), (12,12)","tags":"","loc":"proc/ri.html"},{"title":"RI2 – symRMSD","text":"pure function RI2(R) result(res) Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: R (6,6) Return Value real(kind=RK), (26,26)","tags":"","loc":"proc/ri2.html"},{"title":"centroid – symRMSD","text":"pure function centroid(d, n, X) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n real(kind=RK), intent(in) :: X (d,n) Return Value real(kind=RK), (d)","tags":"","loc":"proc/centroid.html"},{"title":"SO2 – symRMSD","text":"function SO2() result(res) Arguments None Return Value real(kind=RK), (2,2)","tags":"","loc":"proc/so2~3.html"},{"title":"SO3 – symRMSD","text":"function SO3() result(res) Arguments None Return Value real(kind=RK), (3,3)","tags":"","loc":"proc/so3~3.html"},{"title":"SO6 – symRMSD","text":"function SO6() result(res) Arguments None Return Value real(kind=RK), (6,6)","tags":"","loc":"proc/so6~2.html"},{"title":"SO12 – symRMSD","text":"function SO12() result(res) Arguments None Return Value real(kind=RK), (12,12)","tags":"","loc":"proc/so12.html"},{"title":"SO26 – symRMSD","text":"function SO26() result(res) Arguments None Return Value real(kind=RK), (26,26)","tags":"","loc":"proc/so26.html"},{"title":"eye – symRMSD","text":"pure function eye(d) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d Return Value real(kind=RK), (d,d)","tags":"","loc":"proc/eye~2.html"},{"title":"test1 – symRMSD","text":"subroutine test1() Arguments None","tags":"","loc":"proc/test1~5.html"},{"title":"test2 – symRMSD","text":"subroutine test2() Arguments None","tags":"","loc":"proc/test2~3.html"},{"title":"test3 – symRMSD","text":"subroutine test3() Arguments None","tags":"","loc":"proc/test3~3.html"},{"title":"mol_rot – symRMSD","text":"pure subroutine mol_rot(d, m, n, X, Y, R) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: m integer, intent(in) :: n real(kind=RK), intent(in) :: X (d,m,n) real(kind=RK), intent(inout) :: Y (d,m,n) real(kind=RK), intent(in) :: R (n,n)","tags":"","loc":"proc/mol_rot.html"},{"title":"procrustes_worksize – symRMSD","text":"public pure elemental function procrustes_worksize(d) result(res) Calculate work array size for d*d matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. Return Value integer(kind=IK)","tags":"","loc":"proc/procrustes_worksize.html"},{"title":"procrustes – symRMSD","text":"public  subroutine procrustes(d, cov, rot, w) Calculate the rotation matrix from covariance matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: rot (*) rotation d*d matrix real(kind=RK), intent(inout) :: w (*) work array, must be larger than procrustes_worksize(d)\nif row_major, must be larger than procrustes_worksize(n)","tags":"","loc":"proc/procrustes.html"},{"title":"test1 – symRMSD","text":"subroutine test1() Arguments None","tags":"","loc":"proc/test1~6.html"},{"title":"test2 – symRMSD","text":"subroutine test2() Arguments None","tags":"","loc":"proc/test2~4.html"},{"title":"test3 – symRMSD","text":"subroutine test3() Arguments None","tags":"","loc":"proc/test3~4.html"},{"title":"test4 – symRMSD","text":"subroutine test4() Arguments None","tags":"","loc":"proc/test4~2.html"},{"title":"cov1 – symRMSD","text":"pure subroutine cov1(d, n, x, y, res) Uses iso_fortran_env Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: x (d,n) real(kind=RK), intent(in) :: y (d,n) real(kind=RK), intent(inout) :: res (d,d)","tags":"","loc":"proc/cov1.html"},{"title":"cov2 – symRMSD","text":"pure subroutine cov2(d, n, x, y, res) Uses iso_fortran_env Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: x (d,n) real(kind=RK), intent(in) :: y (d,n) real(kind=RK), intent(inout) :: res (d,d)","tags":"","loc":"proc/cov2.html"},{"title":"cov3 – symRMSD","text":"pure subroutine cov3(d, n, x, y, res) Uses iso_fortran_env Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: x (d,n) real(kind=RK), intent(in) :: y (d,n) real(kind=RK), intent(inout) :: res (d,d)","tags":"","loc":"proc/cov3.html"},{"title":"SO2 – symRMSD","text":"function SO2() result(res) Arguments None Return Value real(kind=RK), (2,2)","tags":"","loc":"proc/so2~4.html"},{"title":"SO3 – symRMSD","text":"function SO3() result(res) Arguments None Return Value real(kind=RK), (3,3)","tags":"","loc":"proc/so3~4.html"},{"title":"SO6 – symRMSD","text":"function SO6() result(res) Arguments None Return Value real(kind=RK), (6,6)","tags":"","loc":"proc/so6~3.html"},{"title":"eye – symRMSD","text":"pure function eye(d) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d Return Value real(kind=RK), (d,d)","tags":"","loc":"proc/eye~3.html"},{"title":"test1 – symRMSD","text":"subroutine test1(n, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: n_test","tags":"","loc":"proc/test1~7.html"},{"title":"test2 – symRMSD","text":"subroutine test2(n, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: n_test","tags":"","loc":"proc/test2~5.html"},{"title":"test3 – symRMSD","text":"subroutine test3(d, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n_test","tags":"","loc":"proc/test3~5.html"},{"title":"test4 – symRMSD","text":"subroutine test4(d, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n_test","tags":"","loc":"proc/test4~3.html"},{"title":"Kabsch_worksize – symRMSD","text":"public pure elemental function Kabsch_worksize(d) result(res) Calculate work array size for d*d matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. Return Value integer(kind=IK)","tags":"","loc":"proc/kabsch_worksize.html"},{"title":"Kabsch – symRMSD","text":"public pure subroutine Kabsch(d, n, cov, rot, w) Calculate the rotation matrix from covariance matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. integer(kind=IK), intent(in) :: n matrix row dimension. real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: rot (*) rotation d*d matrix real(kind=RK), intent(inout) :: w (*) work array, must be larger than Kabsch_worksize(d)\nif row_major, must be larger than Kabsch_worksize(n)","tags":"","loc":"proc/kabsch.html"},{"title":"test1 – symRMSD","text":"subroutine test1() Arguments None","tags":"","loc":"proc/test1~8.html"},{"title":"test2 – symRMSD","text":"subroutine test2() Arguments None","tags":"","loc":"proc/test2~6.html"},{"title":"test3 – symRMSD","text":"subroutine test3() Arguments None","tags":"","loc":"proc/test3~6.html"},{"title":"test4 – symRMSD","text":"subroutine test4() Arguments None","tags":"","loc":"proc/test4~4.html"},{"title":"test5 – symRMSD","text":"subroutine test5() Arguments None","tags":"","loc":"proc/test5.html"},{"title":"rmsd – symRMSD","text":"public pure function rmsd(d, n, x, y) result(res) Calculate the root mean squared displacement. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. integer(kind=IK), intent(in) :: n matrix row dimension. real(kind=RK), intent(in) :: x (*) d*n array real(kind=RK), intent(in) :: y (*) d*n array Return Value real(kind=RK)","tags":"","loc":"proc/rmsd.html"},{"title":"msd – symRMSD","text":"public pure function msd(d, n, x, y) result(res) Calculate the mean squared displacement. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. integer(kind=IK), intent(in) :: n matrix row dimension. real(kind=RK), intent(in) :: x (*) d*n array real(kind=RK), intent(in) :: y (*) d*n array Return Value real(kind=RK)","tags":"","loc":"proc/msd.html"},{"title":"sd – symRMSD","text":"public pure function sd(d, n, x, y) result(res) Calculate the sum of squared displacement. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. integer(kind=IK), intent(in) :: n matrix row dimension. real(kind=RK), intent(in) :: x (*) d*n array real(kind=RK), intent(in) :: y (*) d*n array Return Value real(kind=RK)","tags":"","loc":"proc/sd.html"},{"title":"mod_cov – symRMSD","text":"Calculate the covariance matrix. Uses mod_params Interfaces public        interface cov private pure subroutine cov_full(d, n, x, y, res, reset) Calculate the covariance matrix, X@YT. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. integer(kind=IK), intent(in) :: n matrix row dimension. real(kind=RK), intent(in) :: x (*) d*n array real(kind=RK), intent(in) :: y (*) d*n array real(kind=RK), intent(inout) :: res (*) returns d*d covariance matrix logical, intent(in), optional :: reset reset flag private pure subroutine cov_part(d, nlist, x, y, res, reset) Calculate the covariance matrix, X@YT, with mask. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. integer(kind=IK), intent(in) :: nlist (:) matrix row index list. real(kind=RK), intent(in) :: x (*) d*n array real(kind=RK), intent(in) :: y (*) d*n array real(kind=RK), intent(inout) :: res (*) returns d*d covariance matrix logical, intent(in), optional :: reset reset flag public        interface cov_row_major private pure subroutine cov_row_major_full(d, n, x, y, res, reset) Calculate the covariance matrix, XT@Y. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. integer(kind=IK), intent(in) :: n matrix row dimension. real(kind=RK), intent(in) :: x (*) d*n array real(kind=RK), intent(in) :: y (*) d*n array real(kind=RK), intent(inout) :: res (*) returns n*n covariance matrix logical, intent(in), optional :: reset reset flag private pure subroutine cov_row_major_part(d, nlist, x, y, res, reset) Calculate the covariance matrix, XT@Y, with mask. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. integer(kind=IK), intent(in) :: nlist (:) matrix row index list. real(kind=RK), intent(in) :: x (*) d*n array real(kind=RK), intent(in) :: y (*) d*n array real(kind=RK), intent(inout) :: res (*) returns d*d covariance matrix logical, intent(in), optional :: reset reset flag","tags":"","loc":"module/mod_cov.html"},{"title":"mod_svd – symRMSD","text":"Uses mod_params Functions public pure function svd_worksize (d) result(res) Calculates the optimal size of the WORK array Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension Return Value integer(kind=IK) Subroutines public pure subroutine svd (d, x, s, u, vt, w) singular value decomposition of square matrix x. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) d*d square matrix, on exit, x is destroyed. real(kind=RK), intent(inout) :: s (*) d vector, returns singular value. real(kind=RK), intent(inout) :: u (*) d*d square matrix, returns left eigen vector. real(kind=RK), intent(inout) :: vt (*) d*d square matrix, returns transpose right eigen vector. real(kind=RK), intent(inout) :: w (*) work array, must be greater than svd_worksize(d).","tags":"","loc":"module/mod_svd.html"},{"title":"mod_symRMSD – symRMSD","text":"","tags":"","loc":"module/mod_symrmsd.html"},{"title":"mod_det – symRMSD","text":"Uses mod_params Interfaces public        interface det private pure subroutine det_full(d, x) calculate determinant of square matrix x. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) square matrix, on exit, x(1) is assigned the determinant of x,\nand the other elements are undefined. private pure subroutine det_part(d, x, ld) calculate determinant of square matrix x, with leading dimension.\n& Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) square matrix, on exit, x(1) is assigned the determinant of x,\nand the other elements are undefined. integer(kind=IK), intent(in) :: ld leading dimension public        interface det_sign private pure subroutine det_sign_copy(d, x, w) calculate determinant sign of square matrix x, with leading dimension. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(in) :: x (*) d * d square matrix. real(kind=RK), intent(inout) :: w (*) work array, on exit, w(1) is assigned the determinant sign of x. private pure subroutine det_sign_full(d, x) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) square matrix, on exit, x(1) is assigned the determinant sign of x, and the other elements are undefined. private pure subroutine det_sign_part(d, x, ld) calculate determinant sign of square matrix x, with leading dimension. & Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix dimension real(kind=RK), intent(inout) :: x (*) square matrix, on exit, x(1) is assigned the determinant sign of x, and the other elements are undefined. integer(kind=IK), intent(in) :: ld leading dimension","tags":"","loc":"module/mod_det.html"},{"title":"mod_rot – symRMSD","text":"Uses mod_params Subroutines public pure subroutine rot (d, n, u, x, res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: u (d,d) real(kind=RK), intent(in) :: x (d,n) real(kind=RK), intent(inout) :: res (d,n)","tags":"","loc":"module/mod_rot.html"},{"title":"mod_params – symRMSD","text":"Uses iso_fortran_env Variables Type Visibility Attributes Name Initial integer(kind=IK), public, parameter :: LK = KIND(.true.) real(kind=RK), public, parameter :: RZERO = 0.0_RK real(kind=RK), public, parameter :: RONE = 1.0_RK real(kind=RK), public, parameter :: RHALF = 0.5_RK","tags":"","loc":"module/mod_params.html"},{"title":"mod_procrustes – symRMSD","text":"Calculate the rotation matrix that minimizes |X-RY|&#94;2 using the procrustes-Umeyama algorithm.\n Here, RR&#94;T=I is satisfied. Uses mod_params mod_svd Functions public pure elemental function procrustes_worksize (d) result(res) Calculate work array size for d*d matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. Return Value integer(kind=IK) Subroutines public  subroutine procrustes (d, cov, rot, w) Calculate the rotation matrix from covariance matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: rot (*) rotation d*d matrix real(kind=RK), intent(inout) :: w (*) work array, must be larger than procrustes_worksize(d)\nif row_major, must be larger than procrustes_worksize(n)","tags":"","loc":"module/mod_procrustes.html"},{"title":"mod_Kabsch – symRMSD","text":"Calculate the rotation matrix that minimizes |X-RY|&#94;2 using the Kabsch-Umeyama algorithm.\n Here, RR&#94;T=I and det(R)=1 are satisfied. Uses mod_params mod_det mod_svd Functions public pure elemental function Kabsch_worksize (d) result(res) Calculate work array size for d*d matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. Return Value integer(kind=IK) Subroutines public pure subroutine Kabsch (d, n, cov, rot, w) Calculate the rotation matrix from covariance matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. integer(kind=IK), intent(in) :: n matrix row dimension. real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: rot (*) rotation d*d matrix real(kind=RK), intent(inout) :: w (*) work array, must be larger than Kabsch_worksize(d)\nif row_major, must be larger than Kabsch_worksize(n)","tags":"","loc":"module/mod_kabsch.html"},{"title":"mod_rmsd – symRMSD","text":"Calculate the rmsd. Uses mod_params Functions public pure function rmsd (d, n, x, y) result(res) Calculate the root mean squared displacement. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. integer(kind=IK), intent(in) :: n matrix row dimension. real(kind=RK), intent(in) :: x (*) d*n array real(kind=RK), intent(in) :: y (*) d*n array Return Value real(kind=RK) public pure function msd (d, n, x, y) result(res) Calculate the mean squared displacement. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. integer(kind=IK), intent(in) :: n matrix row dimension. real(kind=RK), intent(in) :: x (*) d*n array real(kind=RK), intent(in) :: y (*) d*n array Return Value real(kind=RK) public pure function sd (d, n, x, y) result(res) Calculate the sum of squared displacement. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d matrix collumn dimension. integer(kind=IK), intent(in) :: n matrix row dimension. real(kind=RK), intent(in) :: x (*) d*n array real(kind=RK), intent(in) :: y (*) d*n array Return Value real(kind=RK)","tags":"","loc":"module/mod_rmsd.html"},{"title":"main – symRMSD","text":"Uses mod_Kabsch mod_params mod_unittest Variables Type Attributes Name Initial type(unittest) :: z real(kind=RK) :: E2 (2,2) real(kind=RK) :: E3 (3,3) real(kind=RK) :: E6 (6,6) Functions function SO2 () result(res) Arguments None Return Value real(kind=RK), (2,2) function SO3 () result(res) Arguments None Return Value real(kind=RK), (3,3) function SO6 () result(res) Arguments None Return Value real(kind=RK), (6,6) pure function eye (d) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d Return Value real(kind=RK), (d,d) Subroutines subroutine test1 (n, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: n_test subroutine test2 (n, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: n_test subroutine test3 (d, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n_test subroutine test4 (d, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n_test","tags":"","loc":"program/main.html"},{"title":"main – symRMSD","text":"Uses iso_fortran_env Variables Type Attributes Name Initial integer, parameter :: N = 10000000 integer, parameter :: NRUN = 10 integer, parameter :: P = 6 integer, parameter :: NI (P) = [10, 100, 1000, 10000, 100000, 100000] integer, parameter :: MI (P) = [10000, 1000, 100, 10, 1, 1] integer, parameter :: DI (P) = [10, 10, 10, 10, 10, 10] real(kind=REAL64) :: RET real(kind=REAL64) :: T (P) real(kind=REAL64) :: DX (N) real(kind=REAL64) :: DY (N) integer :: J integer :: K Interfaces interface pure subroutine cov(d, n, x, y, res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n real(kind=REAL64), intent(in) :: x (d,n) real(kind=REAL64), intent(in) :: y (d,n) real(kind=REAL64), intent(inout) :: res (d,d) Subroutines subroutine wallclock_time (N, D, M, DX, DY, RET, time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: D integer, intent(in) :: M real(kind=REAL64), intent(in) :: DX (N,D,M) real(kind=REAL64), intent(in) :: DY (N,D,M) real(kind=REAL64), intent(inout) :: RET real(kind=REAL64), intent(inout) :: time","tags":"","loc":"program/main~2.html"},{"title":"main – symRMSD","text":"Uses mod_params mod_unittest mod_rmsd Variables Type Attributes Name Initial type(unittest) :: u Subroutines subroutine test1 () Arguments None","tags":"","loc":"program/main~3.html"},{"title":"main – symRMSD","text":"Uses mod_rot mod_params mod_unittest Variables Type Attributes Name Initial type(unittest) :: u Functions function SO2 () result(res) Arguments None Return Value real(kind=RK), (2,2) function SO3 () result(res) Arguments None Return Value real(kind=RK), (3,3) Subroutines subroutine test1 () Arguments None","tags":"","loc":"program/main~4.html"},{"title":"main – symRMSD","text":"Uses mod_params mod_svd mod_unittest Variables Type Attributes Name Initial type(unittest) :: z Subroutines subroutine test1 () Arguments None subroutine test2 (d) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d subroutine test3 (d, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n","tags":"","loc":"program/main~5.html"},{"title":"main – symRMSD","text":"Uses mod_rmsd mod_params mod_Kabsch mod_procrustes mod_cov mod_unittest Variables Type Attributes Name Initial type(unittest) :: u Functions pure function RI (R) result(res) Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: R (6,6) Return Value real(kind=RK), (12,12) pure function RI2 (R) result(res) Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: R (6,6) Return Value real(kind=RK), (26,26) pure function centroid (d, n, X) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n real(kind=RK), intent(in) :: X (d,n) Return Value real(kind=RK), (d) function SO2 () result(res) Arguments None Return Value real(kind=RK), (2,2) function SO3 () result(res) Arguments None Return Value real(kind=RK), (3,3) function SO6 () result(res) Arguments None Return Value real(kind=RK), (6,6) function SO12 () result(res) Arguments None Return Value real(kind=RK), (12,12) function SO26 () result(res) Arguments None Return Value real(kind=RK), (26,26) pure function eye (d) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d Return Value real(kind=RK), (d,d) Subroutines subroutine test1 () Arguments None subroutine test2 () Arguments None subroutine test3 () Arguments None pure subroutine mol_rot (d, m, n, X, Y, R) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: m integer, intent(in) :: n real(kind=RK), intent(in) :: X (d,m,n) real(kind=RK), intent(inout) :: Y (d,m,n) real(kind=RK), intent(in) :: R (n,n)","tags":"","loc":"program/main~6.html"},{"title":"main – symRMSD","text":"Uses mod_params mod_cov mod_unittest Variables Type Attributes Name Initial type(unittest) :: u Subroutines subroutine test1 () Arguments None subroutine test2 () Arguments None subroutine test3 () Arguments None subroutine test4 () Arguments None pure subroutine cov1 (d, n, x, y, res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: x (d,n) real(kind=RK), intent(in) :: y (d,n) real(kind=RK), intent(inout) :: res (d,d) pure subroutine cov2 (d, n, x, y, res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: x (d,n) real(kind=RK), intent(in) :: y (d,n) real(kind=RK), intent(inout) :: res (d,d) pure subroutine cov3 (d, n, x, y, res) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: x (d,n) real(kind=RK), intent(in) :: y (d,n) real(kind=RK), intent(inout) :: res (d,d)","tags":"","loc":"program/main~7.html"},{"title":"main – symRMSD","text":"Uses mod_params mod_procrustes mod_unittest Variables Type Attributes Name Initial type(unittest) :: z real(kind=RK) :: E2 (2,2) real(kind=RK) :: E3 (3,3) real(kind=RK) :: E6 (6,6) Functions function SO2 () result(res) Arguments None Return Value real(kind=RK), (2,2) function SO3 () result(res) Arguments None Return Value real(kind=RK), (3,3) function SO6 () result(res) Arguments None Return Value real(kind=RK), (6,6) pure function eye (d) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d Return Value real(kind=RK), (d,d) Subroutines subroutine test1 (n, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: n_test subroutine test2 (n, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: n_test subroutine test3 (d, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n_test subroutine test4 (d, n_test) Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: n_test","tags":"","loc":"program/main~8.html"},{"title":"main – symRMSD","text":"Uses mod_params mod_det mod_unittest Variables Type Attributes Name Initial type(unittest) :: u Subroutines subroutine test1 () Arguments None subroutine test2 () Arguments None subroutine test3 () Arguments None subroutine test4 () Arguments None subroutine test5 () Arguments None","tags":"","loc":"program/main~9.html"},{"title":"cov_1.f90 – symRMSD","text":"Source Code pure subroutine cov ( d , n , x , y , res ) use , intrinsic :: ISO_FORTRAN_ENV , only : & & RK => REAL64 , & & IK => INT32 integer ( IK ), intent ( in ) :: d , n real ( RK ), intent ( in ) :: x ( d , n ), y ( d , n ) real ( RK ), intent ( inout ) :: res ( d , d ) ! res = MATMUL ( x , TRANSPOSE ( y )) ! end subroutine cov","tags":"","loc":"sourcefile/cov_1.f90.html"},{"title":"mod_cov.f90 – symRMSD","text":"Source Code !| Calculate the covariance matrix. module mod_cov use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO implicit none private public :: cov , cov_row_major ! interface include 'dgemm.h' end interface ! interface cov module procedure :: cov_full , cov_part end interface cov ! interface cov_row_major module procedure :: cov_row_major_full , cov_row_major_part end interface cov_row_major ! contains ! pure elemental function optarg ( l ) result ( res ) logical , intent ( in ), optional :: l logical :: res if ( PRESENT ( l )) then res = l else res = . false . end if end function optarg ! !| Calculate the covariance matrix, X@YT. pure subroutine cov_full ( d , n , x , y , res , reset ) integer ( IK ), intent ( in ) :: d !! matrix collumn dimension. integer ( IK ), intent ( in ) :: n !! matrix row dimension. real ( RK ), intent ( in ) :: x ( * ) !! d*n array real ( RK ), intent ( in ) :: y ( * ) !! d*n array real ( RK ), intent ( inout ) :: res ( * ) !! returns d*d covariance matrix logical , intent ( in ), optional :: reset !! reset flag ! if ( optarg ( reset )) then call DGEMM ( 'N' , 'T' , d , d , n , ONE , x , d , y , d , ZERO , res , d ) else call DGEMM ( 'N' , 'T' , d , d , n , ONE , x , d , y , d , ONE , res , d ) end if ! !   if (d > n) call add_orthogonal_axis(d, n, res) ! end subroutine cov_full ! !| Calculate the covariance matrix, X@YT, with mask. pure subroutine cov_part ( d , nlist , x , y , res , reset ) integer ( IK ), intent ( in ) :: d !! matrix collumn dimension. integer ( IK ), intent ( in ) :: nlist (:) !! matrix row index list. real ( RK ), intent ( in ) :: x ( * ) !! d*n array real ( RK ), intent ( in ) :: y ( * ) !! d*n array real ( RK ), intent ( inout ) :: res ( * ) !! returns d*d covariance matrix logical , intent ( in ), optional :: reset !! reset flag integer ( IK ) :: i , j , k , p , n ! n = SIZE ( nlist ) if ( optarg ( reset )) res (: d * d ) = ZERO ! do i = 1 , n p = d * ( nlist ( i ) - 1 ) do concurrent ( j = 1 : d , k = 1 : d ) block integer :: q q = ( k - 1 ) * d + j res ( q ) = res ( q ) + x ( p + j ) * y ( p + k ) end block end do end do ! !   if (d > SIZE(nlist)) call add_orthogonal_axis(d, SIZE(nlist), res) ! end subroutine cov_part ! !| Calculate the covariance matrix, XT@Y. pure subroutine cov_row_major_full ( d , n , x , y , res , reset ) integer ( IK ), intent ( in ) :: d !! matrix collumn dimension. integer ( IK ), intent ( in ) :: n !! matrix row dimension. real ( RK ), intent ( in ) :: x ( * ) !! d*n array real ( RK ), intent ( in ) :: y ( * ) !! d*n array real ( RK ), intent ( inout ) :: res ( * ) !! returns n*n covariance matrix logical , intent ( in ), optional :: reset !! reset flag ! if ( optarg ( reset )) then call DGEMM ( 'T' , 'N' , n , n , d , ONE , x , d , y , d , ZERO , res , n ) else call DGEMM ( 'T' , 'N' , n , n , d , ONE , x , d , y , d , ONE , res , n ) end if ! !   if (n > d) call add_orthogonal_axis(n, d, res) ! end subroutine cov_row_major_full ! !| Calculate the covariance matrix, XT@Y, with mask. pure subroutine cov_row_major_part ( d , nlist , x , y , res , reset ) integer ( IK ), intent ( in ) :: d !! matrix collumn dimension. integer ( IK ), intent ( in ) :: nlist (:) !! matrix row index list. real ( RK ), intent ( in ) :: x ( * ) !! d*n array real ( RK ), intent ( in ) :: y ( * ) !! d*n array real ( RK ), intent ( inout ) :: res ( * ) !! returns d*d covariance matrix logical , intent ( in ), optional :: reset !! reset flag integer ( IK ) :: i , j , k , n , dd ! n = SIZE ( nlist ) dd = d * d if ( optarg ( reset )) res (: n * n ) = ZERO ! do concurrent ( j = 1 : n , i = 1 : n ) block integer :: p , q , r p = d * ( nlist ( i ) - 1 ) q = d * ( nlist ( j ) - 1 ) r = i + n * ( j - 1 ) do k = 1 , d res ( r ) = res ( r ) + x ( k + p ) * y ( k + q ) end do end block end do ! !   if (d < n) call add_orthogonal_axis(n, d, res) ! end subroutine cov_row_major_part ! ! pure subroutine add_orthogonal_axis(d, n, res) !   integer(IK), intent(in) :: d, n !   real(RK), intent(inout) :: res(n, n) !   integer(IK)             :: i ! !   do i = d + 1, n !     res(i, i) = res(i, i) + ONE !   end do ! ! end subroutine add_orthogonal_axis ! end module mod_cov","tags":"","loc":"sourcefile/mod_cov.f90.html"},{"title":"mod_svd.f90 – symRMSD","text":"Source Code module mod_svd use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO implicit none private public :: svd_worksize , svd ! interface include 'dgesvd.h' end interface ! contains ! !| Calculates the optimal size of the WORK array pure function svd_worksize ( d ) result ( res ) integer ( IK ), intent ( in ) :: d !! matrix dimension real ( RK ) :: dum ( 1 ) integer ( IK ) :: res , info ! if ( d < 1 ) then res = 0 else call DGESVD ( 'A' , 'A' , d , d , dum , d , dum , dum , d , dum , d , dum , - 1 , info ) res = NINT ( dum ( 1 )) endif ! end function svd_worksize ! !| singular value decomposition of square matrix x. pure subroutine svd ( d , x , s , u , vt , w ) integer ( IK ), intent ( in ) :: d !! matrix dimension real ( RK ), intent ( inout ) :: x ( * ) !! d*d square matrix, on exit, x is destroyed. real ( RK ), intent ( inout ) :: s ( * ) !! d vector, returns singular value. real ( RK ), intent ( inout ) :: u ( * ) !! d*d square matrix, returns left eigen vector. real ( RK ), intent ( inout ) :: vt ( * ) !! d*d square matrix, returns transpose right eigen vector. real ( RK ), intent ( inout ) :: w ( * ) !! work array, must be greater than svd_worksize(d). integer ( IK ) :: lw , info ! lw = svd_worksize ( d ) if ( lw <= 0 . or . d <= 0 ) return call DGESVD ( 'A' , 'A' , d , d , x , d , s , u , d , vt , d , w , lw , info ) ! end subroutine svd ! end module mod_svd","tags":"","loc":"sourcefile/mod_svd.f90.html"},{"title":"test_Kabsch.f90 – symRMSD","text":"Source Code program main use mod_params , only : RK , IK , ONE => RONE , ZERO => RZERO use mod_Kabsch use mod_unittest implicit none type ( unittest ) :: z real ( RK ) :: E2 ( 2 , 2 ), E3 ( 3 , 3 ), E6 ( 6 , 6 ) ! E2 = eye ( 2 ) E3 = eye ( 3 ) E6 = eye ( 6 ) ! call z % init ( 'test Kabsch d=3' ) call test1 ( 1 , 2 ) call test1 ( 2 , 2 ) call test1 ( 3 , 2 ) call test1 ( 5 , 4 ) call test1 ( 100 , 10 ) ! call z % init ( 'test Kabsch d=6' ) call test2 ( 1 , 2 ) call test2 ( 2 , 2 ) call test2 ( 3 , 2 ) call test2 ( 5 , 4 ) call test2 ( 100 , 10 ) ! call z % init ( 'test Kabsch row major n=3' ) call test3 ( 1 , 2 ) call test3 ( 2 , 2 ) call test3 ( 3 , 2 ) call test3 ( 8 , 4 ) call test3 ( 100 , 10 ) ! call z % init ( 'test Kabsch row major n=6' ) call test4 ( 1 , 2 ) call test4 ( 2 , 2 ) call test4 ( 3 , 2 ) call test4 ( 8 , 4 ) call test4 ( 100 , 10 ) ! call z % finish_and_terminate () ! contains ! subroutine test1 ( n , n_test ) integer , intent ( in ) :: n , n_test integer , parameter :: d = 3 real ( RK ) :: Y ( d , n ), X ( d , n ), cov ( d , d ) real ( RK ) :: rot ( d , d ), krot ( d , d ) real ( RK ) :: w ( Kabsch_worksize ( d )) integer :: i ! call random_number ( X ) ! do i = 1 , N_TEST ! rot = SO3 () Y = MATMUL ( rot , X ) cov = MATMUL ( X , TRANSPOSE ( Y )) call Kabsch ( 3 , n , cov , krot , w ) call z % assert_almost_equal ([ X - MATMUL ( krot , Y )], 0 D0 , 'X = RY  ' ) call z % assert_almost_equal ([ MATMUL ( krot , TRANSPOSE ( krot )) - E3 ], 0 D0 , 'R@RT = I' ) ! enddo ! end subroutine test1 ! subroutine test2 ( n , n_test ) integer , intent ( in ) :: n , n_test real ( RK ) :: Y ( 6 , n ), X ( 6 , n ), cov ( 6 , 6 ) real ( RK ) :: rot ( 6 , 6 ), krot ( 6 , 6 ) real ( RK ) :: w ( Kabsch_worksize ( 6 )) integer :: i ! call random_number ( X ) ! do i = 1 , N_TEST ! rot = SO6 () Y = MATMUL ( rot , X ) cov = MATMUL ( X , TRANSPOSE ( Y )) call Kabsch ( 6 , n , cov , krot , w ) call z % assert_almost_equal ([ X - MATMUL ( krot , Y )], 0 D0 , 'X = RY  ' ) call z % assert_almost_equal ([ MATMUL ( krot , TRANSPOSE ( krot )) - E6 ], 0 D0 , 'R@RT = I' ) ! enddo ! end subroutine test2 ! subroutine test3 ( d , n_test ) integer , intent ( in ) :: d , n_test integer , parameter :: n = 3 real ( RK ) :: Y ( d , n ), X ( d , n ), cov ( n , n ) real ( RK ) :: rot ( n , n ), krot ( n , n ) real ( RK ) :: w ( Kabsch_worksize ( n )) integer :: i ! call random_number ( X ) ! do i = 1 , N_TEST ! rot = SO3 () Y = MATMUL ( X , rot ) cov = MATMUL ( TRANSPOSE ( X ), Y ) call Kabsch ( n , d , cov , krot , w ) call z % assert_almost_equal ([ X - MATMUL ( Y , TRANSPOSE ( krot ))], 0 D0 , 'X = YR  ' ) call z % assert_almost_equal ([ MATMUL ( krot , TRANSPOSE ( krot )) - eye ( n )], 0 D0 , 'R@RT = I' ) ! enddo ! end subroutine test3 ! subroutine test4 ( d , n_test ) integer , intent ( in ) :: d , n_test integer , parameter :: n = 6 real ( RK ) :: Y ( d , n ), X ( d , n ), cov ( n , n ) real ( RK ) :: rot ( n , n ), krot ( n , n ) real ( RK ) :: w ( Kabsch_worksize ( n )) integer :: i ! call random_number ( X ) ! do i = 1 , N_TEST ! rot = SO6 () Y = MATMUL ( X , rot ) cov = MATMUL ( TRANSPOSE ( X ), Y ) call Kabsch ( n , d , cov , krot , w ) call z % assert_almost_equal ([ X - MATMUL ( Y , TRANSPOSE ( krot ))], 0 D0 , 'X = YR  ' ) call z % assert_almost_equal ([ MATMUL ( krot , TRANSPOSE ( krot )) - eye ( n )], 0 D0 , 'R@RT = I' ) ! enddo ! end subroutine test4 ! function SO2 () result ( res ) real ( RK ) :: a ( 1 ), res ( 2 , 2 ) call RANDOM_NUMBER ( a ) res (:, 1 ) = [ COS ( a ( 1 )), - SIN ( a ( 1 ))] res (:, 2 ) = [ SIN ( a ( 1 )), COS ( a ( 1 ))] end function SO2 ! function SO3 () result ( res ) real ( RK ) :: a ( 3 ), res ( 3 , 3 ) call RANDOM_NUMBER ( a ) a = a / SQRT ( DOT_PRODUCT ( a , a )) res (:, 1 ) = [ a ( 1 ) * a ( 1 ), a ( 1 ) * a ( 2 ) - a ( 3 ), a ( 1 ) * a ( 3 ) + a ( 2 )] res (:, 2 ) = [ a ( 1 ) * a ( 2 ) + a ( 3 ), a ( 2 ) * a ( 2 ), a ( 2 ) * a ( 3 ) - a ( 1 )] res (:, 3 ) = [ a ( 1 ) * a ( 3 ) - a ( 2 ), a ( 2 ) * a ( 3 ) + a ( 1 ), a ( 3 ) * a ( 3 )] end function SO3 ! function SO6 () result ( res ) real ( RK ) :: res ( 6 , 6 ), tmp ( 6 , 6 ) ! res = 0 D0 res ( 1 : 2 , 3 : 4 ) = SO2 () res ( 3 : 4 , 1 : 2 ) = SO2 () res ( 5 : 6 , 5 : 6 ) = SO2 () ! tmp = 0 D0 tmp ( 4 : 6 , 1 : 3 ) = SO3 () tmp ( 1 : 3 , 4 : 6 ) = - SO3 () ! res = MATMUL ( res , tmp ) ! end function SO6 ! pure function eye ( d ) result ( res ) integer , intent ( in ) :: d real ( RK ) :: res ( d , d ) integer :: i , j do concurrent ( j = 1 : d , i = 1 : d ) res ( i , j ) = MERGE ( 1 D0 , 0 D0 , i == j ) enddo end function eye ! end program main","tags":"","loc":"sourcefile/test_kabsch.f90.html"},{"title":"test_cov_time.f90 – symRMSD","text":"Source Code program main use , intrinsic :: ISO_FORTRAN_ENV implicit none ! integer , parameter :: N = 10000000 integer , parameter :: NRUN = 10 integer , parameter :: P = 6 integer , parameter :: NI ( P ) = [ 10 , 100 , 1000 , 10000 , 100000 , 100000 ] integer , parameter :: MI ( P ) = [ 10000 , 1000 , 100 , 10 , 1 , 1 ] integer , parameter :: DI ( P ) = [ 10 , 10 , 10 , 10 , 10 , 10 ] real ( REAL64 ) :: RET , T ( P ), DX ( N ), DY ( N ) integer :: J , K ! interface pure subroutine cov ( d , n , x , y , res ) use , intrinsic :: ISO_FORTRAN_ENV integer , intent ( in ) :: d , n real ( REAL64 ), intent ( in ) :: x ( d , n ), y ( d , n ) real ( REAL64 ), intent ( inout ) :: res ( d , d ) end subroutine cov end interface ! T = 0.0_REAL64 RET = 0.0_REAL64 ! do J = 1 , NRUN ! call RANDOM_NUMBER ( DX ) call RANDOM_NUMBER ( DY ) ! do K = 1 , P ! call wallclock_time ( NI ( K ), DI ( K ), MI ( K ), DX , DY , RET , T ( K )) ! end do end do ! print '(F24.12,*(F12.6))' , RET , T ! contains ! subroutine wallclock_time ( N , D , M , DX , DY , RET , time ) integer , intent ( in ) :: N , D , M real ( REAL64 ), intent ( in ) :: DX ( N , D , M ), DY ( N , D , M ) real ( REAL64 ), intent ( inout ) :: RET , time real ( REAL64 ) :: DTMP ( D , D ) integer :: t1 , t2 , t_rate , t_max , diff integer :: I ! call SYSTEM_CLOCK ( t1 ) ! RET = 0.0_REAL64 ! do I = 1 , M DTMP = 0.0_REAL64 call cov ( d , n , DX (:,:, I ), DY (:,:, I ), DTMP ) RET = RET + SUM ( DTMP ) end do ! RET = RET / ( M * N ) ! call SYSTEM_CLOCK ( t2 , t_rate , t_max ) if ( t2 < t1 ) then diff = ( t_max - t1 ) + t2 + 1 else diff = t2 - t1 end if ! time = time + diff / real ( t_rate , REAL64 ) ! end subroutine wallclock_time ! end program main","tags":"","loc":"sourcefile/test_cov_time.f90.html"},{"title":"cov_2.f90 – symRMSD","text":"Source Code pure subroutine cov ( d , n , x , y , res ) use , intrinsic :: ISO_FORTRAN_ENV , only : & & RK => REAL64 , & & IK => INT32 integer ( IK ), intent ( in ) :: d , n real ( RK ), intent ( in ) :: x ( d , n ), y ( d , n ) real ( RK ), intent ( inout ) :: res ( d , d ) integer ( IK ) :: i , j , k ! do k = 1 , n do concurrent ( j = 1 : d , i = 1 : d ) res ( i , j ) = res ( i , j ) + x ( i , k ) * y ( j , k ) end do end do ! end subroutine cov","tags":"","loc":"sourcefile/cov_2.f90.html"},{"title":"mod_symRMSD.f90 – symRMSD","text":"Source Code module mod_symRMSD implicit none ! contains ! ! subroutine X() ! type(unittest)               :: u ! logical,parameter            :: T=.TRUE., F=.FALSE. ! call u%init( 'test_unittest' ) ! call u%assert(                T,           'assert               bool    0  ' ) ! call u%finish_and_terminate() ! end subroutine ! end module mod_symRMSD","tags":"","loc":"sourcefile/mod_symrmsd.f90.html"},{"title":"test_rmsd.f90 – symRMSD","text":"Source Code program main use mod_params , only : RK , IK , RZERO use mod_rmsd use mod_unittest implicit none type ( unittest ) :: u ! call test1 () ! call u % finish_and_terminate () ! contains ! subroutine test1 () ! real ( RK ) :: X ( 12 ) real ( RK ) :: Y ( 12 ) ! call u % init ( 'test rmsd' ) ! call random_number ( X ) call random_number ( Y ) print * , rmsd ( 3 , 4 , X , Y ) ! end subroutine test1 ! end program main","tags":"","loc":"sourcefile/test_rmsd.f90.html"},{"title":"cov_3.f90 – symRMSD","text":"Source Code pure subroutine cov ( d , n , x , y , res ) use , intrinsic :: ISO_FORTRAN_ENV , only : & & RK => REAL64 , & & IK => INT32 integer ( IK ), intent ( in ) :: d , n real ( RK ), intent ( in ) :: x ( d , n ), y ( d , n ) real ( RK ), intent ( inout ) :: res ( d , d ) ! interface include 'dgemm.h' end interface ! call DGEMM ( 'N' , 'T' , d , d , n , 1 D0 , x ( 1 :, 1 :), d , y ( 1 :, 1 :), d , 0 D0 , res ( 1 :, 1 :), d ) ! end subroutine cov","tags":"","loc":"sourcefile/cov_3.f90.html"},{"title":"mod_det.f90 – symRMSD","text":"Source Code module mod_det use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO implicit none private public :: det , det_sign ! interface include 'dgetrf.h' end interface ! interface det module procedure :: det_full , det_part end interface det ! interface det_sign module procedure :: det_sign_copy , det_sign_full , det_sign_part end interface det_sign ! contains ! !| calculate determinant of square matrix x. pure subroutine det_full ( d , x ) integer ( IK ), intent ( in ) :: d !! matrix dimension real ( RK ), intent ( inout ) :: x ( * ) !! square matrix, on exit, x(1) is assigned the determinant of x, !! and the other elements are undefined. ! if ( d <= 1 ) then ! return ! elseif ( d == 2 ) then ! x ( 1 ) = x ( 1 ) * x ( 4 ) - x ( 2 ) * x ( 3 ) ! elseif ( d == 3 ) then ! x ( 1 ) = x ( 1 ) * ( x ( 5 ) * x ( 9 ) - x ( 8 ) * x ( 6 )) + & & x ( 4 ) * ( x ( 8 ) * x ( 3 ) - x ( 2 ) * x ( 9 )) + & & x ( 7 ) * ( x ( 2 ) * x ( 6 ) - x ( 5 ) * x ( 3 )) ! else ! call det_part ( d , x , d ) ! end if ! end subroutine det_full ! !| calculate determinant of square matrix x, with leading dimension. pure subroutine det_part ( d , x , ld ) integer ( IK ), intent ( in ) :: d !! matrix dimension real ( RK ), intent ( inout ) :: x ( * ) !! square matrix, on exit, x(1) is assigned the determinant of x, !! and the other elements are undefined. integer ( IK ), intent ( in ) :: ld !! leading dimension ! if ( d <= 1 ) then ! return ! elseif ( d == 2 ) then block integer ( IK ) :: l2 l2 = MAX ( d , ld ) + 1 x ( 1 ) = x ( 1 ) * x ( l2 + 1 ) - x ( 2 ) * x ( l2 ) end block elseif ( d == 3 ) then block integer ( IK ) :: l2 , l3 l2 = MAX ( d , ld ) l3 = l2 + l2 l2 = l2 + 1 l3 = l3 + 1 !&< x ( 1 ) = x ( 1 ) * ( x ( 1 + l2 ) * x ( 2 + l3 ) - x ( 1 + l3 ) * x ( 2 + l2 )) + & & x ( l2 ) * ( x ( 1 + l3 ) * x ( 2 + 1 ) - x ( 1 + 1 ) * x ( 2 + l3 )) + & & x ( l3 ) * ( x ( 1 + 1 ) * x ( 2 + l2 ) - x ( 1 + l2 ) * x ( 2 + 1 )) !>& end block else block integer ( IK ) :: i , j , k , ipiv ( d ) k = MAX ( d , ld ) call DGETRF ( d , d , x , k , ipiv ( 1 : d ), j ) if ( MODULO ( COUNT ([( ipiv ( i ) == i , i = 1 , d )]), 2 ) == 1 ) x ( 1 ) = - x ( 1 ) ipiv ( 1 ) = k + 1 k = k * d do i = 2 , d j = k - ipiv ( 1 ) x ( j ) = x ( j ) * x ( k ) k = j end do end block end if ! end subroutine det_part ! !| calculate determinant sign of square matrix x, with leading dimension. ! pure subroutine det_sign_copy ( d , x , w ) integer ( IK ), intent ( in ) :: d !! matrix dimension real ( RK ), intent ( in ) :: x ( * ) !! d * d square matrix. real ( RK ), intent ( inout ) :: w ( * ) !! work array, on exit, w(1) is assigned the determinant sign of x. w (: d * d ) = x (: d * d ) call det_sign_full ( d , w ) end subroutine det_sign_copy ! pure subroutine det_sign_full ( d , x ) integer ( IK ), intent ( in ) :: d !! matrix dimension real ( RK ), intent ( inout ) :: x ( * ) !! square matrix, on exit, x(1) is assigned the determinant sign of x, <br> !! and the other elements are undefined. ! if ( d < 1 ) then ! return ! elseif ( d == 1 ) then ! x ( 1 ) = SIGN ( ONE , x ( 1 )) ! elseif ( d == 2 ) then ! x ( 1 ) = SIGN ( ONE , x ( 1 ) * x ( 4 ) - x ( 2 ) * x ( 3 )) ! elseif ( d == 3 ) then ! x ( 1 ) = SIGN ( ONE , x ( 1 ) * ( x ( 5 ) * x ( 9 ) - x ( 8 ) * x ( 6 )) + & & x ( 4 ) * ( x ( 8 ) * x ( 3 ) - x ( 2 ) * x ( 9 )) + & & x ( 7 ) * ( x ( 2 ) * x ( 6 ) - x ( 5 ) * x ( 3 )) ) ! else ! call det_sign_part ( d , x , d ) end if ! end subroutine det_sign_full ! !| calculate determinant sign of square matrix x, with leading dimension. ! pure subroutine det_sign_part ( d , x , ld ) integer ( IK ), intent ( in ) :: d !! matrix dimension real ( RK ), intent ( inout ) :: x ( * ) !! square matrix, on exit, x(1) is assigned the determinant sign of x, <br> !! and the other elements are undefined. integer ( IK ), intent ( in ) :: ld !! leading dimension ! if ( d < 1 ) then ! return ! elseif ( d == 1 ) then ! x ( 1 ) = SIGN ( ONE , x ( 1 )) ! elseif ( d == 2 ) then ! block integer ( IK ) :: l2 l2 = MAX ( d , ld ) + 1 x ( 1 ) = SIGN ( ONE , x ( 1 ) * x ( l2 + 1 ) - x ( 2 ) * x ( l2 )) end block ! elseif ( d == 3 ) then ! block integer ( IK ) :: l2 , l3 l2 = MAX ( d , ld ) l3 = l2 + l2 l2 = l2 + 1 l3 = l3 + 1 !&< x ( 1 ) = SIGN ( ONE , x ( 1 ) * ( x ( 1 + l2 ) * x ( 2 + l3 ) - x ( 1 + l3 ) * x ( 2 + l2 )) + & & x ( l2 ) * ( x ( 1 + l3 ) * x ( 2 + 1 ) - x ( 1 + 1 ) * x ( 2 + l3 )) + & & x ( l3 ) * ( x ( 1 + 1 ) * x ( 2 + l2 ) - x ( 1 + l2 ) * x ( 2 + 1 ))) !>& end block ! else ! block integer ( IK ) :: i , j , k , ipiv ( d ) k = MAX ( d , ld ) call DGETRF ( d , d , x , k , ipiv , j ) ipiv ( 1 ) = COUNT ([( ipiv ( i ) == i , i = 1 , d )]) j = 1 k = k + 1 do i = 1 , d if ( x ( j ) <= ZERO ) ipiv ( 1 ) = ipiv ( 1 ) + 1 j = j + k end do if ( MODULO ( ipiv ( 1 ), 2 ) == 0 ) then x ( 1 ) = ONE else x ( 1 ) = - ONE endif end block ! end if ! end subroutine det_sign_part ! end module mod_det","tags":"","loc":"sourcefile/mod_det.f90.html"},{"title":"mod_rot.f90 – symRMSD","text":"Source Code module mod_rot use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO implicit none private public :: rot ! interface include 'dgemm.h' end interface ! contains ! pure subroutine rot ( d , n , u , x , res ) integer ( IK ), intent ( in ) :: d , n real ( RK ), intent ( in ) :: u ( d , d ), x ( d , n ) real ( RK ), intent ( inout ) :: res ( d , n ) ! call DGEMM ( 'N' , 'N' , d , n , d , ONE , u ( 1 :, 1 :), d , x ( 1 :, 1 :), d , ZERO , res ( 1 :, 1 :), d ) ! end subroutine rot ! end module mod_rot","tags":"","loc":"sourcefile/mod_rot.f90.html"},{"title":"test_rot.f90 – symRMSD","text":"Source Code program main use mod_params , only : RK , IK use mod_rot use mod_unittest implicit none type ( unittest ) :: u ! call test1 () ! call u % finish_and_terminate () ! contains ! subroutine test1 () ! real ( RK ), parameter :: X ( 12 ) = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ] real ( RK ) :: Y ( 12 ) real ( RK ) :: U2 ( 2 , 2 ), U3 ( 3 , 3 ) integer :: i ! call u % init ( 'test rot' ) ! do i = 1 , 10 U2 = SO2 () call rot ( 2 , 6 , U2 , X , Y ) call u % assert_almost_equal ( Y , [ MATMUL ( U2 , RESHAPE ( X , [ 2 , 6 ]))], 'rot  2d  ' ) call u % assert_almost_equal ( DOT_PRODUCT ( Y ( 1 : 2 ), Y ( 1 : 2 )), 5 D0 , 'norm 2d 1' ) call u % assert_almost_equal ( DOT_PRODUCT ( Y ( 3 : 4 ), Y ( 3 : 4 )), 25 D0 , 'norm 2d 2' ) call u % assert_almost_equal ( DOT_PRODUCT ( Y ( 5 : 6 ), Y ( 5 : 6 )), 61 D0 , 'norm 2d 3' ) call u % assert_almost_equal ( DOT_PRODUCT ( Y ( 7 : 8 ), Y ( 7 : 8 )), 113 D0 , 'norm 2d 4' ) call u % assert_almost_equal ( DOT_PRODUCT ( Y ( 9 : 10 ), Y ( 9 : 10 )), 181 D0 , 'norm 2d 5' ) call u % assert_almost_equal ( DOT_PRODUCT ( Y ( 11 : 12 ), Y ( 11 : 12 )), 265 D0 , 'norm 2d 6' ) enddo ! do i = 1 , 10 U3 = SO3 () call rot ( 3 , 4 , U3 , X , Y ) call u % assert_almost_equal ( Y , [ MATMUL ( U3 , RESHAPE ( X , [ 3 , 4 ]))], 'rot  3d  ' ) call u % assert_almost_equal ( DOT_PRODUCT ( Y ( 1 : 3 ), Y ( 1 : 3 )), 14 D0 , 'norm 3d 1' ) call u % assert_almost_equal ( DOT_PRODUCT ( Y ( 4 : 6 ), Y ( 4 : 6 )), 77 D0 , 'norm 3d 2' ) call u % assert_almost_equal ( DOT_PRODUCT ( Y ( 7 : 9 ), Y ( 7 : 9 )), 194 D0 , 'norm 3d 3' ) call u % assert_almost_equal ( DOT_PRODUCT ( Y ( 10 : 12 ), Y ( 10 : 12 )), 365 D0 , 'norm 3d 4' ) enddo ! end subroutine test1 ! function SO2 () result ( res ) real ( RK ) :: a ( 1 ), res ( 2 , 2 ) call RANDOM_NUMBER ( a ) res (:, 1 ) = [ COS ( a ( 1 )), - SIN ( a ( 1 ))] res (:, 2 ) = [ SIN ( a ( 1 )), COS ( a ( 1 ))] end function SO2 ! function SO3 () result ( res ) real ( RK ) :: a ( 3 ), res ( 3 , 3 ) call RANDOM_NUMBER ( a ) a = a / SQRT ( DOT_PRODUCT ( a , a )) res (:, 1 ) = [ a ( 1 ) ** 2 , a ( 1 ) * a ( 2 ) - a ( 3 ), a ( 1 ) * a ( 3 ) + a ( 2 )] res (:, 2 ) = [ a ( 1 ) * a ( 2 ) + a ( 3 ), a ( 2 ) * a ( 2 ), a ( 2 ) * a ( 3 ) - a ( 1 )] res (:, 3 ) = [ a ( 1 ) * a ( 3 ) - a ( 2 ), a ( 2 ) * a ( 3 ) + a ( 1 ), a ( 3 ) * a ( 3 ) ] end function SO3 ! end program main","tags":"","loc":"sourcefile/test_rot.f90.html"},{"title":"mod_params.f90 – symRMSD","text":"Source Code module mod_params use , intrinsic :: ISO_FORTRAN_ENV , only : & & STDIN => INPUT_UNIT , & & STDOUT => OUTPUT_UNIT , & & STDERR => ERROR_UNIT , & & RK => REAL64 , & & IK => INT32 implicit none private public :: RK , IK , LK public :: STDIN , STDOUT , STDERR public :: RZERO , RONE , RHALF ! !&< ! integer ( IK ), parameter :: LK = KIND (. true .) ! real ( RK ), parameter :: RZERO = 0.0_RK real ( RK ), parameter :: RONE = 1.0_RK real ( RK ), parameter :: RHALF = 0.5_RK ! !&> ! end module mod_params","tags":"","loc":"sourcefile/mod_params.f90.html"},{"title":"test_svd.f90 – symRMSD","text":"Source Code program main use mod_params , only : RK , IK , ONE => RONE , ZERO => RZERO use mod_svd use mod_unittest implicit none type ( unittest ) :: z ! call z % init ( 'test svd d=3' ) call test1 () ! call z % init ( 'test svd d=100' ) call test2 ( 2 ) call test2 ( 4 ) call test2 ( 5 ) call test2 ( 6 ) call test2 ( 7 ) call test2 ( 8 ) call test2 ( 9 ) call test2 ( 10 ) ! call test2(20) ! call test2(50) ! call test2(100) ! call z % init ( 'test svd covariance matrix' ) call test3 ( 3 , 100 ) call test3 ( 9 , 100 ) call test3 ( 9 , 3 ) ! call z % finish_and_terminate () ! contains ! subroutine test1 () integer , parameter :: N_TEST = 10 real ( RK ) :: Y ( 9 ), X ( 9 ), E ( 3 , 3 ) real ( RK ) :: s ( 3 ), u ( 3 , 3 ), vt ( 3 , 3 ), w ( 100 ) integer :: i ! E (:, 1 ) = [ 1 , 0 , 0 ] E (:, 2 ) = [ 0 , 1 , 0 ] E (:, 3 ) = [ 0 , 0 , 1 ] ! do i = 1 , N_TEST ! call random_number ( X ) Y = X ; call svd ( 3 , Y , s , u , vt , w ) ! Y = [ MATMUL ( u , TRANSPOSE ( u )) - E ] call z % assert_almost_equal ( Y , 0 D0 , 'U@UT=I' ) ! Y = [ MATMUL ( TRANSPOSE ( vt ), vt ) - E ] call z % assert_almost_equal ( Y , 0 D0 , 'V@VT=I' ) ! Y = [ MATMUL ( MATMUL ( u , RESHAPE ([ s ( 1 ), 0 D0 , 0 D0 , 0 D0 , s ( 2 ), 0 D0 , 0 D0 , 0 D0 , s ( 3 )], [ 3 , 3 ])), vt )] - X call z % assert_almost_equal ( Y , 0 D0 , 'U@S@VT=X' ) ! enddo ! end subroutine test1 ! subroutine test2 ( d ) integer , intent ( in ) :: d integer , parameter :: N_TEST = 10 real ( RK ) :: Y ( d * d ), X ( d * d ), E ( d , d ), Q ( d , d ) real ( RK ) :: s ( d ), u ( d , d ), vt ( d , d ) real ( RK ), allocatable :: w (:) integer :: lw , i , j ! lw = svd_worksize ( d ) allocate ( w ( lw )) ! Q = 0 D0 do concurrent ( j = 1 : d , i = 1 : d ) E ( i , j ) = MERGE ( 1 D0 , 0 D0 , i == j ) end do ! do i = 1 , N_TEST ! call RANDOM_NUMBER ( X ) Y = X ; call svd ( d , Y , s , u , vt , w ) ! Y = [ MATMUL ( u , TRANSPOSE ( u )) - E ] call z % assert_almost_equal ( Y , 0 D0 , 'U@UT=I' ) ! Y = [ MATMUL ( TRANSPOSE ( vt ), vt ) - E ] call z % assert_almost_equal ( Y , 0 D0 , 'V@VT=I' ) ! do j = 1 , d Q ( j , j ) = s ( j ) end do Y = [ MATMUL ( MATMUL ( u , Q ), vt )] - X call z % assert_almost_equal ( Y , 0 D0 , 'U@S@VT=X' ) ! end do ! end subroutine test2 ! subroutine test3 ( d , n ) integer , intent ( in ) :: d , n real ( RK ) :: V ( d , n ), W ( d , n ), X ( d , d ), Y ( d , d ), E ( d , d ), Q ( d , d ) real ( RK ) :: s ( d ), u ( d , d ), vt ( d , d ) real ( RK ), allocatable :: wk (:) integer :: lw , i , j ! lw = svd_worksize ( d ) allocate ( wk ( lw )) ! Q = 0 D0 do concurrent ( j = 1 : d , i = 1 : d ) E ( i , j ) = MERGE ( 1 D0 , 0 D0 , i == j ) end do ! call RANDOM_NUMBER ( V ) call RANDOM_NUMBER ( W ) X = MATMUL ( V , TRANSPOSE ( W )) Y = X call svd ( d , Y , s , u , vt , wk ) ! Y = MATMUL ( u , TRANSPOSE ( u )) - E call z % assert_almost_equal ([ Y ], 0 D0 , 'U@UT=I' ) ! Y = MATMUL ( TRANSPOSE ( vt ), vt ) - E call z % assert_almost_equal ([ Y ], 0 D0 , 'V@VT=I' ) ! do j = 1 , d Q ( j , j ) = s ( j ) end do Y = MATMUL ( MATMUL ( u , Q ), vt ) - X call z % assert_almost_equal ([ Y ], 0 D0 , 'U@S@VT=X' ) ! end subroutine test3 ! end program main","tags":"","loc":"sourcefile/test_svd.f90.html"},{"title":"test_optimize.f90 – symRMSD","text":"Source Code program main use mod_params , only : RK , IK , ONE => RONE , ZERO => RZERO use mod_cov use mod_rmsd use mod_Kabsch use mod_procrustes use mod_unittest implicit none type ( unittest ) :: u ! call u % init ( 'test optimimze' ) call test1 () call test1 () call test1 () call test1 () call test1 () call u % init ( 'test partial optimimze' ) call test2 () call test2 () call test2 () call test2 () call test2 () call u % init ( 'test partial molecular optimimze' ) call test3 () call test3 () call test3 () call test3 () call test3 () ! call u % finish_and_terminate () ! contains ! subroutine test1 () integer , parameter :: n_iter = 500 integer , parameter :: d = 3 integer , parameter :: n = 6 real ( RK ) :: X ( d * n ), Y ( d * n ), Z ( d * n ) real ( RK ) :: Xbar ( d ) real ( RK ) :: dcov ( d * d ), ncov ( n * n ) real ( RK ) :: drot ( d * d ), nrot ( n * n ) real ( RK ) :: w ( Kabsch_worksize ( n )) real ( RK ) :: conv , prev integer :: i ! call RANDOM_NUMBER ( X ); Xbar = centroid ( d , n , X ) do i = 1 , n X (( i - 1 ) * d + 1 : i * d ) = X (( i - 1 ) * d + 1 : i * d ) - Xbar end do Y = [ MATMUL ( MATMUL ( SO3 (), RESHAPE ( X , [ d , n ])), SO6 ())] Z = Y ! prev = rmsd ( d , n , X , Y ) ! do i = 1 , n_iter ! call cov ( d , n , X , Z , dcov , reset = . true .) call Kabsch ( 3 , n , dcov , drot , w ) ! Z = [ MATMUL ( RESHAPE ( drot , [ d , d ]), RESHAPE ( Y , [ d , n ]))] call cov_row_major ( d , n , X , Z , ncov , reset = . true .) call procrustes ( n , ncov , nrot , w ) Z = [ MATMUL ( RESHAPE ( Z , [ d , n ]), TRANSPOSE ( RESHAPE ( nrot , [ n , n ])))] conv = rmsd ( d , n , X , Z ) !print*,i, prev, prev-conv if ( ABS ( prev - conv ) < 1 D - 16 ) exit prev = conv Z = [ MATMUL ( RESHAPE ( Y , [ d , n ]), TRANSPOSE ( RESHAPE ( nrot , [ n , n ])))] ! enddo ! Z = [ MATMUL ( MATMUL ( RESHAPE ( drot , [ d , d ]), RESHAPE ( Y , [ d , n ])), TRANSPOSE ( RESHAPE ( nrot , [ n , n ])))] call u % assert_almost_equal ([ X - Z ], 0 D0 , 'R = RY' ) ! end subroutine test1 ! subroutine test2 () integer , parameter :: n_iter = 500 integer , parameter :: d = 3 integer , parameter :: n = 12 integer , parameter :: nlist ( 6 ) = [ 1 , 2 , 3 , 4 , 5 , 6 ] real ( RK ) :: X ( d * n ), Y ( d * n ), Z ( d * n ) real ( RK ) :: Xbar ( d ) real ( RK ) :: dcov ( d * d ), ncov ( 6 * 6 ) real ( RK ) :: drot ( d * d ), nrot ( 6 * 6 ) real ( RK ) :: w ( Kabsch_worksize ( n )) real ( RK ) :: conv , prev integer :: i ! call RANDOM_NUMBER ( X ); Xbar = centroid ( d , n , X ) do i = 1 , n X (( i - 1 ) * d + 1 : i * d ) = X (( i - 1 ) * d + 1 : i * d ) - Xbar end do Y = [ MATMUL ( MATMUL ( SO3 (), RESHAPE ( X , [ d , n ])), SO12 ())] Z = Y ! prev = rmsd ( d , n , X , Y ) ! do i = 1 , n_iter ! call cov ( d , n , X , Z , dcov , reset = . true .) call Kabsch ( 3 , n , dcov , drot , w ) ! Z = [ MATMUL ( RESHAPE ( drot , [ d , d ]), RESHAPE ( Y , [ d , n ]))] call cov_row_major ( d , nlist , X , Z , ncov , reset = . true .) call procrustes ( 6 , ncov , nrot , w ) Z = [ MATMUL ( RESHAPE ( Z , [ d , n ]), RI ( nrot ))] conv = rmsd ( d , n , X , Z ) !print*,i, prev, prev-conv if ( ABS ( prev - conv ) < 1 D - 16 ) exit prev = conv Z = [ MATMUL ( RESHAPE ( Y , [ d , n ]), RI ( nrot ))] ! enddo ! Z = [ MATMUL ( MATMUL ( RESHAPE ( drot , [ d , d ]), RESHAPE ( Y , [ d , n ])), RI ( nrot ))] call u % assert_almost_equal ([ X - Z ], 0 D0 , 'R = RY' ) ! end subroutine test2 ! subroutine test3 () integer , parameter :: d = 3 integer , parameter :: m = 3 integer , parameter :: n = 26 integer , parameter :: p = 6 integer , parameter :: n_iter = 500 integer , parameter :: nlist ( p ) = [ 21 , 22 , 23 , 24 , 25 , 26 ] real ( RK ) :: X ( d * m * n ), Y ( d * m * n ), Z ( d * m * n ) real ( RK ) :: Xbar ( d ) real ( RK ) :: dcov ( d * d ), ncov ( p * p ) real ( RK ) :: drot ( d * d ), nrot ( p * p ) real ( RK ) :: w ( Kabsch_worksize ( n )) real ( RK ) :: conv , prev integer :: i ! call RANDOM_NUMBER ( X ); Xbar = centroid ( d , n , X ) do i = 1 , m * n X (( i - 1 ) * d + 1 : i * d ) = X (( i - 1 ) * d + 1 : i * d ) - Xbar end do call mol_rot ( d , m , n , MATMUL ( SO3 (), RESHAPE ( X , [ d , m * n ])), Y , SO26 ()) Z = Y ! prev = rmsd ( d , m * n , X , Y ) ! do i = 1 , n_iter ! call cov ( d , n , X , Z , dcov , reset = . true .) call Kabsch ( d , m * n , dcov , drot , w ) Z = [ MATMUL ( RESHAPE ( drot , [ d , d ]), RESHAPE ( Y , [ d , m * n ]))] call cov_row_major ( d * m , nlist , X , Z , ncov , reset = . true .) call procrustes ( p , ncov , nrot , w ) call mol_rot ( d , m , n , [ MATMUL ( RESHAPE ( drot , [ d , d ]), RESHAPE ( Y , [ d , m * n ]))], Z , RI2 ( nrot )) conv = rmsd ( d , m * n , X , Z ) !print*,i, prev, prev-conv if ( ABS ( prev - conv ) < 1 D - 16 ) exit prev = conv call mol_rot ( d , m , n , Y , Z , RI2 ( nrot )) ! enddo ! call mol_rot ( d , m , n , MATMUL ( RESHAPE ( drot , [ d , d ]), RESHAPE ( Y , [ d , m * n ])), Z , RI2 ( nrot )) call u % assert_almost_equal ([ X - Z ], 0 D0 , 'R = RY' ) ! end subroutine test3 ! pure subroutine mol_rot ( d , m , n , X , Y , R ) integer , intent ( in ) :: d , m , n real ( RK ), intent ( in ) :: X ( d , m , n ), R ( n , n ) real ( RK ), intent ( inout ) :: Y ( d , m , n ) integer :: i do i = 1 , m Y (:, i , :) = MATMUL ( X (:, i , :), R ) enddo end subroutine mol_rot ! pure function RI ( R ) result ( res ) real ( RK ), intent ( in ) :: R ( 6 , 6 ) real ( RK ) :: res ( 12 , 12 ) res ( 1 : 6 , 1 : 6 ) = TRANSPOSE ( R ) res ( 7 : 12 , 1 : 6 ) = 0 D0 res ( 1 : 6 , 7 : 12 ) = 0 D0 res ( 7 : 12 , 7 : 12 ) = eye ( 6 ) end function RI ! pure function RI2 ( R ) result ( res ) real ( RK ), intent ( in ) :: R ( 6 , 6 ) real ( RK ) :: res ( 26 , 26 ) res = 0 D0 res ( 1 : 20 , 1 : 20 ) = eye ( 20 ) res ( 21 : 26 , 21 : 26 ) = TRANSPOSE ( R ) end function RI2 ! pure function centroid ( d , n , X ) result ( res ) integer , intent ( in ) :: d , n real ( RK ), intent ( in ) :: X ( d , n ) real ( RK ) :: res ( d ) res = SUM ( X , 2 ) / n end function centroid ! function SO2 () result ( res ) real ( RK ) :: a ( 1 ), res ( 2 , 2 ) call RANDOM_NUMBER ( a ) res (:, 1 ) = [ COS ( a ( 1 )), - SIN ( a ( 1 ))] res (:, 2 ) = [ SIN ( a ( 1 )), COS ( a ( 1 ))] end function SO2 ! function SO3 () result ( res ) real ( RK ) :: a ( 3 ), res ( 3 , 3 ) call RANDOM_NUMBER ( a ) a = a / SQRT ( DOT_PRODUCT ( a , a )) res (:, 1 ) = [ a ( 1 ) * a ( 1 ), a ( 1 ) * a ( 2 ) - a ( 3 ), a ( 1 ) * a ( 3 ) + a ( 2 )] res (:, 2 ) = [ a ( 1 ) * a ( 2 ) + a ( 3 ), a ( 2 ) * a ( 2 ), a ( 2 ) * a ( 3 ) - a ( 1 )] res (:, 3 ) = [ a ( 1 ) * a ( 3 ) - a ( 2 ), a ( 2 ) * a ( 3 ) + a ( 1 ), a ( 3 ) * a ( 3 )] end function SO3 ! function SO6 () result ( res ) real ( RK ) :: res ( 6 , 6 ), tmp ( 6 , 6 ) ! res = 0 D0 res ( 1 : 2 , 3 : 4 ) = SO2 () res ( 3 : 4 , 1 : 2 ) = SO2 () res ( 5 : 6 , 5 : 6 ) = SO2 () ! tmp = 0 D0 tmp ( 4 : 6 , 1 : 3 ) = SO3 () tmp ( 1 : 3 , 4 : 6 ) = - SO3 () ! res = MATMUL ( res , tmp ) ! end function SO6 ! function SO12 () result ( res ) real ( RK ) :: res ( 12 , 12 ) ! res = 0 D0 res ( 1 : 6 , 1 : 6 ) = SO6 () res ( 7 : 12 , 7 : 12 ) = eye ( 6 ) ! end function SO12 ! function SO26 () result ( res ) real ( RK ) :: res ( 26 , 26 ) ! res = 0 D0 res ( 1 : 20 , 1 : 20 ) = eye ( 20 ) res ( 21 : 26 , 21 : 26 ) = SO6 () ! end function SO26 ! pure function eye ( d ) result ( res ) integer , intent ( in ) :: d real ( RK ) :: res ( d , d ) integer :: i , j do concurrent ( j = 1 : d , i = 1 : d ) res ( i , j ) = MERGE ( 1 D0 , 0 D0 , i == j ) enddo end function eye ! end program main","tags":"","loc":"sourcefile/test_optimize.f90.html"},{"title":"mod_procrustes.f90 – symRMSD","text":"Source Code !| Calculate the rotation matrix that minimizes |X-RY|&#94;2 using the procrustes-Umeyama algorithm. !  Here, RR&#94;T=I is satisfied. module mod_procrustes use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO use mod_svd implicit none private public :: procrustes_worksize , procrustes ! interface include 'dgemm.h' end interface ! contains ! !| Calculate work array size for d*d matrix. pure elemental function procrustes_worksize ( d ) result ( res ) integer ( IK ), intent ( in ) :: d !! matrix collumn dimension. integer ( IK ) :: res ! if ( d < 1 ) then res = 0 else res = svd_worksize ( d ) + d * d * 3 + d end if ! end function procrustes_worksize ! !| Calculate the rotation matrix from covariance matrix. subroutine procrustes ( d , cov , rot , w ) integer ( IK ), intent ( in ) :: d !! matrix collumn dimension. real ( RK ), intent ( in ) :: cov ( * ) !! target d*n array real ( RK ), intent ( inout ) :: rot ( * ) !! rotation d*d matrix real ( RK ), intent ( inout ) :: w ( * ) !! work array, must be larger than procrustes_worksize(d) !! if row_major, must be larger than procrustes_worksize(n) integer ( IK ) :: dd , m , s , u , vt , iw ! if ( d < 1 ) RETURN ! dd = d * d m = 1 u = m + dd vt = u + dd s = vt + dd iw = s + d ! w (: dd ) = cov (: dd ) ! call svd ( d , w ( m ), w ( s ), w ( u ), w ( vt ), w ( iw )) call DGEMM ( 'N' , 'N' , d , d , d , ONE , w ( u ), d , w ( vt ), d , ZERO , w ( s ), d ) ! rot (: dd ) = w ( s : s + dd - 1 ) ! end subroutine procrustes ! end module mod_procrustes","tags":"","loc":"sourcefile/mod_procrustes.f90.html"},{"title":"test_cov.f90 – symRMSD","text":"Source Code program main use mod_params , only : RK , IK , RZERO use mod_cov use mod_unittest implicit none type ( unittest ) :: u ! call test1 () call test2 () call test3 () call test4 () ! call u % finish_and_terminate () ! contains ! subroutine test1 () ! real ( RK ), parameter :: X ( 12 ) = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ] real ( RK ), parameter :: Y ( 12 ) = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ] real ( RK ) :: C1 ( 1 * 1 ) real ( RK ) :: C2 ( 2 * 2 ) real ( RK ) :: C3 ( 3 * 3 ) ! call u % init ( 'test cov' ) ! C1 = RZERO call cov ( 1 , 12 , X , Y , C1 ) call u % assert_almost_equal ([ C1 ], [ 650 D0 ], 'cov  1d' ) C1 = RZERO call cov1 ( 1 , 12 , X , Y , C1 ) call u % assert_almost_equal ([ C1 ], [ 650 D0 ], 'cov1 1d' ) C1 = RZERO call cov2 ( 1 , 12 , X , Y , C1 ) call u % assert_almost_equal ([ C1 ], [ 650 D0 ], 'cov2 1d' ) C1 = RZERO call cov3 ( 1 , 12 , X , Y , C1 ) call u % assert_almost_equal ([ C1 ], [ 650 D0 ], 'cov3 1d' ) ! C2 = RZERO call cov ( 2 , 6 , X , Y , C2 ) call u % assert_almost_equal ([ C2 ], [ 286 D0 , 322 D0 , & & 322 D0 , 364 D0 ], & & 'cov  2d' ) C2 = RZERO call cov1 ( 2 , 6 , X , Y , C2 ) call u % assert_almost_equal ([ C2 ], [ 286 D0 , 322 D0 , & & 322 D0 , 364 D0 ], & & 'cov1 2d' ) C2 = RZERO call cov2 ( 2 , 6 , X , Y , C2 ) call u % assert_almost_equal ([ C2 ], [ 286 D0 , 322 D0 , & & 322 D0 , 364 D0 ], & & 'cov2 2d' ) C2 = RZERO call cov3 ( 2 , 6 , X , Y , C2 ) call u % assert_almost_equal ([ C2 ], [ 286 D0 , 322 D0 , & & 322 D0 , 364 D0 ], & & 'cov3 2d' ) ! C3 = RZERO call cov ( 3 , 4 , X , Y , C3 ) call u % assert_almost_equal ([ C3 ], [ 166 D0 , 188 D0 , 210 D0 ,& & 188 D0 , 214 D0 , 240 D0 ,& & 210 D0 , 240 D0 , 270 D0 ],& & 'cov  3d' ) C3 = RZERO call cov1 ( 3 , 4 , X , Y , C3 ) call u % assert_almost_equal ([ C3 ], [ 166 D0 , 188 D0 , 210 D0 ,& & 188 D0 , 214 D0 , 240 D0 ,& & 210 D0 , 240 D0 , 270 D0 ],& & 'cov1 3d' ) C3 = RZERO call cov2 ( 3 , 4 , X , Y , C3 ) call u % assert_almost_equal ([ C3 ], [ 166 D0 , 188 D0 , 210 D0 ,& & 188 D0 , 214 D0 , 240 D0 ,& & 210 D0 , 240 D0 , 270 D0 ],& & 'cov2 3d' ) C3 = RZERO call cov3 ( 3 , 4 , X , Y , C3 ) call u % assert_almost_equal ([ C3 ], [ 166 D0 , 188 D0 , 210 D0 ,& & 188 D0 , 214 D0 , 240 D0 ,& & 210 D0 , 240 D0 , 270 D0 ],& & 'cov3 3d' ) ! end subroutine test1 ! subroutine test2 () integer , parameter :: n_test = 10 integer , parameter :: d = 50 integer , parameter :: n = 20 real ( RK ) :: X ( d * n ), Y ( d * n ) real ( RK ) :: XYT ( d * d ), XTY ( n * n ) integer :: i ! call u % init ( 'test cov, d=100, n=20' ) ! do i = 1 , n_test call RANDOM_NUMBER ( X ) call RANDOM_NUMBER ( Y ) call cov ( d , n , X , Y , XYT , reset = . true .) call u % assert_almost_equal ([ MATMUL ( RESHAPE ( X , [ d , n ]), TRANSPOSE ( RESHAPE ( Y , [ d , n ])))] - XYT , 0 D0 , 'cov X@YT' ) call cov_row_major ( d , n , X , Y , XTY , reset = . true .) call u % assert_almost_equal ([ MATMUL ( TRANSPOSE ( RESHAPE ( X , [ d , n ])), RESHAPE ( Y , [ d , n ]))] - XTY , 0 D0 , 'cov XT@Y' ) end do ! end subroutine test2 ! subroutine test3 () integer , parameter :: n_test = 10 integer , parameter :: d = 3 integer , parameter :: n = 100 integer , parameter :: ln = 20 integer , parameter :: nlist ( ln ) = [ 1 , 2 , 5 , 7 , 9 , 10 , 14 , 19 , 20 , 22 , 25 , 30 , 42 , 44 , 46 , 50 , 52 , 59 , 60 , 77 ] real ( RK ) :: X ( d , n ), Y ( d , n ) real ( RK ) :: XYT ( d * d ), XTY ( ln * ln ) integer :: i ! call u % init ( 'test cov with mask, d=3, n=100, nlist=20' ) ! do i = 1 , n_test call RANDOM_NUMBER ( X ) call RANDOM_NUMBER ( Y ) call cov ( d , nlist , [ X ], [ Y ], XYT , reset = . true .) call u % assert_almost_equal ([ MATMUL ( X (:, nlist ), TRANSPOSE ( Y (:, nlist )))] - XYT , 0 D0 , 'cov X@YT' ) call cov_row_major ( d , nlist , [ X ], [ Y ], XTY , reset = . true .) call u % assert_almost_equal ([ MATMUL ( TRANSPOSE ( X (:, nlist )), Y (:, nlist ))] - XTY , 0 D0 , 'cov XT@Y' ) end do ! end subroutine test3 ! subroutine test4 () integer , parameter :: n_test = 10 integer , parameter :: d = 3 integer , parameter :: nfold = 5 integer , parameter :: n = 100 integer , parameter :: ln = 20 integer , parameter :: nlist ( ln ) = [ 1 , 2 , 5 , 7 , 9 , 10 , 14 , 19 , 20 , 22 , 25 , 30 , 42 , 44 , 46 , 50 , 52 , 59 , 60 , 77 ] real ( RK ) :: X ( d , nfold , n ), Y ( d , nfold , n ) real ( RK ) :: XTY ( ln * ln ) real ( RK ) :: TMP ( ln , ln ) integer :: i , j ! call u % init ( 'test cov with mask and dfold, d=3, nfold=5, n=100, nlist=20' ) ! do i = 1 , n_test call RANDOM_NUMBER ( X ) call RANDOM_NUMBER ( Y ) ! call cov_row_major ( d * nfold , nlist , [ X ], [ Y ], XTY , reset = . true .) TMP = 0 D0 do j = 1 , nfold TMP = TMP + MATMUL ( TRANSPOSE ( X (:, j , nlist )), Y (:, j , nlist )) enddo call u % assert_almost_equal ([ TMP ] - XTY , 0 D0 , 'cov XT@Y' ) ! end do ! end subroutine test4 ! pure subroutine cov1 ( d , n , x , y , res ) use , intrinsic :: ISO_FORTRAN_ENV , only : & & RK => REAL64 , & & IK => INT32 integer ( IK ), intent ( in ) :: d , n real ( RK ), intent ( in ) :: x ( d , n ), y ( d , n ) real ( RK ), intent ( inout ) :: res ( d , d ) ! res = MATMUL ( x , TRANSPOSE ( y )) ! end subroutine cov1 ! pure subroutine cov2 ( d , n , x , y , res ) use , intrinsic :: ISO_FORTRAN_ENV , only : & & RK => REAL64 , & & IK => INT32 integer ( IK ), intent ( in ) :: d , n real ( RK ), intent ( in ) :: x ( d , n ), y ( d , n ) real ( RK ), intent ( inout ) :: res ( d , d ) integer ( IK ) :: i , j , k ! do k = 1 , n do concurrent ( j = 1 : d , i = 1 : d ) res ( i , j ) = res ( i , j ) + x ( i , k ) * y ( j , k ) end do end do ! end subroutine cov2 ! pure subroutine cov3 ( d , n , x , y , res ) use , intrinsic :: ISO_FORTRAN_ENV , only : & & RK => REAL64 , & & IK => INT32 integer ( IK ), intent ( in ) :: d , n real ( RK ), intent ( in ) :: x ( d , n ), y ( d , n ) real ( RK ), intent ( inout ) :: res ( d , d ) ! interface include 'dgemm.h' end interface ! call DGEMM ( 'N' , 'T' , d , d , n , 1 D0 , x ( 1 :, 1 :), d , y ( 1 :, 1 :), d , 0 D0 , res ( 1 :, 1 :), d ) ! end subroutine cov3 ! end program main","tags":"","loc":"sourcefile/test_cov.f90.html"},{"title":"test_procrustes.f90 – symRMSD","text":"Source Code program main use mod_params , only : RK , IK , ONE => RONE , ZERO => RZERO use mod_procrustes use mod_unittest implicit none type ( unittest ) :: z real ( RK ) :: E2 ( 2 , 2 ), E3 ( 3 , 3 ), E6 ( 6 , 6 ) ! E2 = eye ( 2 ) E3 = eye ( 3 ) E6 = eye ( 6 ) ! call z % init ( 'test Kabsch d=3' ) call test1 ( 1 , 2 ) call test1 ( 2 , 2 ) call test1 ( 3 , 2 ) call test1 ( 5 , 4 ) call test1 ( 100 , 10 ) ! call z % init ( 'test Kabsch d=6' ) call test2 ( 1 , 2 ) call test2 ( 2 , 2 ) call test2 ( 3 , 2 ) call test2 ( 5 , 4 ) call test2 ( 100 , 10 ) ! call z % init ( 'test Kabsch row major n=3' ) call test3 ( 1 , 2 ) call test3 ( 2 , 2 ) call test3 ( 3 , 2 ) call test3 ( 8 , 4 ) call test3 ( 100 , 10 ) ! call z % init ( 'test Kabsch row major n=6' ) call test4 ( 1 , 2 ) call test4 ( 2 , 2 ) call test4 ( 3 , 2 ) call test4 ( 8 , 4 ) call test4 ( 100 , 10 ) ! call z % finish_and_terminate () ! contains ! subroutine test1 ( n , n_test ) integer , intent ( in ) :: n , n_test integer , parameter :: d = 3 real ( RK ) :: Y ( d , n ), X ( d , n ), cov ( d , d ) real ( RK ) :: rot ( d , d ), krot ( d , d ) real ( RK ) :: w ( procrustes_worksize ( d )) integer :: i ! call random_number ( X ) ! do i = 1 , N_TEST ! rot = SO3 () Y = MATMUL ( rot , X ) cov = MATMUL ( X , TRANSPOSE ( Y )) call procrustes ( 3 , cov , krot , w ) call z % assert_almost_equal ([ X - MATMUL ( krot , Y )], 0 D0 , 'X = RY  ' ) call z % assert_almost_equal ([ MATMUL ( krot , TRANSPOSE ( krot )) - E3 ], 0 D0 , 'R@RT = I' ) ! enddo ! end subroutine test1 ! subroutine test2 ( n , n_test ) integer , intent ( in ) :: n , n_test real ( RK ) :: Y ( 6 , n ), X ( 6 , n ), cov ( 6 , 6 ) real ( RK ) :: rot ( 6 , 6 ), krot ( 6 , 6 ) real ( RK ) :: w ( procrustes_worksize ( 6 )) integer :: i ! call random_number ( X ) ! do i = 1 , N_TEST ! rot = SO6 () Y = MATMUL ( rot , X ) cov = MATMUL ( X , TRANSPOSE ( Y )) call procrustes ( 6 , cov , krot , w ) call z % assert_almost_equal ([ X - MATMUL ( krot , Y )], 0 D0 , 'X = RY  ' ) call z % assert_almost_equal ([ MATMUL ( krot , TRANSPOSE ( krot )) - E6 ], 0 D0 , 'R@RT = I' ) ! enddo ! end subroutine test2 ! subroutine test3 ( d , n_test ) integer , intent ( in ) :: d , n_test integer , parameter :: n = 3 real ( RK ) :: Y ( d , n ), X ( d , n ), cov ( n , n ) real ( RK ) :: rot ( n , n ), krot ( n , n ) real ( RK ) :: w ( procrustes_worksize ( n )) integer :: i ! call random_number ( X ) ! do i = 1 , N_TEST ! rot = SO3 () Y = MATMUL ( X , rot ) cov = MATMUL ( TRANSPOSE ( X ), Y ) call procrustes ( n , cov , krot , w ) call z % assert_almost_equal ([ X - MATMUL ( Y , TRANSPOSE ( krot ))], 0 D0 , 'X = YR  ' ) call z % assert_almost_equal ([ MATMUL ( krot , TRANSPOSE ( krot )) - eye ( n )], 0 D0 , 'R@RT = I' ) ! enddo ! end subroutine test3 ! subroutine test4 ( d , n_test ) integer , intent ( in ) :: d , n_test integer , parameter :: n = 6 real ( RK ) :: Y ( d , n ), X ( d , n ), cov ( n , n ) real ( RK ) :: rot ( n , n ), krot ( n , n ) real ( RK ) :: w ( procrustes_worksize ( n )) integer :: i ! call random_number ( X ) ! do i = 1 , N_TEST ! rot = SO6 () Y = MATMUL ( X , rot ) cov = MATMUL ( TRANSPOSE ( X ), Y ) call procrustes ( n , cov , krot , w ) call z % assert_almost_equal ([ X - MATMUL ( Y , TRANSPOSE ( krot ))], 0 D0 , 'X = YR  ' ) call z % assert_almost_equal ([ MATMUL ( krot , TRANSPOSE ( krot )) - eye ( n )], 0 D0 , 'R@RT = I' ) ! enddo ! end subroutine test4 ! function SO2 () result ( res ) real ( RK ) :: a ( 2 ), res ( 2 , 2 ) call RANDOM_NUMBER ( a ) res (:, 1 ) = [ COS ( a ( 1 )), - SIN ( a ( 1 ))] res (:, 2 ) = [ SIN ( a ( 1 )), COS ( a ( 1 ))] if ( a ( 2 ) < 0.5D0 ) res ( 2 , :) = - res ( 2 , :) end function SO2 ! function SO3 () result ( res ) real ( RK ) :: a ( 4 ), res ( 3 , 3 ), P ( 3 , 3 ) call RANDOM_NUMBER ( a ) a (: 3 ) = a (: 3 ) / SQRT ( DOT_PRODUCT ( a (: 3 ), a (: 3 ))) res (:, 1 ) = [ a ( 1 ) * a ( 1 ), a ( 1 ) * a ( 2 ) - a ( 3 ), a ( 1 ) * a ( 3 ) + a ( 2 )] res (:, 2 ) = [ a ( 1 ) * a ( 2 ) + a ( 3 ), a ( 2 ) * a ( 2 ), a ( 2 ) * a ( 3 ) - a ( 1 )] res (:, 3 ) = [ a ( 1 ) * a ( 3 ) - a ( 2 ), a ( 2 ) * a ( 3 ) + a ( 1 ), a ( 3 ) * a ( 3 )] P (:, 1 ) = [ 1 , 0 , 0 ] P (:, 2 ) = [ 0 , 0 , 1 ] P (:, 3 ) = [ 0 , 1 , 0 ] if ( a ( 4 ) < 0.5D0 ) res = MATMUL ( res , P ) end function SO3 ! function SO6 () result ( res ) real ( RK ) :: res ( 6 , 6 ), tmp ( 6 , 6 ) ! res = 0 D0 res ( 1 : 2 , 3 : 4 ) = SO2 () res ( 3 : 4 , 1 : 2 ) = SO2 () res ( 5 : 6 , 5 : 6 ) = SO2 () ! tmp = 0 D0 tmp ( 4 : 6 , 1 : 3 ) = SO3 () tmp ( 1 : 3 , 4 : 6 ) = - SO3 () ! res = MATMUL ( res , tmp ) ! end function SO6 ! pure function eye ( d ) result ( res ) integer , intent ( in ) :: d real ( RK ) :: res ( d , d ) integer :: i , j do concurrent ( j = 1 : d , i = 1 : d ) res ( i , j ) = MERGE ( 1 D0 , 0 D0 , i == j ) enddo end function eye ! end program main","tags":"","loc":"sourcefile/test_procrustes.f90.html"},{"title":"mod_Kabsch.f90 – symRMSD","text":"Source Code !| Calculate the rotation matrix that minimizes |X-RY|&#94;2 using the Kabsch-Umeyama algorithm. !  Here, RR&#94;T=I and det(R)=1 are satisfied. module mod_Kabsch use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO use mod_svd use mod_det implicit none private public :: Kabsch_worksize , Kabsch ! interface include 'dgemm.h' end interface ! contains ! !| Calculate work array size for d*d matrix. pure elemental function Kabsch_worksize ( d ) result ( res ) integer ( IK ), intent ( in ) :: d !! matrix collumn dimension. integer ( IK ) :: res ! if ( d < 1 ) then res = 0 else res = svd_worksize ( d ) + d * d * 3 + d end if ! end function Kabsch_worksize ! !| Calculate the rotation matrix from covariance matrix. pure subroutine Kabsch ( d , n , cov , rot , w ) integer ( IK ), intent ( in ) :: d !! matrix collumn dimension. integer ( IK ), intent ( in ) :: n !! matrix row dimension. real ( RK ), intent ( in ) :: cov ( * ) !! target d*n array real ( RK ), intent ( inout ) :: rot ( * ) !! rotation d*d matrix real ( RK ), intent ( inout ) :: w ( * ) !! work array, must be larger than Kabsch_worksize(d) !! if row_major, must be larger than Kabsch_worksize(n) integer ( IK ) :: dd , m , s , u , vt , iw , l ! if ( d < 1 ) RETURN ! l = MIN ( d , n ) dd = d * d m = 1 u = m + dd vt = u + dd s = vt + dd iw = s + d ! w (: dd ) = cov (: dd ) ! call svd ( d , w ( m ), w ( s ), w ( u ), w ( vt ), w ( iw )) ! call DGEMM ( 'N' , 'N' , d , d , d , ONE , w ( u ), d , w ( vt ), d , ZERO , w ( s ), d ) call det_sign ( d , w ( s : s + dd - 1 )) if ( w ( s ) < ZERO ) w ( u + dd - d : u + dd - 1 ) = - w ( u + dd - d : u + dd - 1 ) call DGEMM ( 'N' , 'N' , d , d , d , ONE , w ( u ), d , w ( vt ), d , ZERO , w ( s ), d ) ! rot (: dd ) = w ( s : s + dd - 1 ) ! end subroutine Kabsch ! end module mod_Kabsch","tags":"","loc":"sourcefile/mod_kabsch.f90.html"},{"title":"test_det.f90 – symRMSD","text":"Source Code program main use mod_params , only : RK , IK , ONE => RONE , ZERO => RZERO use mod_det use mod_unittest implicit none type ( unittest ) :: u ! call test1 () call test2 () call test3 () call test4 () call test5 () ! call u % finish_and_terminate () ! contains ! subroutine test1 () integer , parameter :: N_TEST = 10 real ( RK ) :: W ( 1 ), X ( 1 ) integer :: i ! call u % init ( 'test det d=1' ) ! do i = 1 , N_TEST call random_number ( X ) W = X ; call det ( 1 , W ) call u % assert_almost_equal ( W ( 1 ), X ( 1 ), 'det d=1' ) W = X ; call det_sign ( 1 , W ) call u % assert_almost_equal ( W ( 1 ), SIGN ( ONE , X ( 1 )), 'det_sign d=1' ) enddo ! end subroutine test1 ! subroutine test2 () integer , parameter :: N_TEST = 10 real ( RK ) :: W ( 4 ), X ( 4 ) real ( RK ) :: da integer :: i ! call u % init ( 'test det d=2' ) ! do i = 1 , N_TEST call random_number ( X ) da = X ( 1 ) * X ( 4 ) - X ( 2 ) * X ( 3 ) W = X ; call det ( 2 , W ) call u % assert_almost_equal ( W ( 1 ), da , 'det d=2' ) W = X ; call det_sign ( 2 , W ) call u % assert_almost_equal ( W ( 1 ), SIGN ( ONE , da ), 'det_sign d=2' ) enddo ! end subroutine test2 ! subroutine test3 () integer , parameter :: N_TEST = 10 real ( RK ) :: W ( 9 ), X ( 9 ) real ( RK ) :: da integer :: i ! call u % init ( 'test det d=3' ) ! do i = 1 , N_TEST call random_number ( X ) da = X ( 1 ) * X ( 5 ) * X ( 9 ) + X ( 2 ) * X ( 6 ) * X ( 7 ) + X ( 3 ) * X ( 4 ) * X ( 8 ) & - X ( 3 ) * X ( 5 ) * X ( 7 ) - X ( 2 ) * X ( 4 ) * X ( 9 ) - X ( 1 ) * X ( 6 ) * X ( 8 ) W = X ; call det ( 3 , W ) call u % assert_almost_equal ( W ( 1 ), da , 'det d=3' ) W = X ; call det_sign ( 3 , W ) call u % assert_almost_equal ( W ( 1 ), SIGN ( ONE , da ), 'det_sign d=3' ) enddo ! end subroutine test3 ! subroutine test4 () integer , parameter :: N_TEST = 20 real ( RK ) :: W ( 16 ), Y ( 16 ), X ( 16 ) integer :: i ! call u % init ( 'test det d=4' ) ! do i = 1 , N_TEST call random_number ( X ) W = X ; call det ( 4 , W ) Y = X ; call det_sign ( 4 , Y ) call u % assert_almost_equal ( Y ( 1 ), SIGN ( ONE , W ( 1 )), 'det_sign d=4' ) enddo ! end subroutine test4 ! subroutine test5 () integer , parameter :: N_TEST = 20 integer , parameter :: d = 100 real ( RK ) :: W ( d * d ), Y ( d * d ), X ( d * d ) integer :: i ! call u % init ( 'test det d=100' ) ! do i = 1 , N_TEST call random_number ( X ) W = X ; call det ( d , W ) Y = X ; call det_sign ( d , Y ) call u % assert_almost_equal ( Y ( 1 ), SIGN ( ONE , W ( 1 )), 'det_sign d=100' ) enddo ! end subroutine test5 ! end program main","tags":"","loc":"sourcefile/test_det.f90.html"},{"title":"mod_rmsd.f90 – symRMSD","text":"Source Code !| Calculate the rmsd. module mod_rmsd use mod_params , only : IK , RK , ZERO => RZERO implicit none private public :: sd , msd , rmsd ! contains ! !| Calculate the root mean squared displacement. pure function rmsd ( d , n , x , y ) result ( res ) integer ( IK ), intent ( in ) :: d !! matrix collumn dimension. integer ( IK ), intent ( in ) :: n !! matrix row dimension. real ( RK ), intent ( in ) :: x ( * ) !! d*n array real ( RK ), intent ( in ) :: y ( * ) !! d*n array real ( RK ) :: res ! res = SQRT ( msd ( d , n , x , y )) ! end function rmsd ! !| Calculate the mean squared displacement. pure function msd ( d , n , x , y ) result ( res ) integer ( IK ), intent ( in ) :: d !! matrix collumn dimension. integer ( IK ), intent ( in ) :: n !! matrix row dimension. real ( RK ), intent ( in ) :: x ( * ) !! d*n array real ( RK ), intent ( in ) :: y ( * ) !! d*n array real ( RK ) :: res ! res = sd ( d , n , x , y ) / n ! end function msd ! !| Calculate the sum of squared displacement. pure function sd ( d , n , x , y ) result ( res ) integer ( IK ), intent ( in ) :: d !! matrix collumn dimension. integer ( IK ), intent ( in ) :: n !! matrix row dimension. real ( RK ), intent ( in ) :: x ( * ) !! d*n array real ( RK ), intent ( in ) :: y ( * ) !! d*n array real ( RK ) :: res integer ( IK ) :: i , nd ! nd = d * n res = ZERO do i = 1 , nd res = res + ( x ( i ) - y ( i )) ** 2 enddo ! end function sd ! end module mod_rmsd","tags":"","loc":"sourcefile/mod_rmsd.f90.html"}]}