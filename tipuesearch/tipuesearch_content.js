var tipuesearch = {"pages":[{"title":" mobbrmsd ","text":"mobbrmsd molecular symmetry corrected RMSD by branch and bound project page Bug A bug may exist in the degenerate case of the mod_rotation (3d) routines. Neval curve does not reproduce even if experimented.\nThere seems to be a mistake in the implementation of the algorithm. Todo Add Usage Compatible with compilers other than gnu Add detail documentation Add benchmarks Algorithm 一般化RMSD-fitを枝刈りする 分子座標表現 $m$ 分子からなる同種分子が $N$ 個からなる分子集合体の原子座標を考える。分子座標を で表す。ここで $x_{jI}\\in\\mathbb{R}&#94;d$は $I$ 番目の分子の $j$ 番目の原子である。指示ベクトル $e_I$ を で定義する。ここで $\\delta_{IK}$ はクロネッカーのデルタである。指示ベクトルに対して などが成り立つ。分子集合体の原子座標は で表わす。ここで $\\otimes$ はクロネッカー積である。 分子対称性補正最小化RMSD 分子集合体座標の組 $X,Y\\in\\mathbb{R}&#94;{d\\times mN}$ に対して、分子対称性補正RMSDを以下で定義する。 ここで$R\\in\\mathbb R&#94;{d\\times d}$は $d$ 次元回転行列、すなわち を満たす。\nここで $E_n$ は $n$ 次元単位行列を表す。 $\\nu,\\mu$ はそれぞれ同一のインデックス集合を始域と終域とする単射 $\\nu:{1,2,\\dots,N}\\mapsto{1,2,\\dots,N}$ , $\\mu:{1,2,\\dots,m}\\mapsto{1,2,\\dots,m}$ である。\n考慮する置換の集合を $\\mathcal{N}\\subset S_N,\\mu\\in\\mathcal{M}\\subset S_m$ と記載する。\nここで $S_n$ は $n$ 次の置換全体の集合である。\nRMSDの最小化は二乗和誤差SDの最小化と等価なので、ここからはSDの最小化を考える。 と変形できるから、問題は右辺第三項の最大化問題となり、 が求まればよいことになる。 分子置換 分子集合体構造 $X\\in\\mathbb{R}&#94;{d\\times mN}$ に対して、その分子間置換行列と分子内置換は置換行列 $P\\in\\mathbb{R}&#94;{N\\times N},Q_I\\in\\mathbb{R}&#94;{m\\times m}$ を用いて で表現できる。さらに、分子内置換 $Q_I$ の候補は $I$ に依存せず、列挙できるとする。 写像 $\\sigma:{1,2,\\dots,I}\\mapsto{1,2,\\dots,S}$ を用いて と書き直しておく。任意の分子置換操作は置換の積 で表現できる。 一般に $P&#94;{(mN)},Q&#94;{(nN)}$ は非可換で $Q&#94;{(mN)}=E_N\\otimes Q$ のとき、つまり $Q_1=Q_2=\\dots=Q_N$ のときのみ可換になる。 トレースの変形 トレースを変形する。 ここで登場した共分散行列 $C_{sIJ}\\in\\mathbb{R}&#94;{d\\times d}$ は分子内置換 $Q&#94;{(s)}$ が既知なら与えられた構造に対して簡単に評価できる。したがって、まず与えられた構造に対して分散共分散テンソルを計算しておいて、その後 $R,\\sigma,\\nu$ を変分的に最大化すると効率が良い。 変分下限 組み合わせ最適化のため、分枝計画法を用いる。分枝計画法に必要なのは部分集合への分割と部分集合に対する下限（上限）の計算である。そこで、話を再びRMSD値の最小化へと戻し、分割しやすい形へと変形する。評価関数式Xは$N$個の定数と行列トレースの和であり、そのインデックス毎に割当 $\\sigma,\\nu$ を一つずつ重複組合せと順列で選んでいけば、重複なく木構造を作ることができる。 ここで定義した自己相関関数のトレース $S_{IJ}:=\\text{tr}[X_I&#94;TX_I]+\\text{tr}[Y_{J}&#94;TY_{J}]$ も $C_{sIJ}$ と同様に事前に計算しておくことができる。 まず、全体の下限を求める。下限の作り方は任意性があるが、ここでは回転行列をインデックス毎に分割することで確認する。 行列のトレースを最大化する元 $R_I&#94;b,\\sigma&#94;b$ はKabschのアルゴリズム、あるいは四元数を用いたキー行列の最大固有値の推定によって簡単に求まる。また、行列 を定義してハンガリアンアルゴリズムを用いることによって、これを最小化する組み合わせ $\\nu_0&#94;{*}$ は効率的に発見できる。これより が示され、解は必ずこの数値以上であることを保証できる。\nこれを可能な $J,s$ に対して評価することで、親ノードの下限を引き上げることができる。 分枝 $\\Sigma$ を $\\sigma$ 全体の集合、 $\\mathcal{N}$ を $\\nu$ 全体の集合（ $=S_N$ ）として、次の分割を考える。 このとき $\\Sigma=\\Sigma_1\\cup\\Sigma_2\\cup\\dots\\cup\\Sigma_S, \\mathcal{N}=\\mathcal{N}_1\\cup\\mathcal{N}_2\\cup\\dots\\cup\\mathcal{N}_N$ となっており、それぞれの部分集合に重複はない。 \nしたがって、これらの組集合 $(\\sigma_s,\\nu_J)\\in(\\Sigma_s,\\mathcal{N}_J)$ も重複はなく、それらの直積集合の和集合は $\\sigma,\\nu$ 全体と一致する。\nこの分割は $SN$ 個 の部分集合を与える。\n$\\sigma\\in\\Sigma_s,\\nu\\in\\mathcal{N}_J$ に対する評価関数は $\\sigma\\in\\Sigma_s,\\nu\\in\\mathcal{N}_J$ に対して で与えられる。この右辺第二項もKabschアルゴリズムとハンガリアンアルゴリズムによって簡単に計算できるから、容易に評価可能である。また、この値は だから、部分集合の下限は集合全体の下限よりも大きな値を持つことが確認できる。 同様に となる分割を考えて、下限を $\\sigma\\in\\Sigma_{ss'},\\nu\\in\\mathcal{N}_{JJ'}$ に対して と定めれば、必ず親集合よりも大きな値を持つことが確認できる。 限定法 RMSD最小化のメモ $A,B\\in\\mathbb {R}&#94;{d\\times n},\\mathbb{R}\\in\\mathbb{R}&#94;{&#94;{d\\times d}},P\\in{0,1}&#94;{n\\times n}$ とする。$R&#94;TR=I,P&#94;TP=I$である。一般化RMSDは $\\textrm{tr}(RBPA&#94;T)$の最大化問題に帰着される。 コーシーシュワルツの不等式の一般化により がなりたつ。ここで$S=BPA&#94;T$とおいた。 ※これ以上分解すると となり自明な情報しか得られない。 ここで正規直交行列$\\tilde P\\in\\mathbb{R}&#94;{n\\times n}$が$\\tilde P&#94;T\\tilde P=I$を満たすとする。このとき、Kabschのアルゴリズムを用いて、特異値分解 に対して が定まる（はずである、ok）。ここで$X=\\mathrm{Diag}(1,1,\\dots,1,\\det(VU&#94;T))$ である。 $P$は部分空間に分けられるので分枝限定法に利用できるはずである。 とする。このとき... Rを固定してPの変分下界を計算することが必要？ 変分上界 最小化RMSDを見つけるのは難しい。そこでまず $\\mathrm{tr}[X&#94;TRY\\tilde S]$ の変分上界を評価することにする。 $\\mathcal O_n$ を $n$ 次元直交行列全体の集合として、$P\\in\\mathcal O_N,P_I=e&#94;T_Ie_IP,Q_I\\in\\mathcal O_M$ に対して と定義する。このとき、$\\mathcal S_n\\subset\\mathcal O_n$から、 が成り立つ。 $P&#94;{(MN)}=P\\otimes E_M$ は任意の分子置換、$Q&#94;{(MN)}=\\sum_{I=1}&#94;Ne_I&#94;Te_IQ_I$ は任意の分子内回転を表す置換行列を部分集合に含む直交行列である。したがって $P&#94;{(MN)}Q&#94;{(MN)}$は任意の分子対称性を制限された置換行列を部分集合に含む。一般に $P&#94;{(MN)},Q&#94;{(MN)}$ は非可換で$Q&#94;{(MN)}=E_N\\otimes Q$ のとき、つまり $Q_1=Q_2=\\dots=Q_N$ のときのみ可換になる（$P&#94;{(MN)}Q&#94;{(MN)}=(P\\otimes E_M)(E_N\\otimes Q)=(E_N\\otimes Q)(P\\otimes E_M)=Q&#94;{(MN)}P&#94;{(MN)}$）。 トレースを変形する。 ここで を定義した。$Q_I,C_{IJ}\\in\\mathbb{R}&#94;{M\\times M}$ であり、その行列積は$N$回評価すればよい（$\\mathcal O(NM&#94;3)$）。これは$NM\\times NM$の行列積（$\\mathcal O(N&#94;3M&#94;3)$）を計算するよりははるかに評価が簡単になる。 次元削減 $P,Q$を同時に解くのは難しいが、行列 に対して直交プロクラステス問題を繰り返し解くことで、$P,Q$を自己無撞着に求めることができる。ここで $d\\le n,d\\le m$ の場合、$\\sum_{J=1}&#94;Np_{JI}C_{IJ}$ や ${\\mathrm{tr}[Q_I\\sum_{J=1}&#94;N C_{IJ}]}_{IJ}$ の持つ次元はたかだか $d$ に制限されるため、それぞれフル次元で求解することは非効率で、解の不定性と不安定性をもたらす。そこで事前処理として、$X,Y$の有効次元を落としておく。\n直交行列 $U\\in\\mathbb{R}&#94;{d\\times d},V\\in\\mathbb{R}&#94;{n\\times n},W\\in\\mathbb{R}&#94;{m\\times m}$ に対して とする。これはトレースの循環性より評価値を変えない。ここで $X,Y\\in\\mathbb R&#94;{d\\times n}$ に対して、$Z=X-Y$ とおくと、$U$ は $Z$ の左特異ベクトル、$V\\otimes W$ は右特異ベクトルを取れば良い。 分散が0の軸$w\\in\\mathbb R&#94;{n\\times 1}$は を満たす。したがって が成り立っている。 そこでまずPCAによる次元削減を行い、$d$ 次元以下の直交プロクラステス問題を解くことを考える。 まずは $C_Q$ の次元削減を考える。 に対して、対称行列 を作る。このとき固有ベクトルとなる直交行列 $W_{IJ}$ を取ることができる。 実効次元が制限されるため、任意の$IJ$と$k>d$ に対して、$\\lambda_{IJ,1}=\\dots=\\lambda_{IJ,M}=0$ が成り立つように取れば、任意の$\\lambda_k=0$ に対応する固有ベクトル $w_k$ は を満たすから、式変形すると となり、直交プロクラステス問題は とすることができる。ここで右辺第二項を最大化する直交行列は $Q_I''=E_{m-d}$ であると直ちに定まるから、$Q_I'\\in\\mathbb{R}&#94;{d\\times d}$ を求める問題に帰着する。 目的関数の勾配 ラグランジュの未定乗数 $\\lambda=(\\lambda_P,\\lambda_Q,\\lambda_R,\\lambda_{|R|})$ に対して を目的関数として最大化することを考える。ここで $g$ は$A\\in\\mathbb{R}&#94;{n\\times m}$ に対して で定義される。 $P,Q$ の拘束条件より の最大化問題へと簡略化される。 $P$ について偏微分を行うと と計算できる。 第一項は と求まる。第二項は と計算でき、ここで、$\\mathbb{R}&#94;{n\\times n}\\ni A={a_{ij}}_{ij}$ に対して まとめると が得られる。 $Q_I$についても同様に であるから と定まる。 $R$については と変形しておいて と計算できる。この形式は部分回転を考える際に計算不要な部分をスキップできるためクロネッカー積で表される$\\mathbb{R}&#94;{MN\\times MN}$ の直行行列を用いるより有利である。まとめて ここで$\\mathrm{adj}(R)$ は $R$ の余因子行列を表す。 未定乗数の勾配についても同様に と計算される。 Note note Developer Info yymmt742","tags":"home","loc":"index.html"},{"title":"f_matrix – mobbrmsd ","text":"type, public :: f_matrix F matrix manager.\n This derived type is mainly used for passing during initialization. Contents Constructor f_matrix Constructor public interface f_matrix Constructer private pure function f_matrix_new(b) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: b (*) mol_block, must be initialized Return Value type( f_matrix )","tags":"","loc":"type/f_matrix.html"},{"title":"mol_block – mobbrmsd ","text":"type, public :: mol_block sequence molecular block\n This is mainly used for passing during initialization. Contents Constructor mol_block Constructor public interface mol_block private pure function mol_block_new(n, M, sym) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: n number of atoms per molecule integer(kind=IK), intent(in) :: M number of molecules integer(kind=IK), intent(in), optional :: sym (:,:) symmetric codomains, sym(n, S) Return Value type( mol_block )","tags":"","loc":"type/mol_block.html"},{"title":"group_permutation – mobbrmsd ","text":"type, public :: group_permutation A structure that references an array representing a replacement operation. It is possible to hold s permutation mapping of starting from [1,2,...,N].\n This is mainly used for passing during initialization. Contents Constructor group_permutation Finalization Procedures group_permutation_destroy Constructor public interface group_permutation private pure function group_permutation_new(perm) result(res) Constructor. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in), optional :: perm (:,:) codomains, [[a1,a2,...,am],[b1,b2,...,bm],...]. Return Value type( group_permutation ) return value. Finalization Procedures final :: group_permutation_destroy private pure elemental subroutine group_permutation_destroy(this) Arguments Type Intent Optional Attributes Name type( group_permutation ), intent(inout) :: this","tags":"","loc":"type/group_permutation.html"},{"title":"c_matrix – mobbrmsd ","text":"type, public :: c_matrix C matrix manager.\n  This derived type is mainly used for passing during initialization. Contents Constructor c_matrix Finalization Procedures c_matrix_destroy Constructor public interface c_matrix Constructer private pure function c_matrix_new(b) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: b (*) mol_block header, must be initialized. Return Value type( c_matrix ) Finalization Procedures final :: c_matrix_destroy private pure elemental subroutine c_matrix_destroy(this) Arguments Type Intent Optional Attributes Name type( c_matrix ), intent(inout) :: this","tags":"","loc":"type/c_matrix.html"},{"title":"bb_list – mobbrmsd ","text":"type, public :: bb_list This derived type is mainly used for passing during initialization. Contents Constructor bb_list Finalization Procedures bb_list_destroy Constructor public interface bb_list Constructer private pure function bb_list_new(blk) result(res) Constructer Arguments Type Intent Optional Attributes Name type( bb_block ), intent(in) :: blk (:) Return Value type( bb_list ) Finalization Procedures final :: bb_list_destroy private pure elemental subroutine bb_list_destroy(this) destractor Arguments Type Intent Optional Attributes Name type( bb_list ), intent(inout) :: this","tags":"","loc":"type/bb_list.html"},{"title":"tree – mobbrmsd ","text":"type, public :: tree Factorial tree. Note This type is mainly used for passing during initialization. Contents Constructor tree Finalization Procedures tree_destroy Constructor public interface tree private pure function tree_new(nmol, nsym) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: nmol number of molecule integer(kind=IK), intent(in) :: nsym number of molecular symmetry Return Value type( tree ) Finalization Procedures final :: tree_destroy private pure elemental subroutine tree_destroy(this) Destoructer Arguments Type Intent Optional Attributes Name type( tree ), intent(inout) :: this","tags":"","loc":"type/tree.html"},{"title":"mobbrmsd_input – mobbrmsd ","text":"type, public :: mobbrmsd_input mobbrmsd_input Contents Variables blk Finalization Procedures mobbrmsd_input_destroy Type-Bound Procedures add Components Type Visibility Attributes Name Initial type( mol_block_input ), public, allocatable :: blk (:) Finalization Procedures final :: mobbrmsd_input_destroy public pure elemental subroutine mobbrmsd_input_destroy (this) destractor Arguments Type Intent Optional Attributes Name type( mobbrmsd_input ), intent(inout) :: this Type-Bound Procedures procedure, public :: add => mobbrmsd_input_add public pure subroutine mobbrmsd_input_add (this, m, n, sym) add molecule Arguments Type Intent Optional Attributes Name class( mobbrmsd_input ), intent(inout) :: this mol_block_input array integer(kind=IK), intent(in) :: m number of atoms per molecule integer(kind=IK), intent(in) :: n number of molecule integer(kind=IK), intent(in), optional :: sym (:,:) molecular symmetry, sym(m, s-1)","tags":"","loc":"type/mobbrmsd_input.html"},{"title":"mol_block_input – mobbrmsd ","text":"type, public :: mol_block_input mol_block_input (for python interface) Contents Variables m n sym Finalization Procedures mol_block_input_destroy Components Type Visibility Attributes Name Initial integer(kind=IK), public :: m number of atoms per molecule integer(kind=IK), public :: n number of molecule integer(kind=IK), public, allocatable :: sym (:,:) molecular symmetry Finalization Procedures final :: mol_block_input_destroy public pure elemental subroutine mol_block_input_destroy (this) destractor Arguments Type Intent Optional Attributes Name type( mol_block_input ), intent(inout) :: this","tags":"","loc":"type/mol_block_input.html"},{"title":"mobbrmsd – mobbrmsd ","text":"type, public :: mobbrmsd mobbrmsd Contents Variables h s Constructor mobbrmsd Finalization Procedures mobbrmsd_destroy Components Type Visibility Attributes Name Initial type( mobbrmsd_header ), public :: h mobbrmsd_header type( mobbrmsd_state ), public :: s mobbrmsd_state Constructor public interface mobbrmsd public pure elemental function mobbrmsd_new (inp) result(res) constructor Arguments Type Intent Optional Attributes Name type( mobbrmsd_input ), intent(in) :: inp mobbrmsd_input Return Value type( mobbrmsd ) public pure function mobbrmsd_new_from_block (blocks) result(res) constructor, from mol_block_input. (for python interface) Arguments Type Intent Optional Attributes Name type( mol_block_input ), intent(in) :: blocks (:) mol_block_input array Return Value type( mobbrmsd ) Finalization Procedures final :: mobbrmsd_destroy public pure elemental subroutine mobbrmsd_destroy (this) Arguments Type Intent Optional Attributes Name type( mobbrmsd ), intent(inout) :: this","tags":"","loc":"type/mobbrmsd.html"},{"title":"mobbrmsd_header – mobbrmsd ","text":"type, public :: mobbrmsd_header mobbrmsd_header Contents Variables d q s Constructor mobbrmsd_header Finalization Procedures mobbrmsd_header_destroy Type-Bound Procedures n_dims n_block n_atoms log_n_nodes frac_n_nodes exp_n_nodes memsize state_template dump load Components Type Visibility Attributes Name Initial integer(kind=IK), public :: d spatial dimension integer(kind=IK), public, allocatable :: q (:) header array integer(kind=IK), public, allocatable :: s (:) state template Constructor public interface mobbrmsd_header public pure function mobbrmsd_header_new (q, s) result(res) Returns spatial dimension Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (:) mobbrmsd_header sequence integer(kind=IK), intent(in) :: s (:) mobbrmsd_state template sequence Return Value type( mobbrmsd_header ) Finalization Procedures final :: mobbrmsd_header_destroy public pure elemental subroutine mobbrmsd_header_destroy (this) destructer Arguments Type Intent Optional Attributes Name type( mobbrmsd_header ), intent(inout) :: this Type-Bound Procedures procedure, public :: n_dims => mobbrmsd_header_n_dims public pure elemental function mobbrmsd_header_n_dims (this) result(res) Returns spatial dimension Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK) procedure, public :: n_block => mobbrmsd_header_n_block public pure elemental function mobbrmsd_header_n_block (this) result(res) Returns number of molecular blocks Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK) procedure, public :: n_atoms => mobbrmsd_header_n_atoms public pure elemental function mobbrmsd_header_n_atoms (this) result(res) Returns n_atoms Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK) procedure, public :: log_n_nodes => mobbrmsd_header_log_n_nodes public pure elemental function mobbrmsd_header_log_n_nodes (this) result(res) Returns log_n_nodes Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value real(kind=RK) procedure, public :: frac_n_nodes => mobbrmsd_header_frac_n_nodes public pure function mobbrmsd_header_frac_n_nodes (this) result(res) returns number of nodes in fraction. Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value real(kind=RK) procedure, public :: exp_n_nodes => mobbrmsd_header_exp_n_nodes public pure function mobbrmsd_header_exp_n_nodes (this) result(res) returns number of nodes in exp. Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK) procedure, public :: memsize => mobbrmsd_header_memsize public pure elemental function mobbrmsd_header_memsize (this) result(res) Returns header_memsize Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK) procedure, public :: state_template => mobbrmsd_header_state_template public pure function mobbrmsd_header_state_template (this) result(res) dump state template as integer array Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK),allocatable, (:) procedure, public :: dump => mobbrmsd_header_dump public pure function mobbrmsd_header_dump (this) result(res) dump header as integer array Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK),allocatable, (:) procedure, public :: load => mobbrmsd_header_load public pure subroutine mobbrmsd_header_load (this, q) load integer array as header Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(inout) :: this this integer(kind=IK), intent(in) :: q (:) header array","tags":"","loc":"type/mobbrmsd_header.html"},{"title":"mobbrmsd_state – mobbrmsd ","text":"type, public :: mobbrmsd_state mobbrmsd_state Contents Variables s z Constructor mobbrmsd_state Finalization Procedures mobbrmsd_state_destroy Type-Bound Procedures upperbound lowerbound autovariance squared_deviation mean_squared_deviation rmsd lowerbound_as_rmsd n_eval eval_ratio log_eval_ratio rotation dump dump_real load Components Type Visibility Attributes Name Initial integer(kind=IK), public, allocatable :: s (:) real(kind=RK), public, allocatable :: z (:) Constructor public interface mobbrmsd_state public pure elemental function mobbrmsd_state_new (header) result(res) returns upperbound Arguments Type Intent Optional Attributes Name type( mobbrmsd_header ), intent(in) :: header mobbrmsd header Return Value type( mobbrmsd_state ) Finalization Procedures final :: mobbrmsd_state_destroy destracter public pure elemental subroutine mobbrmsd_state_destroy (this) Arguments Type Intent Optional Attributes Name type( mobbrmsd_state ), intent(inout) :: this Type-Bound Procedures procedure, public :: upperbound => mobbrmsd_state_upperbound upperbound public pure elemental function mobbrmsd_state_upperbound (this) result(res) returns upperbound Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) procedure, public :: lowerbound => mobbrmsd_state_lowerbound lowerbound public pure elemental function mobbrmsd_state_lowerbound (this) result(res) returns lowerbound Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) procedure, public :: autovariance => mobbrmsd_state_autovariance lowerbound public pure elemental function mobbrmsd_state_autovariance (this) result(res) returns autovariance Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) procedure, public :: squared_deviation => mobbrmsd_state_squared_deviation sqrared_deviation public pure elemental function mobbrmsd_state_squared_deviation (this) result(res) returns squared deviation Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) procedure, public :: mean_squared_deviation => mobbrmsd_state_mean_squared_deviation sqrared_deviation public pure elemental function mobbrmsd_state_mean_squared_deviation (this) result(res) returns squared deviation Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) procedure, public :: rmsd => mobbrmsd_state_rmsd rmsd public pure elemental function mobbrmsd_state_rmsd (this) result(res) returns rmsd Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) procedure, public :: lowerbound_as_rmsd => mobbrmsd_state_lowerbound_as_rmsd lowerbound_as_rmsd public pure elemental function mobbrmsd_state_lowerbound_as_rmsd (this) result(res) returns lowerbound as rmsd Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) procedure, public :: n_eval => mobbrmsd_state_n_eval number of lowerbound evaluation public pure elemental function mobbrmsd_state_n_eval (this) result(res) returns n_eval Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value integer(kind=IK) procedure, public :: eval_ratio => mobbrmsd_state_eval_ratio ratio of evaluated node public pure elemental function mobbrmsd_state_eval_ratio (this) result(res) returns eval_ratio Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) procedure, public :: log_eval_ratio => mobbrmsd_state_log_eval_ratio log ratio of evaluated node public pure elemental function mobbrmsd_state_log_eval_ratio (this) result(res) returns log_eval_ratio Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this Return Value real(kind=RK) procedure, public :: rotation => mobbrmsd_state_rotation rotate given coordinate public pure subroutine mobbrmsd_state_rotation (this, header, X) returns eval_ratio Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this type( mobbrmsd_header ), intent(in) :: header mobbrmsd header real(kind=RK), intent(inout) :: X (*) coordinate procedure, public :: dump => mobbrmsd_state_dump dump current state public pure function mobbrmsd_state_dump (this) result(res) dump header as integer array (for python interface api) Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this mobbrmsd_header Return Value integer(kind=IK),allocatable, (:) procedure, public :: dump_real => mobbrmsd_state_dump_real dump real part of current state public pure function mobbrmsd_state_dump_real (this) result(res) dump header as integer array (for python interface api) Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this mobbrmsd_header Return Value real(kind=RK),allocatable, (:) procedure, public :: load => mobbrmsd_state_load load state public pure subroutine mobbrmsd_state_load (this, s, z) load integer array as header (for python interface api) Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(inout) :: this mobbrmsd_header integer(kind=IK), intent(in) :: s (:) state integer array real(kind=RK), intent(in) :: z (:) state real array","tags":"","loc":"type/mobbrmsd_state.html"},{"title":"bb_block – mobbrmsd ","text":"type, public :: bb_block bb_block This is mainly used for passing during initialization. Contents Constructor bb_block Finalization Procedures bb_block_destroy Constructor public interface bb_block private pure function bb_block_new(n_apm, n_mol, sym) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: n_apm number of molecules. integer(kind=IK), intent(in) :: n_mol number of atoms per molecule. integer(kind=IK), intent(in), optional :: sym (:,:) symmetric codomains, [[a1,a2,...,am], [b1,b2,...,bm], ...]. Return Value type( bb_block ) Finalization Procedures final :: bb_block_destroy private pure elemental subroutine bb_block_destroy(this) destructer Arguments Type Intent Optional Attributes Name type( bb_block ), intent(inout) :: this","tags":"","loc":"type/bb_block.html"},{"title":"DGEMM – mobbrmsd","text":"pure subroutine DGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses iso_fortran_env DGEMM for . and are provided for compatibility with BLAS and are not used here. Warning This is not a full-featured routine for GEMM. Do not use this routine for anything other than calculating the covariance matrix. Calculate only operations with . Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA IF TRANSA(1)='T', transpose A. character(len=1), intent(in) :: TRANSB IF TRANSB(1)='T', transpose B. integer, intent(in) :: M matrix dimension, not used. integer, intent(in) :: N matrix dimension, not used. integer, intent(in) :: K matrix dimension, not used. real(kind=RK), intent(in) :: ALPHA A coefficient, not used. real(kind=RK), intent(in) :: A (LDA,*) matrix A. integer, intent(in) :: LDA leading dimension of A, must be >1. real(kind=RK), intent(in) :: B (LDA,*) matrix B. integer, intent(in) :: LDB leading dimension of B, must be >1. real(kind=RK), intent(in) :: BETA A coefficient, not used. real(kind=RK), intent(inout) :: C (LDA,*) matrix C. integer, intent(in) :: LDC leading dimension of C, must be >1. Contents None","tags":"","loc":"proc/dgemm.html"},{"title":"SGEMM – mobbrmsd","text":"pure subroutine SGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses iso_fortran_env SGEMM for . and are provided for compatibility with BLAS and are not used here. Warning This is not a full-featured routine for GEMM. Do not use this routine for anything other than calculating the covariance matrix. Calculate only operations with . Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA IF TRANSA(1)='T', transpose A. character(len=1), intent(in) :: TRANSB IF TRANSB(1)='T', transpose B. integer, intent(in) :: M matrix dimension, not used. integer, intent(in) :: N matrix dimension, not used. integer, intent(in) :: K matrix dimension, not used. real(kind=RK), intent(in) :: ALPHA A coefficient, not used. real(kind=RK), intent(in) :: A (LDA,*) matrix A. integer, intent(in) :: LDA leading dimension of A, must be >1. real(kind=RK), intent(in) :: B (LDB,*) matrix B. integer, intent(in) :: LDB leading dimension of B, must be >1. real(kind=RK), intent(in) :: BETA A coefficient, not used. real(kind=RK), intent(inout) :: C (LDC,*) matrix C. integer, intent(in) :: LDC leading dimension of C, must be >1. Contents None","tags":"","loc":"proc/sgemm.html"},{"title":"DGEMM – mobbrmsd","text":"pure subroutine DGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses iso_fortran_env DGEMM for M=N=3. N and M are provided for compatibility with BLAS and are not used here. Warning This is not a full-featured routine for GEMM. Do not use this routine for anything other than calculating the covariance matrix. Calculate only operations with . Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA IF TRANSA(1)='T', transpose A. character(len=1), intent(in) :: TRANSB IF TRANSB(1)='T', transpose B. integer, intent(in) :: M matrix dimension, not used. integer, intent(in) :: N matrix dimension, not used. integer, intent(in) :: K matrix dimension, not used. real(kind=RK), intent(in) :: ALPHA A coefficient, not used. real(kind=RK), intent(in) :: A (LDA,*) matrix A. integer, intent(in) :: LDA leading dimension of A, must be >1. real(kind=RK), intent(in) :: B (LDB,*) matrix B. integer, intent(in) :: LDB leading dimension of B, must be >1. real(kind=RK), intent(in) :: BETA A coefficient, not used. real(kind=RK), intent(inout) :: C (LDC,*) matrix C. integer, intent(in) :: LDC leading dimension of C, must be >1. Contents None","tags":"","loc":"proc/dgemm~2.html"},{"title":"SGEMM – mobbrmsd","text":"pure subroutine SGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Uses iso_fortran_env SGEMM for M=N=3. N and M are provided for compatibility with BLAS and are not used here. Warning This is not a full-featured routine for GEMM. Do not use this routine for anything other than calculating the covariance matrix. Calculate only operations with . Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA IF TRANSA(1)='T', transpose A. character(len=1), intent(in) :: TRANSB IF TRANSB(1)='T', transpose B. integer, intent(in) :: M matrix dimension, not used. integer, intent(in) :: N matrix dimension, not used. integer, intent(in) :: K matrix dimension, not used. real(kind=RK), intent(in) :: ALPHA A coefficient, not used. real(kind=RK), intent(in) :: A (LDA,*) matrix A. integer, intent(in) :: LDA leading dimension of A, must be >1. real(kind=RK), intent(in) :: B (LDB,*) matrix B. integer, intent(in) :: LDB leading dimension of B, must be >1. real(kind=RK), intent(in) :: BETA A coefficient, not used. real(kind=RK), intent(inout) :: C (LDC,*) matrix C. integer, intent(in) :: LDC leading dimension of C, must be >1. Contents None","tags":"","loc":"proc/sgemm~2.html"},{"title":"f_matrix_memsize – mobbrmsd","text":"public pure function f_matrix_memsize(q) result(res) Inquire memsize of f_matrix Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) f_matrix Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/f_matrix_memsize.html"},{"title":"f_matrix_worksize – mobbrmsd","text":"public pure function f_matrix_worksize(q) result(res) Inquire worksize of f_matrix Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) f_matrix Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/f_matrix_worksize.html"},{"title":"f_matrix_eval – mobbrmsd","text":"public pure subroutine f_matrix_eval(q, qc, C, F, W) Evaluation the D matrix Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header of f_matrix integer(kind=IK), intent(in) :: qc (*) header of covariacne matrix C. real(kind=RK), intent(inout) :: C (*) covariacne matrix c. real(kind=RK), intent(inout) :: F (*) main memory of F. real(kind=RK), intent(inout) :: W (*) work array. Contents None","tags":"","loc":"proc/f_matrix_eval.html"},{"title":"f_matrix – mobbrmsd","text":"public interface f_matrix Constructer Contents Module Procedures f_matrix_new Module Procedures private pure function f_matrix_new(b) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: b (*) mol_block, must be initialized Return Value type( f_matrix )","tags":"","loc":"interface/f_matrix.html"},{"title":"mol_block_natm – mobbrmsd","text":"public pure function mol_block_natm(q) result(res) number of atoms, defined by . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) mol_block Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/mol_block_natm.html"},{"title":"mol_block_nmol – mobbrmsd","text":"public pure function mol_block_nmol(q) result(res) number of molecules, . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) mol_block Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/mol_block_nmol.html"},{"title":"mol_block_napm – mobbrmsd","text":"public pure function mol_block_napm(q) result(res) number of atoms per molecule, Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) mol_block Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/mol_block_napm.html"},{"title":"mol_block_nsym – mobbrmsd","text":"public pure function mol_block_nsym(q) result(res) number of molecular symmetry, . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) mol_block Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/mol_block_nsym.html"},{"title":"mol_block_each_size – mobbrmsd","text":"public pure function mol_block_each_size(q) result(res) memory blocksize per molecule, defined by . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) mol_block Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/mol_block_each_size.html"},{"title":"mol_block_total_size – mobbrmsd","text":"public pure function mol_block_total_size(q) result(res) memory blocksize, defined by . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) mol_block Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/mol_block_total_size.html"},{"title":"mol_block_swap – mobbrmsd","text":"public pure subroutine mol_block_swap(q, isym, X) Compute molecular symmetry permutation according to isym. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) mol_block integer(kind=IK), intent(in) :: isym symmetry id real(kind=RK), intent(inout) :: X (*) work array Contents None","tags":"","loc":"proc/mol_block_swap.html"},{"title":"mol_block_inverse_swap – mobbrmsd","text":"public pure subroutine mol_block_inverse_swap(q, isym, X) Compute molecular symmetry inverse permutation according to isym. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) mol_block integer(kind=IK), intent(in) :: isym symmetry id. real(kind=RK), intent(inout) :: X (*) work array Contents None","tags":"","loc":"proc/mol_block_inverse_swap.html"},{"title":"mol_block – mobbrmsd","text":"public interface mol_block Contents Module Procedures mol_block_new Module Procedures private pure function mol_block_new(n, M, sym) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: n number of atoms per molecule integer(kind=IK), intent(in) :: M number of molecules integer(kind=IK), intent(in), optional :: sym (:,:) symmetric codomains, sym(n, S) Return Value type( mol_block )","tags":"","loc":"interface/mol_block.html"},{"title":"group_permutation_nsym – mobbrmsd","text":"public pure function group_permutation_nsym(q) result(res) nsym of group_permutation Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) work array. Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/group_permutation_nsym.html"},{"title":"group_permutation_swap – mobbrmsd","text":"public pure subroutine group_permutation_swap(q, s, d, X) Replaces an array of real numbers according to the map s. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) work array. integer(kind=IK), intent(in) :: s permutation index. integer(kind=IK), intent(in) :: d leading dimension of x real(kind=RK), intent(inout) :: X (*) data array. Contents None","tags":"","loc":"proc/group_permutation_swap.html"},{"title":"group_permutation_inverse – mobbrmsd","text":"public pure subroutine group_permutation_inverse(q, s, d, X) Replaces an array of real numbers according to the inverse map s. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) work array. integer(kind=IK), intent(in) :: s permutation index. integer(kind=IK), intent(in) :: d leading dimension of x real(kind=RK), intent(inout) :: X (*) data array. Contents None","tags":"","loc":"proc/group_permutation_inverse.html"},{"title":"group_permutation – mobbrmsd","text":"public interface group_permutation Contents Module Procedures group_permutation_new Module Procedures private pure function group_permutation_new(perm) result(res) Constructor. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in), optional :: perm (:,:) codomains, [[a1,a2,...,am],[b1,b2,...,bm],...]. Return Value type( group_permutation ) return value.","tags":"","loc":"interface/group_permutation.html"},{"title":"c_matrix_blocksize – mobbrmsd","text":"public pure function c_matrix_blocksize(q) result(res) Inquire blocksize of c_matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) c_matrix header. Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/c_matrix_blocksize.html"},{"title":"c_matrix_memsize – mobbrmsd","text":"public pure function c_matrix_memsize(q) result(res) Inquire memsize of c_matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) c_matrix header. Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/c_matrix_memsize.html"},{"title":"c_matrix_worksize – mobbrmsd","text":"public pure function c_matrix_worksize(q) result(res) Inquire worksize of c_matrix evaluation. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) c_matrix header. Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/c_matrix_worksize.html"},{"title":"c_matrix_eval – mobbrmsd","text":"public pure subroutine c_matrix_eval(q, b, s, X, Y, CX, CY, C, W, sort_by_g) Evaluation the c-matrix. g-matrix is also calculated at the same time. At the end of the calculation, save the c-matrix C(cb,M,M) to C(*). workarray W(*) must be larger than c_matrix_worksize(q). Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) c_matrix header. integer(kind=IK), intent(in) :: b (*) mol block header. integer(kind=IK), intent(inout) :: s (*) swap_indice real(kind=RK), intent(in) :: X (*) reference coordinate, real(kind=RK), intent(in) :: Y (*) target coordinate, real(kind=RK), intent(in) :: CX (*) centroid of . real(kind=RK), intent(in) :: CY (*) centroid of . real(kind=RK), intent(inout) :: C (*) main memory real(kind=RK), intent(inout) :: W (*) work memory logical, intent(in), optional :: sort_by_g if true, row is sorted respect to G of reference coordinate. Contents None","tags":"","loc":"proc/c_matrix_eval.html"},{"title":"c_matrix_autocorr – mobbrmsd","text":"public pure subroutine c_matrix_autocorr(q, C, G) Calc . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) c_matrix real(kind=RK), intent(in) :: C (*) main memory, calculated by c_matrix_eval. real(kind=RK), intent(inout) :: G partial covariance matrix, must be larger than . Contents None","tags":"","loc":"proc/c_matrix_autocorr.html"},{"title":"c_matrix_add – mobbrmsd","text":"public pure subroutine c_matrix_add(q, i, j, s, C, G, Cp) Adds and specified by index to the arguments. This routine adds directly to G and C(:DD), so they must be initialized. If indices outside the area defined by q(*) is specified, operation results are not guaranteed. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) c_matrix integer(kind=IK), intent(in) :: i row index integer(kind=IK), intent(in) :: j collumn index integer(kind=IK), intent(in) :: s symmetry index real(kind=RK), intent(in) :: C (*) main memory, calculated by c_matrix_eval. real(kind=RK), intent(inout) :: G partial auto variance matrix. real(kind=RK), intent(inout) :: Cp (*) partial covariance matrix, must be larger than . Contents None","tags":"","loc":"proc/c_matrix_add.html"},{"title":"c_matrix_swap_indices – mobbrmsd","text":"public pure subroutine c_matrix_swap_indices(q, s, z, res) returns swap(z) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state integer(kind=IK), intent(in) :: z (*) permutation integer(kind=IK), intent(inout) :: res (*) swap indice Contents None","tags":"","loc":"proc/c_matrix_swap_indices.html"},{"title":"c_matrix – mobbrmsd","text":"public interface c_matrix Constructer Contents Module Procedures c_matrix_new Module Procedures private pure function c_matrix_new(b) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: b (*) mol_block header, must be initialized. Return Value type( c_matrix )","tags":"","loc":"interface/c_matrix.html"},{"title":"bb_list_memsize – mobbrmsd","text":"public pure function bb_list_memsize(q) result(res) Inquire worksize of f_matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) bb_block. Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/bb_list_memsize.html"},{"title":"bb_list_n_block – mobbrmsd","text":"public pure function bb_list_n_block(q) result(res) Returns number of molecular blocks. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) bb_block. Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/bb_list_n_block.html"},{"title":"bb_list_n_atoms – mobbrmsd","text":"public pure function bb_list_n_atoms(q) result(res) Returns number of total atoms. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) bb_block. Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/bb_list_n_atoms.html"},{"title":"bb_list_log_n_nodes – mobbrmsd","text":"public pure function bb_list_log_n_nodes(q) result(res) Returns the logarithm of the total number of nodes. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) bb_block. Return Value real(kind=RK) Contents None","tags":"","loc":"proc/bb_list_log_n_nodes.html"},{"title":"bb_list_is_finished – mobbrmsd","text":"public pure function bb_list_is_finished(q, s) result(res) Returns bb is finished. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical Contents None","tags":"","loc":"proc/bb_list_is_finished.html"},{"title":"bb_list_setup – mobbrmsd","text":"public pure subroutine bb_list_setup(q, s, X, Y, W, remove_com, sort_by_g) Setup Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(inout) :: s (*) state real(kind=RK), intent(in) :: X (*) reference coordinate real(kind=RK), intent(in) :: Y (*) target coordinate real(kind=RK), intent(inout) :: W (*) work array logical, intent(in), optional :: remove_com if true, remove centroids. default [.true.] logical, intent(in), optional :: sort_by_g if true, row is sorted respect to G of reference coordinate. default [.true.] Contents None","tags":"","loc":"proc/bb_list_setup.html"},{"title":"bb_list_run – mobbrmsd","text":"public pure subroutine bb_list_run(q, s, W, cutoff, difflim, maxeval) run branch and bound Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(inout) :: s (*) state real(kind=RK), intent(inout) :: W (*) work array real(kind=RK), intent(in), optional :: cutoff The search ends when lowerbound is determined real(kind=RK), intent(in), optional :: difflim The search ends when the difference integer(kind=IK), intent(in), optional :: maxeval The search ends when ncount exceeds maxiter. Contents None","tags":"","loc":"proc/bb_list_run.html"},{"title":"bb_list_swap_y – mobbrmsd","text":"public pure subroutine bb_list_swap_y(q, s, Y) Swap target coordinate. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state real(kind=RK), intent(inout) :: Y (*) target coordinate Contents None","tags":"","loc":"proc/bb_list_swap_y.html"},{"title":"bb_list_rotation_matrix – mobbrmsd","text":"public pure subroutine bb_list_rotation_matrix(q, s, W, R) Sum covariance matrix by saved state z. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array integer(kind=IK), intent(in) :: s (*) state real(kind=RK), intent(in) :: W (*) main memory real(kind=RK), intent(inout) :: R (*) rotation matrix Contents None","tags":"","loc":"proc/bb_list_rotation_matrix.html"},{"title":"bb_list – mobbrmsd","text":"public interface bb_list Constructer Contents Module Procedures bb_list_new Module Procedures private pure function bb_list_new(blk) result(res) Constructer Arguments Type Intent Optional Attributes Name type( bb_block ), intent(in) :: blk (:) Return Value type( bb_list )","tags":"","loc":"interface/bb_list.html"},{"title":"tree_nnodes – mobbrmsd","text":"public pure function tree_nnodes(q) result(res) Inquire number of nodes,\n defined by . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/tree_nnodes.html"},{"title":"tree_current_level – mobbrmsd","text":"public pure function tree_current_level(s) result(res) Returns current level, . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/tree_current_level.html"},{"title":"tree_current_state – mobbrmsd","text":"public pure function tree_current_state(s) result(res) Returns the state of current node, . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/tree_current_state.html"},{"title":"tree_current_nnodes – mobbrmsd","text":"public pure function tree_current_nnodes(q, s) result(res) Returns the number of nodes in -queue. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/tree_current_nnodes.html"},{"title":"tree_current_iper – mobbrmsd","text":"public pure function tree_current_iper(q, s) result(res) Returns current permutation indices of . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/tree_current_iper.html"},{"title":"tree_current_isym – mobbrmsd","text":"public pure function tree_current_isym(q, s) result(res) Returns current mapping index of . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/tree_current_isym.html"},{"title":"tree_queue_pointer – mobbrmsd","text":"public pure function tree_queue_pointer(q, s) result(res) Returns a pointer to the current queue. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/tree_queue_pointer.html"},{"title":"tree_current_pointer – mobbrmsd","text":"public pure function tree_current_pointer(q, s) result(res) Returns a pointer to the current node, . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/tree_current_pointer.html"},{"title":"tree_node_pointer – mobbrmsd","text":"public pure function tree_node_pointer(q, s, iper, isym) result(res) Returns a pointer to a node specified by iper, isym. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state integer(kind=IK), intent(in) :: iper permutation index, must be [0,1,...,q%n/s-1]. integer(kind=IK), intent(in) :: isym mapping index, must be [0,1,...,s-1]. Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/tree_node_pointer.html"},{"title":"tree_current_sequence – mobbrmsd","text":"public pure function tree_current_sequence(q, s) result(res) Returns current sequence indices. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK)(q(qd)) Contents None","tags":"","loc":"proc/tree_current_sequence.html"},{"title":"tree_current_permutation – mobbrmsd","text":"public pure function tree_current_permutation(q, s) result(res) Returns current permutation indices. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK)(q(qd)) Contents None","tags":"","loc":"proc/tree_current_permutation.html"},{"title":"tree_sequence_to_permutation – mobbrmsd","text":"public pure function tree_sequence_to_permutation(q, z) result(res) Convert sequence to permutation. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: z (*) state Return Value integer(kind=IK)(q(qd)) Contents None","tags":"","loc":"proc/tree_sequence_to_permutation.html"},{"title":"tree_current_mapping – mobbrmsd","text":"public pure function tree_current_mapping(q, s) result(res) Returns current mapping indices. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK)(q(qd)) Contents None","tags":"","loc":"proc/tree_current_mapping.html"},{"title":"tree_sequence_to_mapping – mobbrmsd","text":"public pure function tree_sequence_to_mapping(q, z) result(res) Convert sequence to mapping. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: z (*) state Return Value integer(kind=IK)(q(qd)) Contents None","tags":"","loc":"proc/tree_sequence_to_mapping.html"},{"title":"tree_lowest_value – mobbrmsd","text":"public pure function tree_lowest_value(q, s, ld, W) result(res) Returns the minimum value of the surviving nodes, excluding the current value.\n If tree is empty, Returns -infty. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state integer(kind=IK), intent(in) :: ld leading dimension real(kind=RK), intent(in) :: W (ld,*) work array Return Value real(kind=RK) Contents None","tags":"","loc":"proc/tree_lowest_value.html"},{"title":"tree_n_sym – mobbrmsd","text":"public pure function tree_n_sym(q) result(res) Returns number of symmetry in queue. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/tree_n_sym.html"},{"title":"tree_n_perm – mobbrmsd","text":"public pure function tree_n_perm(q, s) result(res) Returns number of permutation in queue. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/tree_n_perm.html"},{"title":"tree_n_depth – mobbrmsd","text":"public pure function tree_n_depth(q) result(res) Returns number tree depth (without root node). Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/tree_n_depth.html"},{"title":"tree_log_ncomb – mobbrmsd","text":"public pure function tree_log_ncomb(q) result(res) Returns number of nodes in tree. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header Return Value real(kind=RK) Contents None","tags":"","loc":"proc/tree_log_ncomb.html"},{"title":"tree_ncomb_frac – mobbrmsd","text":"public pure function tree_ncomb_frac(q) result(res) Returns number of nodes in fraction. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header Return Value real(kind=RK) Contents None","tags":"","loc":"proc/tree_ncomb_frac.html"},{"title":"tree_ncomb_exp – mobbrmsd","text":"public pure function tree_ncomb_exp(q) result(res) Returns number of nodes in exp. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/tree_ncomb_exp.html"},{"title":"tree_queue_is_unexplored – mobbrmsd","text":"public pure function tree_queue_is_unexplored(q, s) result(res) Returns true if current node is unexplored. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical Contents None","tags":"","loc":"proc/tree_queue_is_unexplored.html"},{"title":"tree_queue_is_explored – mobbrmsd","text":"public pure function tree_queue_is_explored(q, s) result(res) Returns true if current node is explored. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical Contents None","tags":"","loc":"proc/tree_queue_is_explored.html"},{"title":"tree_is_empty – mobbrmsd","text":"public pure function tree_is_empty(q, s) result(res) Returns true if -queue is empty. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical Contents None","tags":"","loc":"proc/tree_is_empty.html"},{"title":"tree_is_unexplored – mobbrmsd","text":"public pure function tree_is_unexplored(q, s) result(res) Returns true if tree is unexplored. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical Contents None","tags":"","loc":"proc/tree_is_unexplored.html"},{"title":"tree_queue_is_empty – mobbrmsd","text":"public pure function tree_queue_is_empty(q, s) result(res) Returns true if -queue is explored. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical Contents None","tags":"","loc":"proc/tree_queue_is_empty.html"},{"title":"tree_queue_is_selected – mobbrmsd","text":"public pure function tree_queue_is_selected(q, s) result(res) Returns true if -queue has current node. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical Contents None","tags":"","loc":"proc/tree_queue_is_selected.html"},{"title":"tree_queue_is_left – mobbrmsd","text":"public pure function tree_queue_is_left(q, s, ld, UB, W) result(res) Returns true if -queue has an unexplored node other than the selected node. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state integer(kind=IK), intent(in) :: ld leading dimension real(kind=RK), intent(in) :: UB upperbound real(kind=RK), intent(in) :: W (ld,*) work array Return Value logical Contents None","tags":"","loc":"proc/tree_queue_is_left.html"},{"title":"tree_queue_is_root – mobbrmsd","text":"public pure function tree_queue_is_root(q, s) result(res) Returns true if . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical Contents None","tags":"","loc":"proc/tree_queue_is_root.html"},{"title":"tree_queue_is_bottom – mobbrmsd","text":"public pure function tree_queue_is_bottom(q, s) result(res) Returns true if . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical Contents None","tags":"","loc":"proc/tree_queue_is_bottom.html"},{"title":"tree_reset – mobbrmsd","text":"public pure subroutine tree_reset(q, s) Reset the state Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(inout) :: s (*) state Contents None","tags":"","loc":"proc/tree_reset.html"},{"title":"tree_expand – mobbrmsd","text":"public pure subroutine tree_expand(q, s) Expand current node. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(inout) :: s (*) state Contents None","tags":"","loc":"proc/tree_expand.html"},{"title":"tree_leave – mobbrmsd","text":"public pure subroutine tree_leave(q, s) Leave current node. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(inout) :: s (*) state Contents None","tags":"","loc":"proc/tree_leave.html"},{"title":"tree_select_top_node – mobbrmsd","text":"public pure subroutine tree_select_top_node(q, s, ld, UB, W) Select top node, using W(1, *). Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(inout) :: s (*) state integer(kind=IK), intent(in) :: ld leading dimension real(kind=RK), intent(in) :: UB upperbound real(kind=RK), intent(in) :: W (ld,*) work array Contents None","tags":"","loc":"proc/tree_select_top_node.html"},{"title":"tree – mobbrmsd","text":"public interface tree Contents Module Procedures tree_new Module Procedures private pure function tree_new(nmol, nsym) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: nmol number of molecule integer(kind=IK), intent(in) :: nsym number of molecular symmetry Return Value type( tree )","tags":"","loc":"interface/tree.html"},{"title":"Hungarian_worksize – mobbrmsd","text":"public pure elemental function Hungarian_worksize(m, n) result(res) query work array size Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: m matrix dimension 1. integer(kind=IK), intent(in) :: n matrix dimension 2. Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/hungarian_worksize.html"},{"title":"Hungarian – mobbrmsd","text":"public pure subroutine Hungarian(m, n, C, W) Calculate the minimum linear assignment cost using Hungarian method.\n If m and n are different, the sum of the linear assignments of the smaller is returned.\n If m>0 and n>0, W(1) stores the minimum linear assignment cost.\n If m==0 or n==0, do nothing.\n If (m<0 or n<0) and (|m|>0 and |n|>0), W(1) stores the required memory size for C(|m|,|n|). Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: m matrix dimension 1. integer(kind=IK), intent(in) :: n matrix dimension 2. real(kind=RK), intent(in) :: C (*) score matrix C(m, n). real(kind=RK), intent(inout) :: W (*) work array. Contents None","tags":"","loc":"proc/hungarian.html"},{"title":"mobbrmsd_new – mobbrmsd","text":"public pure elemental function mobbrmsd_new(inp) result(res) constructor Arguments Type Intent Optional Attributes Name type( mobbrmsd_input ), intent(in) :: inp mobbrmsd_input Return Value type( mobbrmsd ) Contents None","tags":"","loc":"proc/mobbrmsd_new.html"},{"title":"mobbrmsd_new_from_block – mobbrmsd","text":"public pure function mobbrmsd_new_from_block(blocks) result(res) constructor, from mol_block_input. (for python interface) Arguments Type Intent Optional Attributes Name type( mol_block_input ), intent(in) :: blocks (:) mol_block_input array Return Value type( mobbrmsd ) Contents None","tags":"","loc":"proc/mobbrmsd_new_from_block.html"},{"title":"mobbrmsd_is_finished – mobbrmsd","text":"public pure function mobbrmsd_is_finished(header, state) result(res) Returns bb process is finished. Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: header mobbrmsd_header class( mobbrmsd_state ), intent(in) :: state mobbrmsd_state Return Value logical Contents None","tags":"","loc":"proc/mobbrmsd_is_finished.html"},{"title":"mobbrmsd_input_add – mobbrmsd","text":"public pure subroutine mobbrmsd_input_add(this, m, n, sym) add molecule Arguments Type Intent Optional Attributes Name class( mobbrmsd_input ), intent(inout) :: this mol_block_input array integer(kind=IK), intent(in) :: m number of atoms per molecule integer(kind=IK), intent(in) :: n number of molecule integer(kind=IK), intent(in), optional :: sym (:,:) molecular symmetry, sym(m, s-1) Contents None","tags":"","loc":"proc/mobbrmsd_input_add.html"},{"title":"mobbrmsd_input_destroy – mobbrmsd","text":"public pure elemental subroutine mobbrmsd_input_destroy(this) destractor Arguments Type Intent Optional Attributes Name type( mobbrmsd_input ), intent(inout) :: this Contents None","tags":"","loc":"proc/mobbrmsd_input_destroy.html"},{"title":"mol_block_input_add – mobbrmsd","text":"public pure subroutine mol_block_input_add(this, m, n, sym) add molecule Arguments Type Intent Optional Attributes Name type( mol_block_input ), intent(inout), allocatable :: this (:) mol_block_input array integer(kind=IK), intent(in) :: m number of atoms per molecule integer(kind=IK), intent(in) :: n number of molecule integer(kind=IK), intent(in), optional :: sym (:,:) molecular symmetry Contents None","tags":"","loc":"proc/mol_block_input_add.html"},{"title":"mol_block_input_destroy – mobbrmsd","text":"public pure elemental subroutine mol_block_input_destroy(this) destractor Arguments Type Intent Optional Attributes Name type( mol_block_input ), intent(inout) :: this Contents None","tags":"","loc":"proc/mol_block_input_destroy.html"},{"title":"mobbrmsd_run – mobbrmsd","text":"public pure subroutine mobbrmsd_run(header, state, X, Y, W, cutoff, difflim, maxeval, remove_com, sort_by_g) run mobbrmsd Arguments Type Intent Optional Attributes Name type( mobbrmsd_header ), intent(in) :: header mobbrmsd_header type( mobbrmsd_state ), intent(inout) :: state mobbrmsd_state, the result is contained in this structure. real(kind=RK), intent(in) :: X (*) reference coordinate real(kind=RK), intent(in) :: Y (*) target coordinate real(kind=RK), intent(inout), optional :: W (*) work array, must be > header%memsize() real(kind=RK), intent(in), optional :: cutoff The search ends when lowerbound is determined to be greater than to cutoff. real(kind=RK), intent(in), optional :: difflim The search ends when the difference between the lower and upper bounds is less than difflim. integer(kind=IK), intent(in), optional :: maxeval The search ends when ncount exceeds maxiter. logical, intent(in), optional :: remove_com if true, remove centroids. default [.true.] logical, intent(in), optional :: sort_by_g if true, row is sorted respect to G of reference coordinate. default [.true.] Contents None","tags":"","loc":"proc/mobbrmsd_run.html"},{"title":"mobbrmsd_restart – mobbrmsd","text":"public pure subroutine mobbrmsd_restart(header, state, W, cutoff, difflim, maxeval) run mobbrmsd Arguments Type Intent Optional Attributes Name type( mobbrmsd_header ), intent(in) :: header mobbrmsd_header type( mobbrmsd_state ), intent(inout) :: state mobbrmsd_state, the result is contained in this structure. real(kind=RK), intent(inout) :: W (*) work array, must be > header%memsize() real(kind=RK), intent(in), optional :: cutoff The search ends when lowerbound is determined to be greater than to cutoff. real(kind=RK), intent(in), optional :: difflim The search ends when the difference between the lower and upper bounds is less than difflim. integer(kind=IK), intent(in), optional :: maxeval The search ends when ncount exceeds maxiter. Contents None","tags":"","loc":"proc/mobbrmsd_restart.html"},{"title":"mobbrmsd_state_update – mobbrmsd","text":"public pure subroutine mobbrmsd_state_update(this, header, W) update mobbrmsd_state Arguments Type Intent Optional Attributes Name type( mobbrmsd_state ), intent(inout) :: this mobbrmsd header type( mobbrmsd_header ), intent(in) :: header mobbrmsd header real(kind=RK), intent(in) :: W (*) mobbrmsd workarray Contents None","tags":"","loc":"proc/mobbrmsd_state_update.html"},{"title":"mobbrmsd_destroy – mobbrmsd","text":"public pure elemental subroutine mobbrmsd_destroy(this) Arguments Type Intent Optional Attributes Name type( mobbrmsd ), intent(inout) :: this Contents None","tags":"","loc":"proc/mobbrmsd_destroy.html"},{"title":"mobbrmsd – mobbrmsd","text":"public interface mobbrmsd Contents Module Procedures mobbrmsd_new mobbrmsd_new_from_block Module Procedures public pure elemental function mobbrmsd_new (inp) result(res) constructor Arguments Type Intent Optional Attributes Name type( mobbrmsd_input ), intent(in) :: inp mobbrmsd_input Return Value type( mobbrmsd ) public pure function mobbrmsd_new_from_block (blocks) result(res) constructor, from mol_block_input. (for python interface) Arguments Type Intent Optional Attributes Name type( mol_block_input ), intent(in) :: blocks (:) mol_block_input array Return Value type( mobbrmsd )","tags":"","loc":"interface/mobbrmsd.html"},{"title":"mobbrmsd_header_new – mobbrmsd","text":"public pure function mobbrmsd_header_new(q, s) result(res) Returns spatial dimension Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (:) mobbrmsd_header sequence integer(kind=IK), intent(in) :: s (:) mobbrmsd_state template sequence Return Value type( mobbrmsd_header ) Contents None","tags":"","loc":"proc/mobbrmsd_header_new.html"},{"title":"mobbrmsd_header_n_dims – mobbrmsd","text":"public pure elemental function mobbrmsd_header_n_dims(this) result(res) Returns spatial dimension Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/mobbrmsd_header_n_dims.html"},{"title":"mobbrmsd_header_n_block – mobbrmsd","text":"public pure elemental function mobbrmsd_header_n_block(this) result(res) Returns number of molecular blocks Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/mobbrmsd_header_n_block.html"},{"title":"mobbrmsd_header_memsize – mobbrmsd","text":"public pure elemental function mobbrmsd_header_memsize(this) result(res) Returns header_memsize Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/mobbrmsd_header_memsize.html"},{"title":"mobbrmsd_header_n_atoms – mobbrmsd","text":"public pure elemental function mobbrmsd_header_n_atoms(this) result(res) Returns n_atoms Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/mobbrmsd_header_n_atoms.html"},{"title":"mobbrmsd_header_log_n_nodes – mobbrmsd","text":"public pure elemental function mobbrmsd_header_log_n_nodes(this) result(res) Returns log_n_nodes Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value real(kind=RK) Contents None","tags":"","loc":"proc/mobbrmsd_header_log_n_nodes.html"},{"title":"mobbrmsd_header_frac_n_nodes – mobbrmsd","text":"public pure function mobbrmsd_header_frac_n_nodes(this) result(res) returns number of nodes in fraction. Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value real(kind=RK) Contents None","tags":"","loc":"proc/mobbrmsd_header_frac_n_nodes.html"},{"title":"mobbrmsd_header_exp_n_nodes – mobbrmsd","text":"public pure function mobbrmsd_header_exp_n_nodes(this) result(res) returns number of nodes in exp. Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/mobbrmsd_header_exp_n_nodes.html"},{"title":"mobbrmsd_header_state_template – mobbrmsd","text":"public pure function mobbrmsd_header_state_template(this) result(res) dump state template as integer array Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK),allocatable,(:) Contents None","tags":"","loc":"proc/mobbrmsd_header_state_template.html"},{"title":"mobbrmsd_header_dump – mobbrmsd","text":"public pure function mobbrmsd_header_dump(this) result(res) dump header as integer array Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK),allocatable,(:) Contents None","tags":"","loc":"proc/mobbrmsd_header_dump.html"},{"title":"mobbrmsd_header_load – mobbrmsd","text":"public pure subroutine mobbrmsd_header_load(this, q) load integer array as header Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(inout) :: this this integer(kind=IK), intent(in) :: q (:) header array Contents None","tags":"","loc":"proc/mobbrmsd_header_load.html"},{"title":"mobbrmsd_header_destroy – mobbrmsd","text":"public pure elemental subroutine mobbrmsd_header_destroy(this) destructer Arguments Type Intent Optional Attributes Name type( mobbrmsd_header ), intent(inout) :: this Contents None","tags":"","loc":"proc/mobbrmsd_header_destroy.html"},{"title":"mobbrmsd_header – mobbrmsd","text":"public interface mobbrmsd_header Contents Module Procedures mobbrmsd_header_new Module Procedures public pure function mobbrmsd_header_new (q, s) result(res) Returns spatial dimension Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (:) mobbrmsd_header sequence integer(kind=IK), intent(in) :: s (:) mobbrmsd_state template sequence Return Value type( mobbrmsd_header )","tags":"","loc":"interface/mobbrmsd_header.html"},{"title":"mobbrmsd_batch_run – mobbrmsd","text":"public subroutine mobbrmsd_batch_run(n_target, header, state, X, Y, W, cutoff, difflim, maxeval, remove_com, sort_by_g, rotate_y) batch parallel run Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: n_target number of target coordinates type( mobbrmsd_header ), intent(in) :: header mobbrmsd_header type( mobbrmsd_state ), intent(inout) :: state (n_target) mobbrmsd_state, the result is contained in this structure. real(kind=RK), intent(in) :: X (*) reference coordinate real(kind=RK), intent(inout) :: Y (*) target coordinate real(kind=RK), intent(inout) :: W (*) work memory, must be larger than header%memsize() * mobbrmsd_num_threads() real(kind=RK), intent(in), optional :: cutoff The search ends when lowerbound is determined to be greater than to cutoff. real(kind=RK), intent(in), optional :: difflim The search ends when the difference between the lower and upper bounds is less than difflim. integer(kind=IK), intent(in), optional :: maxeval The search ends when ncount exceeds maxiter. logical, intent(in), optional :: remove_com if true, remove centroids. default [.true.] logical, intent(in), optional :: sort_by_g if true, row is sorted respect to G of reference coordinate. default [.true.] logical, intent(in), optional :: rotate_y The search ends when ncount exceeds maxiter. Contents None","tags":"","loc":"proc/mobbrmsd_batch_run.html"},{"title":"mobbrmsd_state_new – mobbrmsd","text":"public pure elemental function mobbrmsd_state_new(header) result(res) returns upperbound Arguments Type Intent Optional Attributes Name type( mobbrmsd_header ), intent(in) :: header mobbrmsd header Return Value type( mobbrmsd_state ) Contents None","tags":"","loc":"proc/mobbrmsd_state_new.html"},{"title":"mobbrmsd_state_upperbound – mobbrmsd","text":"public pure elemental function mobbrmsd_state_upperbound(this) result(res) returns upperbound Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) Contents None","tags":"","loc":"proc/mobbrmsd_state_upperbound.html"},{"title":"mobbrmsd_state_lowerbound – mobbrmsd","text":"public pure elemental function mobbrmsd_state_lowerbound(this) result(res) returns lowerbound Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) Contents None","tags":"","loc":"proc/mobbrmsd_state_lowerbound.html"},{"title":"mobbrmsd_state_autovariance – mobbrmsd","text":"public pure elemental function mobbrmsd_state_autovariance(this) result(res) returns autovariance Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) Contents None","tags":"","loc":"proc/mobbrmsd_state_autovariance.html"},{"title":"mobbrmsd_state_squared_deviation – mobbrmsd","text":"public pure elemental function mobbrmsd_state_squared_deviation(this) result(res) returns squared deviation Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) Contents None","tags":"","loc":"proc/mobbrmsd_state_squared_deviation.html"},{"title":"mobbrmsd_state_mean_squared_deviation – mobbrmsd","text":"public pure elemental function mobbrmsd_state_mean_squared_deviation(this) result(res) returns squared deviation Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) Contents None","tags":"","loc":"proc/mobbrmsd_state_mean_squared_deviation.html"},{"title":"mobbrmsd_state_rmsd – mobbrmsd","text":"public pure elemental function mobbrmsd_state_rmsd(this) result(res) returns rmsd Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) Contents None","tags":"","loc":"proc/mobbrmsd_state_rmsd.html"},{"title":"mobbrmsd_state_lowerbound_as_rmsd – mobbrmsd","text":"public pure elemental function mobbrmsd_state_lowerbound_as_rmsd(this) result(res) returns lowerbound as rmsd Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) Contents None","tags":"","loc":"proc/mobbrmsd_state_lowerbound_as_rmsd.html"},{"title":"mobbrmsd_state_n_eval – mobbrmsd","text":"public pure elemental function mobbrmsd_state_n_eval(this) result(res) returns n_eval Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/mobbrmsd_state_n_eval.html"},{"title":"mobbrmsd_state_eval_ratio – mobbrmsd","text":"public pure elemental function mobbrmsd_state_eval_ratio(this) result(res) returns eval_ratio Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) Contents None","tags":"","loc":"proc/mobbrmsd_state_eval_ratio.html"},{"title":"mobbrmsd_state_log_eval_ratio – mobbrmsd","text":"public pure elemental function mobbrmsd_state_log_eval_ratio(this) result(res) returns log_eval_ratio Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this Return Value real(kind=RK) Contents None","tags":"","loc":"proc/mobbrmsd_state_log_eval_ratio.html"},{"title":"mobbrmsd_state_dump – mobbrmsd","text":"public pure function mobbrmsd_state_dump(this) result(res) dump header as integer array (for python interface api) Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this mobbrmsd_header Return Value integer(kind=IK),allocatable,(:) Contents None","tags":"","loc":"proc/mobbrmsd_state_dump.html"},{"title":"mobbrmsd_state_dump_real – mobbrmsd","text":"public pure function mobbrmsd_state_dump_real(this) result(res) dump header as integer array (for python interface api) Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this mobbrmsd_header Return Value real(kind=RK),allocatable,(:) Contents None","tags":"","loc":"proc/mobbrmsd_state_dump_real.html"},{"title":"mobbrmsd_state_rotation – mobbrmsd","text":"public pure subroutine mobbrmsd_state_rotation(this, header, X) returns eval_ratio Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this type( mobbrmsd_header ), intent(in) :: header mobbrmsd header real(kind=RK), intent(inout) :: X (*) coordinate Contents None","tags":"","loc":"proc/mobbrmsd_state_rotation.html"},{"title":"mobbrmsd_state_load – mobbrmsd","text":"public pure subroutine mobbrmsd_state_load(this, s, z) load integer array as header (for python interface api) Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(inout) :: this mobbrmsd_header integer(kind=IK), intent(in) :: s (:) state integer array real(kind=RK), intent(in) :: z (:) state real array Contents None","tags":"","loc":"proc/mobbrmsd_state_load.html"},{"title":"mobbrmsd_state_destroy – mobbrmsd","text":"public pure elemental subroutine mobbrmsd_state_destroy(this) Arguments Type Intent Optional Attributes Name type( mobbrmsd_state ), intent(inout) :: this Contents None","tags":"","loc":"proc/mobbrmsd_state_destroy.html"},{"title":"mobbrmsd_state – mobbrmsd","text":"public interface mobbrmsd_state Contents Module Procedures mobbrmsd_state_new Module Procedures public pure elemental function mobbrmsd_state_new (header) result(res) returns upperbound Arguments Type Intent Optional Attributes Name type( mobbrmsd_header ), intent(in) :: header mobbrmsd header Return Value type( mobbrmsd_state )","tags":"","loc":"interface/mobbrmsd_state.html"},{"title":"mobbrmsd_min_span_tree – mobbrmsd","text":"public subroutine mobbrmsd_min_span_tree(n_target, header, state, X, W, cutoff, difflim, maxeval, remove_com, sort_by_g, edges, weights, show_progress, verbose) min_span_tree construction Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: n_target number of coordinates type( mobbrmsd_header ), intent(in) :: header mobbrmsd_header type( mobbrmsd_state ), intent(inout) :: state (n_target,n_target) mobbrmsd_state, the result is contained in this structure. real(kind=RK), intent(in) :: X (*) coordinate sequence real(kind=RK), intent(inout) :: W (*) work memory, must be larger than header%memsize() * mobbrmsd_num_threads() real(kind=RK), intent(in), optional :: cutoff The search ends when lowerbound is determined to be greater than to cutoff. real(kind=RK), intent(in), optional :: difflim The search ends when the difference between the lower and upper bounds is less than difflim. integer(kind=IK), intent(in), optional :: maxeval The search ends when ncount exceeds maxiter. logical, intent(in), optional :: remove_com if true, remove centroids. default [.true.] logical, intent(in), optional :: sort_by_g if true, row is sorted respect to G of reference coordinate. default [.true.] integer(kind=IK), intent(out), optional :: edges (2,n_target-1) minimum spanning tree edges real(kind=RK), intent(out), optional :: weights (n_target-1) minimum spanning tree weights logical, intent(in), optional :: show_progress if true, show progress bar logical, intent(in), optional :: verbose show progress bar Contents None","tags":"","loc":"proc/mobbrmsd_min_span_tree.html"},{"title":"bb_block_memsize – mobbrmsd","text":"public pure function bb_block_memsize(q) result(res) Returns the memory size array size. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) bb_block header array. Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/bb_block_memsize.html"},{"title":"bb_block_worksize – mobbrmsd","text":"public pure function bb_block_worksize(q) result(res) Returns the work memory size array size. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header. Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/bb_block_worksize.html"},{"title":"bb_block_nmol – mobbrmsd","text":"public pure function bb_block_nmol(q) result(res) Returns the number of molecules. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header. Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/bb_block_nmol.html"},{"title":"bb_block_natm – mobbrmsd","text":"public pure function bb_block_natm(q) result(res) Returns the number of molecules. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header. Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/bb_block_natm.html"},{"title":"bb_block_molsize – mobbrmsd","text":"public pure function bb_block_molsize(q) result(res) Returns the memory size of molecular block size. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) bb_block header array. Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/bb_block_molsize.html"},{"title":"bb_block_statesize – mobbrmsd","text":"public pure function bb_block_statesize(q) result(res) Returns size of saved state. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header. Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/bb_block_statesize.html"},{"title":"bb_block_is_left – mobbrmsd","text":"public pure function bb_block_is_left(UB, q, s, W) result(res) Returns true when tree is empty Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: UB upper bound integer(kind=IK), intent(in) :: q (*) integer array integer(kind=IK), intent(in) :: s (*) work integer array real(kind=RK), intent(in) :: W (*) main memory Return Value logical Contents None","tags":"","loc":"proc/bb_block_is_left.html"},{"title":"bb_block_tree_is_empty – mobbrmsd","text":"public pure function bb_block_tree_is_empty(q, s) result(res) Returns true when tree is empty Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array integer(kind=IK), intent(in) :: s (*) work integer array Return Value logical Contents None","tags":"","loc":"proc/bb_block_tree_is_empty.html"},{"title":"bb_block_tree_is_finished – mobbrmsd","text":"public pure function bb_block_tree_is_finished(q, s) result(res) Returns true when tree is finished Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array integer(kind=IK), intent(in) :: s (*) work integer array Return Value logical Contents None","tags":"","loc":"proc/bb_block_tree_is_finished.html"},{"title":"bb_block_is_bottom – mobbrmsd","text":"public pure function bb_block_is_bottom(q, s) result(res) Returns true when tree is bottom Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array integer(kind=IK), intent(in) :: s (*) work integer array Return Value logical Contents None","tags":"","loc":"proc/bb_block_is_bottom.html"},{"title":"bb_block_current_level – mobbrmsd","text":"public pure function bb_block_current_level(q, s) result(res) Returns current level. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) work integer array Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/bb_block_current_level.html"},{"title":"bb_block_current_value – mobbrmsd","text":"public pure function bb_block_current_value(q, s, W) result(res) Returns current L value. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array integer(kind=IK), intent(in) :: s (*) work integer array real(kind=RK), intent(in) :: W (*) main memory Return Value real(kind=RK) Contents None","tags":"","loc":"proc/bb_block_current_value.html"},{"title":"bb_block_lowest_value – mobbrmsd","text":"public pure function bb_block_lowest_value(q, s, W) result(res) Returns the minimum value of the surviving nodes, excluding the current value. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state real(kind=RK), intent(in) :: W (*) main memory Return Value real(kind=RK) Contents None","tags":"","loc":"proc/bb_block_lowest_value.html"},{"title":"bb_block_lowerbound – mobbrmsd","text":"public pure function bb_block_lowerbound(W) result(res) Returns the minimum value of the surviving nodes, excluding the current value. Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: W (*) main memory Return Value real(kind=RK) Contents None","tags":"","loc":"proc/bb_block_lowerbound.html"},{"title":"bb_block_evaluation_count – mobbrmsd","text":"public pure function bb_block_evaluation_count(W) result(res) Returns the minimum value of the surviving nodes, excluding the current value. Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: W (*) main memory Return Value real(kind=RK) Contents None","tags":"","loc":"proc/bb_block_evaluation_count.html"},{"title":"bb_block_log_ncomb – mobbrmsd","text":"public pure function bb_block_log_ncomb(q) result(res) Returns the minimum value of the surviving nodes, excluding the current value. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array Return Value real(kind=RK) Contents None","tags":"","loc":"proc/bb_block_log_ncomb.html"},{"title":"bb_block_autocorr – mobbrmsd","text":"public pure function bb_block_autocorr(q, W) result(res) Returns the minimum value of the surviving nodes, excluding the current value. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header real(kind=RK), intent(in) :: W (*) main memory Return Value real(kind=RK) Contents None","tags":"","loc":"proc/bb_block_autocorr.html"},{"title":"bb_block_setup – mobbrmsd","text":"public pure subroutine bb_block_setup(q, X, Y, CX, CY, s, W, zfill, sort_by_g) Setup C matrix and F matrix in root node. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array real(kind=RK), intent(in) :: X (*) reference coordinate real(kind=RK), intent(in) :: Y (*) target coordinate real(kind=RK), intent(in) :: CX (*) centroid of X real(kind=RK), intent(in) :: CY (*) centroid of Y integer(kind=IK), intent(inout) :: s (*) integer work array real(kind=RK), intent(inout) :: W (*) work integer array logical, intent(in) :: zfill if true, the root node is filled by zero. logical, intent(in), optional :: sort_by_g if true, row is sorted respect to G of reference coordinate. Contents None","tags":"","loc":"proc/bb_block_setup.html"},{"title":"bb_block_inheritance – mobbrmsd","text":"public pure subroutine bb_block_inheritance(q, s, W, p, r, Z) Expands the latest node of the parent block to the top-level queue of the child block. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) work integer array integer(kind=IK), intent(inout) :: s (*) work integer array real(kind=RK), intent(inout) :: W (*) main memory integer(kind=IK), intent(in) :: p (*) parent integer array integer(kind=ik), intent(in) :: r (*) parent integer work array real(kind=RK), intent(in) :: Z (*) parent work array Contents None","tags":"","loc":"proc/bb_block_inheritance.html"},{"title":"bb_block_expand – mobbrmsd","text":"public pure subroutine bb_block_expand(UB, q, s, W) Expand top node in queue. Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: UB upper bound integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(inout) :: s (*) state real(kind=RK), intent(inout) :: W (*) main memory Contents None","tags":"","loc":"proc/bb_block_expand.html"},{"title":"bb_block_closure – mobbrmsd","text":"public pure subroutine bb_block_closure(UB, q, s, W) closure current node. Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: UB upper bound integer(kind=IK), intent(in) :: q (*) work integer array integer(kind=IK), intent(inout) :: s (*) work integer array real(kind=RK), intent(in) :: W (*) Contents None","tags":"","loc":"proc/bb_block_closure.html"},{"title":"bb_block_set_ub_offset – mobbrmsd","text":"public pure subroutine bb_block_set_ub_offset(W, ubofs) Set ub offset value Arguments Type Intent Optional Attributes Name real(kind=RK), intent(inout) :: W (*) main memory real(kind=RK), intent(in) :: ubofs main memory Contents None","tags":"","loc":"proc/bb_block_set_ub_offset.html"},{"title":"bb_block_save_state – mobbrmsd","text":"public pure subroutine bb_block_save_state(q, s, z) Save current state. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array integer(kind=IK), intent(in) :: s (*) state vector integer(kind=IK), intent(inout) :: z (*) memory Contents None","tags":"","loc":"proc/bb_block_save_state.html"},{"title":"bb_block_swap_y – mobbrmsd","text":"public pure subroutine bb_block_swap_y(q, s, z, Y) swap Y by saved state z. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state integer(kind=IK), intent(in) :: z (*) saved state (not state vector) real(kind=RK), intent(inout) :: Y (*) target coordinate Contents None","tags":"","loc":"proc/bb_block_swap_y.html"},{"title":"bb_block_covmat_add – mobbrmsd","text":"public pure subroutine bb_block_covmat_add(q, z, W, G, C) Sum covariance matrix by saved state z. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array integer(kind=IK), intent(in) :: z (*) saved state (not state vector) real(kind=RK), intent(in) :: W (*) main memory real(kind=RK), intent(inout) :: G autovariance real(kind=RK), intent(inout) :: C (*) covariance matrix Contents None","tags":"","loc":"proc/bb_block_covmat_add.html"},{"title":"bb_block – mobbrmsd","text":"public interface bb_block Contents Module Procedures bb_block_new Module Procedures private pure function bb_block_new(n_apm, n_mol, sym) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: n_apm number of molecules. integer(kind=IK), intent(in) :: n_mol number of atoms per molecule. integer(kind=IK), intent(in), optional :: sym (:,:) symmetric codomains, [[a1,a2,...,am], [b1,b2,...,bm], ...]. Return Value type( bb_block )","tags":"","loc":"interface/bb_block.html"},{"title":"setup_dimension – mobbrmsd","text":"public subroutine setup_dimension(d_) Sets the dimensions of the space. This is dummy interface. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d_ Contents None","tags":"","loc":"proc/setup_dimension.html"},{"title":"compute_com – mobbrmsd","text":"public pure subroutine compute_com(d, n, X, C) Calculate center of mass for Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(inout) :: C (d) Contents None","tags":"","loc":"proc/compute_com.html"},{"title":"compute_cov – mobbrmsd","text":"public pure subroutine compute_cov(d, n, X, Y, C) Calculate covariance matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(in) :: Y (d,*) real(kind=RK), intent(inout) :: C (d,d) Contents None","tags":"","loc":"proc/compute_cov.html"},{"title":"covcopy – mobbrmsd","text":"public pure subroutine covcopy(d, n, X, CX, Y) Compute for Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(in) :: CX (d) real(kind=RK), intent(inout) :: Y (d,*) Contents None","tags":"","loc":"proc/covcopy.html"},{"title":"sdmin_worksize – mobbrmsd","text":"public pure elemental function sdmin_worksize() result(res) Inquire function for memory size of estimate_sdmin. Arguments None Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/sdmin_worksize.html"},{"title":"rotation_worksize – mobbrmsd","text":"public pure elemental function rotation_worksize() result(res) Inquire function for memory size of rotation. Arguments None Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/rotation_worksize.html"},{"title":"estimate_rcmax – mobbrmsd","text":"public pure subroutine estimate_rcmax(g, cov, w) Compute . Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g sum of auto covariance matrix real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_sdmin(). Contents None","tags":"","loc":"proc/estimate_rcmax.html"},{"title":"estimate_sdmin – mobbrmsd","text":"public pure subroutine estimate_sdmin(g, cov, w) Compute the least-squares sum_i&#94;n |x_i-Ry_i|&#94;2 from cov = YX&#94;T and g = tr[XX&#94;T] + tr[YY&#94;T]. Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g sum of auto covariance matrix real(kind=RK), intent(in) :: cov (*) target d*d array real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_sdmin(). Contents None","tags":"","loc":"proc/estimate_sdmin.html"},{"title":"estimate_rotation – mobbrmsd","text":"public pure subroutine estimate_rotation(g, cov, rot, w) Compute the transpose rotation matrix for minimize tr[CR] from cov = YX&#94;T and g = tr[XX&#94;T] + tr[YY&#94;T]. Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g g = tr[XX&#94;T] + tr[YY&#94;T] real(kind=RK), intent(in) :: cov (*) covariance dxd matrix, YX&#94;T real(kind=RK), intent(inout) :: rot (*) rotation dxd matrix real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_rotation(). Contents None","tags":"","loc":"proc/estimate_rotation.html"},{"title":"setup_dimension – mobbrmsd","text":"public subroutine setup_dimension(d_) Sets the dimensions of the space. Caution, this routine affects global. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d_ Contents None","tags":"","loc":"proc/setup_dimension~2.html"},{"title":"compute_com – mobbrmsd","text":"public pure subroutine compute_com(d, n, X, C) Calculate center of mass for Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(inout) :: C (d) Contents None","tags":"","loc":"proc/compute_com~2.html"},{"title":"compute_cov – mobbrmsd","text":"public pure subroutine compute_cov(d, n, X, Y, C) Calculate covariance matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(in) :: Y (d,*) real(kind=RK), intent(inout) :: C (d,d) Contents None","tags":"","loc":"proc/compute_cov~2.html"},{"title":"covcopy – mobbrmsd","text":"public pure subroutine covcopy(d, n, X, CX, Y) Compute for Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(in) :: CX (d) real(kind=RK), intent(inout) :: Y (d,*) Contents None","tags":"","loc":"proc/covcopy~2.html"},{"title":"sdmin_worksize – mobbrmsd","text":"public pure elemental function sdmin_worksize() result(res) Inquire function for memory size of estimate_sdmin. Arguments None Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/sdmin_worksize~2.html"},{"title":"rotation_worksize – mobbrmsd","text":"public pure elemental function rotation_worksize() result(res) Inquire function for memory size of rotation. Arguments None Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/rotation_worksize~2.html"},{"title":"estimate_rcmax – mobbrmsd","text":"public pure subroutine estimate_rcmax(g, cov, w) Compute . Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g sum of auto covariance matrix real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_sdmin(). Contents None","tags":"","loc":"proc/estimate_rcmax~2.html"},{"title":"estimate_sdmin – mobbrmsd","text":"public pure subroutine estimate_sdmin(g, cov, w) Compute the least-squares sum_i&#94;n |x_i-Ry_i|&#94;2 from cov = YX&#94;T and g = tr[XX&#94;T] + tr[YY&#94;T]. Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g sum of auto covariance matrix real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_sdmin(). Contents None","tags":"","loc":"proc/estimate_sdmin~2.html"},{"title":"estimate_rotation – mobbrmsd","text":"public pure subroutine estimate_rotation(g, cov, rot, w) Compute the transpose rotation matrix for minimize tr[CR] from cov = YX&#94;T and g = tr[XX&#94;T] + tr[YY&#94;T].\n This subroutine is based on the method of Coutsias et.al. 10.1002/jcc.25802 Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g g = tr[XX&#94;T] + tr[YY&#94;T] real(kind=RK), intent(in) :: cov (*) covariance dxd matrix, YX&#94;T real(kind=RK), intent(inout) :: rot (*) rotation dxd matrix real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_rotation(). Contents None","tags":"","loc":"proc/estimate_rotation~2.html"},{"title":"setup_dimension – mobbrmsd","text":"public subroutine setup_dimension(d_) Sets the dimensions of the space. Caution, this routine affects global. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d_ Contents None","tags":"","loc":"proc/setup_dimension~3.html"},{"title":"compute_com – mobbrmsd","text":"public pure subroutine compute_com(d, n, X, C) Calculate center of mass. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(inout) :: C (d) Contents None","tags":"","loc":"proc/compute_com~3.html"},{"title":"compute_cov – mobbrmsd","text":"public pure subroutine compute_cov(d, n, X, Y, C) Calculate covariance matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(in) :: Y (d,*) real(kind=RK), intent(inout) :: C (d,d) Contents None","tags":"","loc":"proc/compute_cov~3.html"},{"title":"covcopy – mobbrmsd","text":"public pure subroutine covcopy(d, n, X, CX, Y) Compute . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(in) :: CX (d) real(kind=RK), intent(inout) :: Y (d,*) Contents None","tags":"","loc":"proc/covcopy~3.html"},{"title":"sdmin_worksize – mobbrmsd","text":"public pure elemental function sdmin_worksize() result(res) Inquire function for memory size of estimate_sdmin. Arguments None Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/sdmin_worksize~3.html"},{"title":"rotation_worksize – mobbrmsd","text":"public pure elemental function rotation_worksize() result(res) Inquire function for memory size of estimate_rotation(). Arguments None Return Value integer(kind=IK) Contents None","tags":"","loc":"proc/rotation_worksize~3.html"},{"title":"estimate_rcmax – mobbrmsd","text":"public pure subroutine estimate_rcmax(g, cov, w) Compute . Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g sum of auto covariance matrix real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_sdmin(). Contents None","tags":"","loc":"proc/estimate_rcmax~3.html"},{"title":"estimate_sdmin – mobbrmsd","text":"public pure subroutine estimate_sdmin(g, cov, w) Compute ,\n where Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g sum of auto covariance matrix real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_sdmin(). Contents None","tags":"","loc":"proc/estimate_sdmin~3.html"},{"title":"estimate_rotation – mobbrmsd","text":"public pure subroutine estimate_rotation(g, cov, rot, w) Compute the transpose of rotation matrix that maximize . Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g . real(kind=RK), intent(in) :: cov (*) covariance matrix rotation real(kind=RK), intent(inout) :: rot (*) rotation matrix, . real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_rotation(). Contents None","tags":"","loc":"proc/estimate_rotation~3.html"},{"title":"mod_f_matrix – mobbrmsd","text":"Module for managing free rotation cost matrix, . :: Covariance matrix of and with -th molecular permutation. :: Rotation matrix on . Uses mod_Hungarian mod_params mod_c_matrix mod_rotation mod_mol_block mod_dimspec_functions Contents Interfaces f_matrix Derived Types f_matrix Functions f_matrix_memsize f_matrix_worksize Subroutines f_matrix_eval Interfaces public interface f_matrix Constructer private pure function f_matrix_new(b) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: b (*) mol_block, must be initialized Return Value type( f_matrix ) Derived Types type, public :: f_matrix F matrix manager.\n This derived type is mainly used for passing during initialization. Constructor Constructer private pure function f_matrix_new (b) Constructer Functions public pure function f_matrix_memsize (q) result(res) Inquire memsize of f_matrix Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) f_matrix Return Value integer(kind=IK) public pure function f_matrix_worksize (q) result(res) Inquire worksize of f_matrix Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) f_matrix Return Value integer(kind=IK) Subroutines public pure subroutine f_matrix_eval (q, qc, C, F, W) Evaluation the D matrix Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header of f_matrix integer(kind=IK), intent(in) :: qc (*) header of covariacne matrix C. real(kind=RK), intent(inout) :: C (*) covariacne matrix c. real(kind=RK), intent(inout) :: F (*) main memory of F. real(kind=RK), intent(inout) :: W (*) work array.","tags":"","loc":"module/mod_f_matrix.html"},{"title":"mod_mol_block – mobbrmsd","text":"Module for molecular coodinate block indicator. Coordinates must be stored in the 3-D array, X(d, n, M). - :: spatial dimension. - :: number of atom in a molecule. - :: number of molecule. Uses mod_group_permutation mod_params mod_dimspec_functions Contents Interfaces mol_block Derived Types mol_block Functions mol_block_natm mol_block_nmol mol_block_napm mol_block_nsym mol_block_each_size mol_block_total_size Subroutines mol_block_swap mol_block_inverse_swap Interfaces public interface mol_block private pure function mol_block_new(n, M, sym) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: n number of atoms per molecule integer(kind=IK), intent(in) :: M number of molecules integer(kind=IK), intent(in), optional :: sym (:,:) symmetric codomains, sym(n, S) Return Value type( mol_block ) Derived Types type, public, sequence  :: mol_block molecular block\n This is mainly used for passing during initialization. Constructor private pure function mol_block_new (n, M, sym) Constructer Functions public pure function mol_block_natm (q) result(res) number of atoms, defined by . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) mol_block Return Value integer(kind=IK) public pure function mol_block_nmol (q) result(res) number of molecules, . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) mol_block Return Value integer(kind=IK) public pure function mol_block_napm (q) result(res) number of atoms per molecule, Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) mol_block Return Value integer(kind=IK) public pure function mol_block_nsym (q) result(res) number of molecular symmetry, . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) mol_block Return Value integer(kind=IK) public pure function mol_block_each_size (q) result(res) memory blocksize per molecule, defined by . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) mol_block Return Value integer(kind=IK) public pure function mol_block_total_size (q) result(res) memory blocksize, defined by . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) mol_block Return Value integer(kind=IK) Subroutines public pure subroutine mol_block_swap (q, isym, X) Compute molecular symmetry permutation according to isym. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) mol_block integer(kind=IK), intent(in) :: isym symmetry id real(kind=RK), intent(inout) :: X (*) work array public pure subroutine mol_block_inverse_swap (q, isym, X) Compute molecular symmetry inverse permutation according to isym. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) mol_block integer(kind=IK), intent(in) :: isym symmetry id. real(kind=RK), intent(inout) :: X (*) work array","tags":"","loc":"module/mod_mol_block.html"},{"title":"mod_group_permutation – mobbrmsd","text":"Module for order permutation by decomposed cyclic groups. This module provides swap operations on sequences equivalent to X(:, :) = X(:, perm(:)). A given swap index perm(:) is decomposed into periodic substitutions. Note group permutations are encoded in header integer array, in the following. :: number of permutation. :: pointer to to . is equiv to Swap indeces are stored in work array, in the following. :: number of order - 1. :: pointer to . :: body. body is constructed as follows. :: number of permutation. :: order of cycle. :: mapping sequence, . - memsize is Uses mod_params Contents Interfaces group_permutation Derived Types group_permutation Functions group_permutation_nsym Subroutines group_permutation_swap group_permutation_inverse Interfaces public interface group_permutation private pure function group_permutation_new(perm) result(res) Constructor. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in), optional :: perm (:,:) codomains, [[a1,a2,...,am],[b1,b2,...,bm],...]. Return Value type( group_permutation ) return value. Derived Types type, public :: group_permutation A structure that references an array representing a replacement operation. It is possible to hold s permutation mapping of starting from [1,2,...,N].\n This is mainly used for passing during initialization. Constructor private pure function group_permutation_new (perm) Constructor. Finalizations Procedures final :: group_permutation_destroy Functions public pure function group_permutation_nsym (q) result(res) nsym of group_permutation Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) work array. Return Value integer(kind=IK) Subroutines public pure subroutine group_permutation_swap (q, s, d, X) Replaces an array of real numbers according to the map s. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) work array. integer(kind=IK), intent(in) :: s permutation index. integer(kind=IK), intent(in) :: d leading dimension of x real(kind=RK), intent(inout) :: X (*) data array. public pure subroutine group_permutation_inverse (q, s, d, X) Replaces an array of real numbers according to the inverse map s. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) work array. integer(kind=IK), intent(in) :: s permutation index. integer(kind=IK), intent(in) :: d leading dimension of x real(kind=RK), intent(inout) :: X (*) data array.","tags":"","loc":"module/mod_group_permutation.html"},{"title":"mod_kinds – mobbrmsd","text":"variable kinds correction Uses iso_fortran_env Contents Variables IK RK Variables Type Visibility Attributes Name Initial integer, public, parameter :: IK = KIND(0) Selected integer kind. integer, public, parameter :: RK = KIND(0.0_R8) Selected real kind.","tags":"","loc":"module/mod_kinds.html"},{"title":"mod_c_matrix – mobbrmsd","text":"A module for managing c-matrices, tensor of covariance matrices. is third-order ( ) tensor of matrix ,\n defined by :: -th molecule in reference coordinate, . :: -th molecule in target coordinate, . :: Molecular permutation matrix on . To quickly find the rotation matrix, is stored with autocorrelation , defined by Note does not change with respect to molecular symmetry permutation index, . Therefore, data blocks are stored in three-dimensional array C(bs,M,M)\n   with the leading dimension with . Data blocks are defined by Uses mod_params mod_mol_block mod_dimspec_functions Contents Interfaces c_matrix Derived Types c_matrix Functions c_matrix_blocksize c_matrix_memsize c_matrix_worksize Subroutines c_matrix_eval c_matrix_autocorr c_matrix_add c_matrix_swap_indices Interfaces public interface c_matrix Constructer private pure function c_matrix_new(b) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: b (*) mol_block header, must be initialized. Return Value type( c_matrix ) Derived Types type, public :: c_matrix C matrix manager.\n  This derived type is mainly used for passing during initialization. Constructor Constructer private pure function c_matrix_new (b) Constructer Finalizations Procedures final :: c_matrix_destroy Functions public pure function c_matrix_blocksize (q) result(res) Inquire blocksize of c_matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) c_matrix header. Return Value integer(kind=IK) public pure function c_matrix_memsize (q) result(res) Inquire memsize of c_matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) c_matrix header. Return Value integer(kind=IK) public pure function c_matrix_worksize (q) result(res) Inquire worksize of c_matrix evaluation. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) c_matrix header. Return Value integer(kind=IK) Subroutines public pure subroutine c_matrix_eval (q, b, s, X, Y, CX, CY, C, W, sort_by_g) Evaluation the c-matrix. g-matrix is also calculated at the same time. At the end of the calculation, save the c-matrix C(cb,M,M) to C(*). workarray W(*) must be larger than c_matrix_worksize(q). Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) c_matrix header. integer(kind=IK), intent(in) :: b (*) mol block header. integer(kind=IK), intent(inout) :: s (*) swap_indice real(kind=RK), intent(in) :: X (*) reference coordinate, real(kind=RK), intent(in) :: Y (*) target coordinate, real(kind=RK), intent(in) :: CX (*) centroid of . real(kind=RK), intent(in) :: CY (*) centroid of . real(kind=RK), intent(inout) :: C (*) main memory real(kind=RK), intent(inout) :: W (*) work memory logical, intent(in), optional :: sort_by_g if true, row is sorted respect to G of reference coordinate. public pure subroutine c_matrix_autocorr (q, C, G) Calc . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) c_matrix real(kind=RK), intent(in) :: C (*) main memory, calculated by c_matrix_eval. real(kind=RK), intent(inout) :: G partial covariance matrix, must be larger than . public pure subroutine c_matrix_add (q, i, j, s, C, G, Cp) Adds and specified by index to the arguments. This routine adds directly to G and C(:DD), so they must be initialized. If indices outside the area defined by q(*) is specified, operation results are not guaranteed. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) c_matrix integer(kind=IK), intent(in) :: i row index integer(kind=IK), intent(in) :: j collumn index integer(kind=IK), intent(in) :: s symmetry index real(kind=RK), intent(in) :: C (*) main memory, calculated by c_matrix_eval. real(kind=RK), intent(inout) :: G partial auto variance matrix. real(kind=RK), intent(inout) :: Cp (*) partial covariance matrix, must be larger than . public pure subroutine c_matrix_swap_indices (q, s, z, res) returns swap(z) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state integer(kind=IK), intent(in) :: z (*) permutation integer(kind=IK), intent(inout) :: res (*) swap indice","tags":"","loc":"module/mod_c_matrix.html"},{"title":"mod_bb_list – mobbrmsd","text":"Manage multiple bb_blocks and execute multi-component Branch-and-Bound. Uses mod_rotation mod_bb_block mod_params mod_dimspec_functions Contents Variables bb_list_INDEX_TO_AUTOCORR bb_list_INDEX_TO_UPPERBOUND bb_list_INDEX_TO_LOWERBOUND bb_list_INDEX_TO_N_EVAL bb_list_INDEX_TO_LOG_N_COMB Interfaces bb_list Derived Types bb_list Functions bb_list_memsize bb_list_n_block bb_list_n_atoms bb_list_log_n_nodes bb_list_is_finished Subroutines bb_list_setup bb_list_run bb_list_swap_y bb_list_rotation_matrix Variables Type Visibility Attributes Name Initial integer(kind=IK), public, parameter :: bb_list_INDEX_TO_AUTOCORR = 1 integer(kind=IK), public, parameter :: bb_list_INDEX_TO_UPPERBOUND = 2 integer(kind=IK), public, parameter :: bb_list_INDEX_TO_LOWERBOUND = 3 integer(kind=IK), public, parameter :: bb_list_INDEX_TO_N_EVAL = 4 integer(kind=IK), public, parameter :: bb_list_INDEX_TO_LOG_N_COMB = 5 Interfaces public interface bb_list Constructer private pure function bb_list_new(blk) result(res) Constructer Arguments Type Intent Optional Attributes Name type( bb_block ), intent(in) :: blk (:) Return Value type( bb_list ) Derived Types type, public :: bb_list This derived type is mainly used for passing during initialization. Constructor Constructer private pure function bb_list_new (blk) Constructer Finalizations Procedures final :: bb_list_destroy Functions public pure function bb_list_memsize (q) result(res) Inquire worksize of f_matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) bb_block. Return Value integer(kind=IK) public pure function bb_list_n_block (q) result(res) Returns number of molecular blocks. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) bb_block. Return Value integer(kind=IK) public pure function bb_list_n_atoms (q) result(res) Returns number of total atoms. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) bb_block. Return Value integer(kind=IK) public pure function bb_list_log_n_nodes (q) result(res) Returns the logarithm of the total number of nodes. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) bb_block. Return Value real(kind=RK) public pure function bb_list_is_finished (q, s) result(res) Returns bb is finished. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical Subroutines public pure subroutine bb_list_setup (q, s, X, Y, W, remove_com, sort_by_g) Setup Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(inout) :: s (*) state real(kind=RK), intent(in) :: X (*) reference coordinate real(kind=RK), intent(in) :: Y (*) target coordinate real(kind=RK), intent(inout) :: W (*) work array logical, intent(in), optional :: remove_com if true, remove centroids. default [.true.] logical, intent(in), optional :: sort_by_g if true, row is sorted respect to G of reference coordinate. default [.true.] public pure subroutine bb_list_run (q, s, W, cutoff, difflim, maxeval) run branch and bound Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(inout) :: s (*) state real(kind=RK), intent(inout) :: W (*) work array real(kind=RK), intent(in), optional :: cutoff The search ends when lowerbound is determined real(kind=RK), intent(in), optional :: difflim The search ends when the difference integer(kind=IK), intent(in), optional :: maxeval The search ends when ncount exceeds maxiter. public pure subroutine bb_list_swap_y (q, s, Y) Swap target coordinate. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state real(kind=RK), intent(inout) :: Y (*) target coordinate public pure subroutine bb_list_rotation_matrix (q, s, W, R) Sum covariance matrix by saved state z. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array integer(kind=IK), intent(in) :: s (*) state real(kind=RK), intent(in) :: W (*) main memory real(kind=RK), intent(inout) :: R (*) rotation matrix","tags":"","loc":"module/mod_bb_list.html"},{"title":"mod_tree – mobbrmsd","text":"Factorial tree for branch and bound. This structure handles factorial trees with nodes of constant memory size, ld. The factorial tree is completely defined by the number of level and a constant .\n  A node in level has childs,\n  and each level has nodes.\n  Here, only nodes for level are kept as state vector.\n  All other information is discarded. The tree informations are kept by header q(*) and state vector s(*). Note q(*) constant and should be treated as an immutable variable. However, it is defined as an integer array\n  so that it can be treated as part of a data structure\n  at a higher level imprementation. The tree type has states and ,\n  where is the current level\n  and is the selected node indices.\n  Let be current node,\n  and a retained nodes belonging to is defined as a -queue. A -queue has one of the following states,\n  corresponding to the state of the current node. - Node is selected :: - -queue is unexplored :: - -queue is explored :: The real data is kept in an external heap in the form W(ld, *).\n  The value stored in W(1, *) is treated as a node evaluation value.\n  (to be implemented by the user). Note W can be updated dynamically,\n  but changes to the memory referenced by nodes\n  in the hierarchy below will destroy the tree structure.\n  The user should control when to update W. Uses mod_params Contents Interfaces tree Derived Types tree Functions tree_nnodes tree_current_level tree_current_state tree_current_nnodes tree_current_iper tree_current_isym tree_queue_pointer tree_current_pointer tree_node_pointer tree_current_sequence tree_current_permutation tree_sequence_to_permutation tree_current_mapping tree_sequence_to_mapping tree_lowest_value tree_n_sym tree_n_perm tree_n_depth tree_log_ncomb tree_ncomb_frac tree_ncomb_exp tree_queue_is_unexplored tree_queue_is_explored tree_is_empty tree_is_unexplored tree_queue_is_empty tree_queue_is_selected tree_queue_is_left tree_queue_is_root tree_queue_is_bottom Subroutines tree_reset tree_expand tree_leave tree_select_top_node Interfaces public interface tree private pure function tree_new(nmol, nsym) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: nmol number of molecule integer(kind=IK), intent(in) :: nsym number of molecular symmetry Return Value type( tree ) Derived Types type, public :: tree Factorial tree. Read more… Constructor private pure function tree_new (nmol, nsym) Constructer Finalizations Procedures final :: tree_destroy Functions public pure function tree_nnodes (q) result(res) Inquire number of nodes,\n defined by . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header Return Value integer(kind=IK) public pure function tree_current_level (s) result(res) Returns current level, . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK) public pure function tree_current_state (s) result(res) Returns the state of current node, . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK) public pure function tree_current_nnodes (q, s) result(res) Returns the number of nodes in -queue. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK) public pure function tree_current_iper (q, s) result(res) Returns current permutation indices of . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK) public pure function tree_current_isym (q, s) result(res) Returns current mapping index of . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK) public pure function tree_queue_pointer (q, s) result(res) Returns a pointer to the current queue. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK) public pure function tree_current_pointer (q, s) result(res) Returns a pointer to the current node, . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK) public pure function tree_node_pointer (q, s, iper, isym) result(res) Returns a pointer to a node specified by iper, isym. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state integer(kind=IK), intent(in) :: iper permutation index, must be [0,1,...,q%n/s-1]. integer(kind=IK), intent(in) :: isym mapping index, must be [0,1,...,s-1]. Return Value integer(kind=IK) public pure function tree_current_sequence (q, s) result(res) Returns current sequence indices. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK)(q(qd)) public pure function tree_current_permutation (q, s) result(res) Returns current permutation indices. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK)(q(qd)) public pure function tree_sequence_to_permutation (q, z) result(res) Convert sequence to permutation. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: z (*) state Return Value integer(kind=IK)(q(qd)) public pure function tree_current_mapping (q, s) result(res) Returns current mapping indices. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK)(q(qd)) public pure function tree_sequence_to_mapping (q, z) result(res) Convert sequence to mapping. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: z (*) state Return Value integer(kind=IK)(q(qd)) public pure function tree_lowest_value (q, s, ld, W) result(res) Returns the minimum value of the surviving nodes, excluding the current value.\n If tree is empty, Returns -infty. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state integer(kind=IK), intent(in) :: ld leading dimension real(kind=RK), intent(in) :: W (ld,*) work array Return Value real(kind=RK) public pure function tree_n_sym (q) result(res) Returns number of symmetry in queue. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header Return Value integer(kind=IK) public pure function tree_n_perm (q, s) result(res) Returns number of permutation in queue. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value integer(kind=IK) public pure function tree_n_depth (q) result(res) Returns number tree depth (without root node). Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header Return Value integer(kind=IK) public pure function tree_log_ncomb (q) result(res) Returns number of nodes in tree. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header Return Value real(kind=RK) public pure function tree_ncomb_frac (q) result(res) Returns number of nodes in fraction. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header Return Value real(kind=RK) public pure function tree_ncomb_exp (q) result(res) Returns number of nodes in exp. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header Return Value integer(kind=IK) public pure function tree_queue_is_unexplored (q, s) result(res) Returns true if current node is unexplored. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical public pure function tree_queue_is_explored (q, s) result(res) Returns true if current node is explored. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical public pure function tree_is_empty (q, s) result(res) Returns true if -queue is empty. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical public pure function tree_is_unexplored (q, s) result(res) Returns true if tree is unexplored. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical public pure function tree_queue_is_empty (q, s) result(res) Returns true if -queue is explored. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical public pure function tree_queue_is_selected (q, s) result(res) Returns true if -queue has current node. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical public pure function tree_queue_is_left (q, s, ld, UB, W) result(res) Returns true if -queue has an unexplored node other than the selected node. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state integer(kind=IK), intent(in) :: ld leading dimension real(kind=RK), intent(in) :: UB upperbound real(kind=RK), intent(in) :: W (ld,*) work array Return Value logical public pure function tree_queue_is_root (q, s) result(res) Returns true if . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical public pure function tree_queue_is_bottom (q, s) result(res) Returns true if . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state Return Value logical Subroutines public pure subroutine tree_reset (q, s) Reset the state Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(inout) :: s (*) state public pure subroutine tree_expand (q, s) Expand current node. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(inout) :: s (*) state public pure subroutine tree_leave (q, s) Leave current node. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(inout) :: s (*) state public pure subroutine tree_select_top_node (q, s, ld, UB, W) Select top node, using W(1, *). Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(inout) :: s (*) state integer(kind=IK), intent(in) :: ld leading dimension real(kind=RK), intent(in) :: UB upperbound real(kind=RK), intent(in) :: W (ld,*) work array","tags":"","loc":"module/mod_tree.html"},{"title":"mod_params – mobbrmsd","text":"Module with constant collection. Uses mod_kinds Contents Variables RZERO RONE RHALF RFOUR RTEN RPI RNAPIER RHUGE LN_TO_L10 Variables Type Visibility Attributes Name Initial real(kind=RK), public, parameter :: RZERO = 0.0_RK Real zero. real(kind=RK), public, parameter :: RONE = 1.0_RK Real one. real(kind=RK), public, parameter :: RHALF = 0.5_RK Real 1/2. real(kind=RK), public, parameter :: RFOUR = 4.0_RK Real four. real(kind=RK), public, parameter :: RTEN = 10.0_RK Real ten. real(kind=RK), public, parameter :: RPI = ACOS(RZERO) Real circular constant. real(kind=RK), public, parameter :: RNAPIER = 2.71828182846_RK Napier constant. real(kind=RK), public, parameter :: RHUGE = HUGE(RZERO) Real large numbe real(kind=RK), public, parameter :: LN_TO_L10 = LOG10(RNAPIER) Scaling factor, LOG10(x) =LN_TO_L10 * LN(x)","tags":"","loc":"module/mod_params.html"},{"title":"mod_Hungarian – mobbrmsd","text":"Calculate the minimum linear assignment cost using Hungarian method. Uses mod_params Contents Functions Hungarian_worksize Subroutines Hungarian Functions public pure elemental function Hungarian_worksize (m, n) result(res) query work array size Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: m matrix dimension 1. integer(kind=IK), intent(in) :: n matrix dimension 2. Return Value integer(kind=IK) Subroutines public pure subroutine Hungarian (m, n, C, W) Calculate the minimum linear assignment cost using Hungarian method.\n If m and n are different, the sum of the linear assignments of the smaller is returned.\n If m>0 and n>0, W(1) stores the minimum linear assignment cost.\n If m==0 or n==0, do nothing.\n If (m<0 or n<0) and (|m|>0 and |n|>0), W(1) stores the required memory size for C(|m|,|n|). Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: m matrix dimension 1. integer(kind=IK), intent(in) :: n matrix dimension 2. real(kind=RK), intent(in) :: C (*) score matrix C(m, n). real(kind=RK), intent(inout) :: W (*) work array.","tags":"","loc":"module/mod_hungarian.html"},{"title":"mod_mobbrmsd – mobbrmsd","text":"molecular orientation corrected RMSD with branch-and-bound. Uses mod_bb_list mod_mobbrmsd_state mod_params mod_mobbrmsd_header mod_bb_block mod_dimspec_functions Contents Interfaces mobbrmsd Derived Types mobbrmsd_input mol_block_input mobbrmsd Functions mobbrmsd_new mobbrmsd_new_from_block mobbrmsd_is_finished Subroutines mobbrmsd_input_add mobbrmsd_input_destroy mol_block_input_add mol_block_input_destroy mobbrmsd_run mobbrmsd_restart mobbrmsd_state_update mobbrmsd_destroy Interfaces public interface mobbrmsd public pure elemental function mobbrmsd_new (inp) result(res) constructor Arguments Type Intent Optional Attributes Name type( mobbrmsd_input ), intent(in) :: inp mobbrmsd_input Return Value type( mobbrmsd ) public pure function mobbrmsd_new_from_block (blocks) result(res) constructor, from mol_block_input. (for python interface) Arguments Type Intent Optional Attributes Name type( mol_block_input ), intent(in) :: blocks (:) mol_block_input array Return Value type( mobbrmsd ) Derived Types type, public :: mobbrmsd_input mobbrmsd_input Components Type Visibility Attributes Name Initial type( mol_block_input ), public, allocatable :: blk (:) Finalizations Procedures final :: mobbrmsd_input_destroy Type-Bound Procedures procedure, public :: add => mobbrmsd_input_add type, public :: mol_block_input mol_block_input (for python interface) Components Type Visibility Attributes Name Initial integer(kind=IK), public :: m number of atoms per molecule integer(kind=IK), public :: n number of molecule integer(kind=IK), public, allocatable :: sym (:,:) molecular symmetry Finalizations Procedures final :: mol_block_input_destroy type, public :: mobbrmsd mobbrmsd Components Type Visibility Attributes Name Initial type( mobbrmsd_header ), public :: h mobbrmsd_header type( mobbrmsd_state ), public :: s mobbrmsd_state Constructor public pure,elemental function mobbrmsd_new (inp) constructor public pure function mobbrmsd_new_from_block (blocks) constructor, from mol_block_input. (for python interface) Finalizations Procedures final :: mobbrmsd_destroy Functions public pure elemental function mobbrmsd_new (inp) result(res) constructor Arguments Type Intent Optional Attributes Name type( mobbrmsd_input ), intent(in) :: inp mobbrmsd_input Return Value type( mobbrmsd ) public pure function mobbrmsd_new_from_block (blocks) result(res) constructor, from mol_block_input. (for python interface) Arguments Type Intent Optional Attributes Name type( mol_block_input ), intent(in) :: blocks (:) mol_block_input array Return Value type( mobbrmsd ) public pure function mobbrmsd_is_finished (header, state) result(res) Returns bb process is finished. Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: header mobbrmsd_header class( mobbrmsd_state ), intent(in) :: state mobbrmsd_state Return Value logical Subroutines public pure subroutine mobbrmsd_input_add (this, m, n, sym) add molecule Arguments Type Intent Optional Attributes Name class( mobbrmsd_input ), intent(inout) :: this mol_block_input array integer(kind=IK), intent(in) :: m number of atoms per molecule integer(kind=IK), intent(in) :: n number of molecule integer(kind=IK), intent(in), optional :: sym (:,:) molecular symmetry, sym(m, s-1) public pure elemental subroutine mobbrmsd_input_destroy (this) destractor Arguments Type Intent Optional Attributes Name type( mobbrmsd_input ), intent(inout) :: this public pure subroutine mol_block_input_add (this, m, n, sym) add molecule Arguments Type Intent Optional Attributes Name type( mol_block_input ), intent(inout), allocatable :: this (:) mol_block_input array integer(kind=IK), intent(in) :: m number of atoms per molecule integer(kind=IK), intent(in) :: n number of molecule integer(kind=IK), intent(in), optional :: sym (:,:) molecular symmetry public pure elemental subroutine mol_block_input_destroy (this) destractor Arguments Type Intent Optional Attributes Name type( mol_block_input ), intent(inout) :: this public pure subroutine mobbrmsd_run (header, state, X, Y, W, cutoff, difflim, maxeval, remove_com, sort_by_g) run mobbrmsd Arguments Type Intent Optional Attributes Name type( mobbrmsd_header ), intent(in) :: header mobbrmsd_header type( mobbrmsd_state ), intent(inout) :: state mobbrmsd_state, the result is contained in this structure. real(kind=RK), intent(in) :: X (*) reference coordinate real(kind=RK), intent(in) :: Y (*) target coordinate real(kind=RK), intent(inout), optional :: W (*) work array, must be > header%memsize() real(kind=RK), intent(in), optional :: cutoff The search ends when lowerbound is determined to be greater than to cutoff. real(kind=RK), intent(in), optional :: difflim The search ends when the difference between the lower and upper bounds is less than difflim. integer(kind=IK), intent(in), optional :: maxeval The search ends when ncount exceeds maxiter. logical, intent(in), optional :: remove_com if true, remove centroids. default [.true.] logical, intent(in), optional :: sort_by_g if true, row is sorted respect to G of reference coordinate. default [.true.] public pure subroutine mobbrmsd_restart (header, state, W, cutoff, difflim, maxeval) run mobbrmsd Arguments Type Intent Optional Attributes Name type( mobbrmsd_header ), intent(in) :: header mobbrmsd_header type( mobbrmsd_state ), intent(inout) :: state mobbrmsd_state, the result is contained in this structure. real(kind=RK), intent(inout) :: W (*) work array, must be > header%memsize() real(kind=RK), intent(in), optional :: cutoff The search ends when lowerbound is determined to be greater than to cutoff. real(kind=RK), intent(in), optional :: difflim The search ends when the difference between the lower and upper bounds is less than difflim. integer(kind=IK), intent(in), optional :: maxeval The search ends when ncount exceeds maxiter. public pure subroutine mobbrmsd_state_update (this, header, W) update mobbrmsd_state Arguments Type Intent Optional Attributes Name type( mobbrmsd_state ), intent(inout) :: this mobbrmsd header type( mobbrmsd_header ), intent(in) :: header mobbrmsd header real(kind=RK), intent(in) :: W (*) mobbrmsd workarray public pure elemental subroutine mobbrmsd_destroy (this) Arguments Type Intent Optional Attributes Name type( mobbrmsd ), intent(inout) :: this","tags":"","loc":"module/mod_mobbrmsd.html"},{"title":"mod_mobbrmsd_header – mobbrmsd","text":"molecular orientation corrected RMSD with branch-and-bound. Uses mod_bb_list mod_bb_block mod_params mod_dimspec_functions Contents Interfaces mobbrmsd_header Derived Types mobbrmsd_header Functions mobbrmsd_header_new mobbrmsd_header_n_dims mobbrmsd_header_n_block mobbrmsd_header_memsize mobbrmsd_header_n_atoms mobbrmsd_header_log_n_nodes mobbrmsd_header_frac_n_nodes mobbrmsd_header_exp_n_nodes mobbrmsd_header_state_template mobbrmsd_header_dump Subroutines mobbrmsd_header_load mobbrmsd_header_destroy Interfaces public interface mobbrmsd_header public pure function mobbrmsd_header_new (q, s) result(res) Returns spatial dimension Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (:) mobbrmsd_header sequence integer(kind=IK), intent(in) :: s (:) mobbrmsd_state template sequence Return Value type( mobbrmsd_header ) Derived Types type, public :: mobbrmsd_header mobbrmsd_header Components Type Visibility Attributes Name Initial integer(kind=IK), public :: d spatial dimension integer(kind=IK), public, allocatable :: q (:) header array integer(kind=IK), public, allocatable :: s (:) state template Constructor public pure function mobbrmsd_header_new (q, s) Returns spatial dimension Finalizations Procedures final :: mobbrmsd_header_destroy Type-Bound Procedures procedure, public :: n_dims => mobbrmsd_header_n_dims procedure, public :: n_block => mobbrmsd_header_n_block procedure, public :: n_atoms => mobbrmsd_header_n_atoms procedure, public :: log_n_nodes => mobbrmsd_header_log_n_nodes procedure, public :: frac_n_nodes => mobbrmsd_header_frac_n_nodes procedure, public :: exp_n_nodes => mobbrmsd_header_exp_n_nodes procedure, public :: memsize => mobbrmsd_header_memsize procedure, public :: state_template => mobbrmsd_header_state_template procedure, public :: dump => mobbrmsd_header_dump procedure, public :: load => mobbrmsd_header_load Functions public pure function mobbrmsd_header_new (q, s) result(res) Returns spatial dimension Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (:) mobbrmsd_header sequence integer(kind=IK), intent(in) :: s (:) mobbrmsd_state template sequence Return Value type( mobbrmsd_header ) public pure elemental function mobbrmsd_header_n_dims (this) result(res) Returns spatial dimension Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK) public pure elemental function mobbrmsd_header_n_block (this) result(res) Returns number of molecular blocks Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK) public pure elemental function mobbrmsd_header_memsize (this) result(res) Returns header_memsize Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK) public pure elemental function mobbrmsd_header_n_atoms (this) result(res) Returns n_atoms Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK) public pure elemental function mobbrmsd_header_log_n_nodes (this) result(res) Returns log_n_nodes Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value real(kind=RK) public pure function mobbrmsd_header_frac_n_nodes (this) result(res) returns number of nodes in fraction. Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value real(kind=RK) public pure function mobbrmsd_header_exp_n_nodes (this) result(res) returns number of nodes in exp. Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK) public pure function mobbrmsd_header_state_template (this) result(res) dump state template as integer array Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK),allocatable, (:) public pure function mobbrmsd_header_dump (this) result(res) dump header as integer array Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(in) :: this this Return Value integer(kind=IK),allocatable, (:) Subroutines public pure subroutine mobbrmsd_header_load (this, q) load integer array as header Arguments Type Intent Optional Attributes Name class( mobbrmsd_header ), intent(inout) :: this this integer(kind=IK), intent(in) :: q (:) header array public pure elemental subroutine mobbrmsd_header_destroy (this) destructer Arguments Type Intent Optional Attributes Name type( mobbrmsd_header ), intent(inout) :: this","tags":"","loc":"module/mod_mobbrmsd_header.html"},{"title":"mod_mobbrmsd_batch_run – mobbrmsd","text":"molecular orientation corrected RMSD with branch-and-bound. Uses mod_mobbrmsd_state mod_mobbrmsd mod_params mod_forbar_collections mod_mobbrmsd_header mod_forbar Contents Subroutines mobbrmsd_batch_run Subroutines public subroutine mobbrmsd_batch_run (n_target, header, state, X, Y, W, cutoff, difflim, maxeval, remove_com, sort_by_g, rotate_y) batch parallel run Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: n_target number of target coordinates type( mobbrmsd_header ), intent(in) :: header mobbrmsd_header type( mobbrmsd_state ), intent(inout) :: state (n_target) mobbrmsd_state, the result is contained in this structure. real(kind=RK), intent(in) :: X (*) reference coordinate real(kind=RK), intent(inout) :: Y (*) target coordinate real(kind=RK), intent(inout) :: W (*) work memory, must be larger than header%memsize() * mobbrmsd_num_threads() real(kind=RK), intent(in), optional :: cutoff The search ends when lowerbound is determined to be greater than to cutoff. real(kind=RK), intent(in), optional :: difflim The search ends when the difference between the lower and upper bounds is less than difflim. integer(kind=IK), intent(in), optional :: maxeval The search ends when ncount exceeds maxiter. logical, intent(in), optional :: remove_com if true, remove centroids. default [.true.] logical, intent(in), optional :: sort_by_g if true, row is sorted respect to G of reference coordinate. default [.true.] logical, intent(in), optional :: rotate_y The search ends when ncount exceeds maxiter.","tags":"","loc":"module/mod_mobbrmsd_batch_run.html"},{"title":"mod_mobbrmsd_state – mobbrmsd","text":"molecular orientation corrected RMSD with branch-and-bound. Uses mod_mobbrmsd_header mod_bb_list mod_params Contents Variables mobbrmsd_state_INDEX_TO_RCP_N_ATOMS mobbrmsd_state_INDEX_TO_AUTOCORR mobbrmsd_state_INDEX_TO_UPPERBOUND mobbrmsd_state_INDEX_TO_LOWERBOUND mobbrmsd_state_INDEX_TO_N_EVAL mobbrmsd_state_INDEX_TO_LOG_RATIO mobbrmsd_state_INDEX_TO_ROTMAT Interfaces mobbrmsd_state Derived Types mobbrmsd_state Functions mobbrmsd_state_new mobbrmsd_state_upperbound mobbrmsd_state_lowerbound mobbrmsd_state_autovariance mobbrmsd_state_squared_deviation mobbrmsd_state_mean_squared_deviation mobbrmsd_state_rmsd mobbrmsd_state_lowerbound_as_rmsd mobbrmsd_state_n_eval mobbrmsd_state_eval_ratio mobbrmsd_state_log_eval_ratio mobbrmsd_state_dump mobbrmsd_state_dump_real Subroutines mobbrmsd_state_rotation mobbrmsd_state_load mobbrmsd_state_destroy Variables Type Visibility Attributes Name Initial integer(kind=IK), public, parameter :: mobbrmsd_state_INDEX_TO_RCP_N_ATOMS = 1 Index of reciprocal natom of dumped state integer(kind=IK), public, parameter :: mobbrmsd_state_INDEX_TO_AUTOCORR = 2 Index to auto correlation integer(kind=IK), public, parameter :: mobbrmsd_state_INDEX_TO_UPPERBOUND = 3 Index of upperbound of dumped state integer(kind=IK), public, parameter :: mobbrmsd_state_INDEX_TO_LOWERBOUND = 4 Index of lowerbound of dumped state integer(kind=IK), public, parameter :: mobbrmsd_state_INDEX_TO_N_EVAL = 5 Index of n_eval of dumped state integer(kind=IK), public, parameter :: mobbrmsd_state_INDEX_TO_LOG_RATIO = 6 Index of log_ratio of dumped state integer(kind=IK), public, parameter :: mobbrmsd_state_INDEX_TO_ROTMAT = 7 Index to rotmatrix of dumped state Interfaces public interface mobbrmsd_state public pure elemental function mobbrmsd_state_new (header) result(res) returns upperbound Arguments Type Intent Optional Attributes Name type( mobbrmsd_header ), intent(in) :: header mobbrmsd header Return Value type( mobbrmsd_state ) Derived Types type, public :: mobbrmsd_state mobbrmsd_state Components Type Visibility Attributes Name Initial integer(kind=IK), public, allocatable :: s (:) real(kind=RK), public, allocatable :: z (:) Constructor public pure,elemental function mobbrmsd_state_new (header) returns upperbound Finalizations Procedures final :: mobbrmsd_state_destroy destracter Type-Bound Procedures procedure, public :: upperbound => mobbrmsd_state_upperbound upperbound procedure, public :: lowerbound => mobbrmsd_state_lowerbound lowerbound procedure, public :: autovariance => mobbrmsd_state_autovariance lowerbound procedure, public :: squared_deviation => mobbrmsd_state_squared_deviation sqrared_deviation procedure, public :: mean_squared_deviation => mobbrmsd_state_mean_squared_deviation sqrared_deviation procedure, public :: rmsd => mobbrmsd_state_rmsd rmsd procedure, public :: lowerbound_as_rmsd => mobbrmsd_state_lowerbound_as_rmsd lowerbound_as_rmsd procedure, public :: n_eval => mobbrmsd_state_n_eval number of lowerbound evaluation procedure, public :: eval_ratio => mobbrmsd_state_eval_ratio ratio of evaluated node procedure, public :: log_eval_ratio => mobbrmsd_state_log_eval_ratio log ratio of evaluated node procedure, public :: rotation => mobbrmsd_state_rotation rotate given coordinate procedure, public :: dump => mobbrmsd_state_dump dump current state procedure, public :: dump_real => mobbrmsd_state_dump_real dump real part of current state procedure, public :: load => mobbrmsd_state_load load state Functions public pure elemental function mobbrmsd_state_new (header) result(res) returns upperbound Arguments Type Intent Optional Attributes Name type( mobbrmsd_header ), intent(in) :: header mobbrmsd header Return Value type( mobbrmsd_state ) public pure elemental function mobbrmsd_state_upperbound (this) result(res) returns upperbound Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) public pure elemental function mobbrmsd_state_lowerbound (this) result(res) returns lowerbound Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) public pure elemental function mobbrmsd_state_autovariance (this) result(res) returns autovariance Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) public pure elemental function mobbrmsd_state_squared_deviation (this) result(res) returns squared deviation Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) public pure elemental function mobbrmsd_state_mean_squared_deviation (this) result(res) returns squared deviation Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) public pure elemental function mobbrmsd_state_rmsd (this) result(res) returns rmsd Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) public pure elemental function mobbrmsd_state_lowerbound_as_rmsd (this) result(res) returns lowerbound as rmsd Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) public pure elemental function mobbrmsd_state_n_eval (this) result(res) returns n_eval Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value integer(kind=IK) public pure elemental function mobbrmsd_state_eval_ratio (this) result(res) returns eval_ratio Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this Return Value real(kind=RK) public pure elemental function mobbrmsd_state_log_eval_ratio (this) result(res) returns log_eval_ratio Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this Return Value real(kind=RK) public pure function mobbrmsd_state_dump (this) result(res) dump header as integer array (for python interface api) Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this mobbrmsd_header Return Value integer(kind=IK),allocatable, (:) public pure function mobbrmsd_state_dump_real (this) result(res) dump header as integer array (for python interface api) Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this mobbrmsd_header Return Value real(kind=RK),allocatable, (:) Subroutines public pure subroutine mobbrmsd_state_rotation (this, header, X) returns eval_ratio Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(in) :: this this type( mobbrmsd_header ), intent(in) :: header mobbrmsd header real(kind=RK), intent(inout) :: X (*) coordinate public pure subroutine mobbrmsd_state_load (this, s, z) load integer array as header (for python interface api) Arguments Type Intent Optional Attributes Name class( mobbrmsd_state ), intent(inout) :: this mobbrmsd_header integer(kind=IK), intent(in) :: s (:) state integer array real(kind=RK), intent(in) :: z (:) state real array public pure elemental subroutine mobbrmsd_state_destroy (this) Arguments Type Intent Optional Attributes Name type( mobbrmsd_state ), intent(inout) :: this","tags":"","loc":"module/mod_mobbrmsd_state.html"},{"title":"mod_mobbrmsd_mst – mobbrmsd","text":"Configure a minimum global tree with mobbrmsd. MST construction is based on the Prim's algorithm,\n but the useless calculations are reduced using the cutoff possibilities of mobbrmsd. Uses mod_mobbrmsd_state mod_mobbrmsd mod_params mod_forbar_collections mod_mobbrmsd_header mod_forbar Contents Subroutines mobbrmsd_min_span_tree Subroutines public subroutine mobbrmsd_min_span_tree (n_target, header, state, X, W, cutoff, difflim, maxeval, remove_com, sort_by_g, edges, weights, show_progress, verbose) min_span_tree construction Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: n_target number of coordinates type( mobbrmsd_header ), intent(in) :: header mobbrmsd_header type( mobbrmsd_state ), intent(inout) :: state (n_target,n_target) mobbrmsd_state, the result is contained in this structure. real(kind=RK), intent(in) :: X (*) coordinate sequence real(kind=RK), intent(inout) :: W (*) work memory, must be larger than header%memsize() * mobbrmsd_num_threads() real(kind=RK), intent(in), optional :: cutoff The search ends when lowerbound is determined to be greater than to cutoff. real(kind=RK), intent(in), optional :: difflim The search ends when the difference between the lower and upper bounds is less than difflim. integer(kind=IK), intent(in), optional :: maxeval The search ends when ncount exceeds maxiter. logical, intent(in), optional :: remove_com if true, remove centroids. default [.true.] logical, intent(in), optional :: sort_by_g if true, row is sorted respect to G of reference coordinate. default [.true.] integer(kind=IK), intent(out), optional :: edges (2,n_target-1) minimum spanning tree edges real(kind=RK), intent(out), optional :: weights (n_target-1) minimum spanning tree weights logical, intent(in), optional :: show_progress if true, show progress bar logical, intent(in), optional :: verbose show progress bar","tags":"","loc":"module/mod_mobbrmsd_mst.html"},{"title":"mod_bb_block – mobbrmsd","text":"Module for handling and the factrial tree. This module provides procedures for performing branch-and-bound algorithms (BB)\n on assemblies consisting of homologous molecules. Since the BB procedure is implemented for multi-component systems,\n this module does not provide the BB itself. Note Node data block is defined by , here : scalar, lowerbound. : scalar, partial sum of auto variance. : partial sum of covariance. Uses mod_Hungarian mod_f_matrix mod_params mod_rotation mod_mol_block mod_tree mod_c_matrix mod_dimspec_functions Contents Interfaces bb_block Derived Types bb_block Functions bb_block_memsize bb_block_worksize bb_block_nmol bb_block_natm bb_block_molsize bb_block_statesize bb_block_is_left bb_block_tree_is_empty bb_block_tree_is_finished bb_block_is_bottom bb_block_current_level bb_block_current_value bb_block_lowest_value bb_block_lowerbound bb_block_evaluation_count bb_block_log_ncomb bb_block_autocorr Subroutines bb_block_setup bb_block_inheritance bb_block_expand bb_block_closure bb_block_set_ub_offset bb_block_save_state bb_block_swap_y bb_block_covmat_add Interfaces public interface bb_block private pure function bb_block_new(n_apm, n_mol, sym) result(res) Constructer Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: n_apm number of molecules. integer(kind=IK), intent(in) :: n_mol number of atoms per molecule. integer(kind=IK), intent(in), optional :: sym (:,:) symmetric codomains, [[a1,a2,...,am], [b1,b2,...,bm], ...]. Return Value type( bb_block ) Derived Types type, public :: bb_block bb_block This is mainly used for passing during initialization. Constructor private pure function bb_block_new (n_apm, n_mol, sym) Constructer Finalizations Procedures final :: bb_block_destroy Functions public pure function bb_block_memsize (q) result(res) Returns the memory size array size. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) bb_block header array. Return Value integer(kind=IK) public pure function bb_block_worksize (q) result(res) Returns the work memory size array size. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header. Return Value integer(kind=IK) public pure function bb_block_nmol (q) result(res) Returns the number of molecules. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header. Return Value integer(kind=IK) public pure function bb_block_natm (q) result(res) Returns the number of molecules. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header. Return Value integer(kind=IK) public pure function bb_block_molsize (q) result(res) Returns the memory size of molecular block size. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) bb_block header array. Return Value integer(kind=IK) public pure function bb_block_statesize (q) result(res) Returns size of saved state. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header. Return Value integer(kind=IK) public pure function bb_block_is_left (UB, q, s, W) result(res) Returns true when tree is empty Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: UB upper bound integer(kind=IK), intent(in) :: q (*) integer array integer(kind=IK), intent(in) :: s (*) work integer array real(kind=RK), intent(in) :: W (*) main memory Return Value logical public pure function bb_block_tree_is_empty (q, s) result(res) Returns true when tree is empty Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array integer(kind=IK), intent(in) :: s (*) work integer array Return Value logical public pure function bb_block_tree_is_finished (q, s) result(res) Returns true when tree is finished Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array integer(kind=IK), intent(in) :: s (*) work integer array Return Value logical public pure function bb_block_is_bottom (q, s) result(res) Returns true when tree is bottom Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array integer(kind=IK), intent(in) :: s (*) work integer array Return Value logical public pure function bb_block_current_level (q, s) result(res) Returns current level. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) work integer array Return Value integer(kind=IK) public pure function bb_block_current_value (q, s, W) result(res) Returns current L value. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array integer(kind=IK), intent(in) :: s (*) work integer array real(kind=RK), intent(in) :: W (*) main memory Return Value real(kind=RK) public pure function bb_block_lowest_value (q, s, W) result(res) Returns the minimum value of the surviving nodes, excluding the current value. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state real(kind=RK), intent(in) :: W (*) main memory Return Value real(kind=RK) public pure function bb_block_lowerbound (W) result(res) Returns the minimum value of the surviving nodes, excluding the current value. Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: W (*) main memory Return Value real(kind=RK) public pure function bb_block_evaluation_count (W) result(res) Returns the minimum value of the surviving nodes, excluding the current value. Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: W (*) main memory Return Value real(kind=RK) public pure function bb_block_log_ncomb (q) result(res) Returns the minimum value of the surviving nodes, excluding the current value. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array Return Value real(kind=RK) public pure function bb_block_autocorr (q, W) result(res) Returns the minimum value of the surviving nodes, excluding the current value. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header real(kind=RK), intent(in) :: W (*) main memory Return Value real(kind=RK) Subroutines public pure subroutine bb_block_setup (q, X, Y, CX, CY, s, W, zfill, sort_by_g) Setup C matrix and F matrix in root node. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array real(kind=RK), intent(in) :: X (*) reference coordinate real(kind=RK), intent(in) :: Y (*) target coordinate real(kind=RK), intent(in) :: CX (*) centroid of X real(kind=RK), intent(in) :: CY (*) centroid of Y integer(kind=IK), intent(inout) :: s (*) integer work array real(kind=RK), intent(inout) :: W (*) work integer array logical, intent(in) :: zfill if true, the root node is filled by zero. logical, intent(in), optional :: sort_by_g if true, row is sorted respect to G of reference coordinate. public pure subroutine bb_block_inheritance (q, s, W, p, r, Z) Expands the latest node of the parent block to the top-level queue of the child block. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) work integer array integer(kind=IK), intent(inout) :: s (*) work integer array real(kind=RK), intent(inout) :: W (*) main memory integer(kind=IK), intent(in) :: p (*) parent integer array integer(kind=ik), intent(in) :: r (*) parent integer work array real(kind=RK), intent(in) :: Z (*) parent work array public pure subroutine bb_block_expand (UB, q, s, W) Expand top node in queue. Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: UB upper bound integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(inout) :: s (*) state real(kind=RK), intent(inout) :: W (*) main memory public pure subroutine bb_block_closure (UB, q, s, W) closure current node. Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: UB upper bound integer(kind=IK), intent(in) :: q (*) work integer array integer(kind=IK), intent(inout) :: s (*) work integer array real(kind=RK), intent(in) :: W (*) public pure subroutine bb_block_set_ub_offset (W, ubofs) Set ub offset value Arguments Type Intent Optional Attributes Name real(kind=RK), intent(inout) :: W (*) main memory real(kind=RK), intent(in) :: ubofs main memory public pure subroutine bb_block_save_state (q, s, z) Save current state. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array integer(kind=IK), intent(in) :: s (*) state vector integer(kind=IK), intent(inout) :: z (*) memory public pure subroutine bb_block_swap_y (q, s, z, Y) swap Y by saved state z. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) header integer(kind=IK), intent(in) :: s (*) state integer(kind=IK), intent(in) :: z (*) saved state (not state vector) real(kind=RK), intent(inout) :: Y (*) target coordinate public pure subroutine bb_block_covmat_add (q, z, W, G, C) Sum covariance matrix by saved state z. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: q (*) integer array integer(kind=IK), intent(in) :: z (*) saved state (not state vector) real(kind=RK), intent(in) :: W (*) main memory real(kind=RK), intent(inout) :: G autovariance real(kind=RK), intent(inout) :: C (*) covariance matrix","tags":"","loc":"module/mod_bb_block.html"},{"title":"mod_dimspec_functions – mobbrmsd","text":"Define spatial dimension, ,\n and provide optimized functions for dimension. Uses mod_kinds Contents Variables D DD ND Subroutines setup_dimension compute_com compute_cov covcopy Variables Type Visibility Attributes Name Initial integer(kind=IK), public, parameter :: D = 2 Spatial dimension integer(kind=IK), public, parameter :: DD = 4 Square spatial dimension integer(kind=IK), public, parameter :: ND = DD+2 Node memory size, defined by .\n Let be a node,\n where and . Subroutines public subroutine setup_dimension (d_) Sets the dimensions of the space. This is dummy interface. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d_ public pure subroutine compute_com (d, n, X, C) Calculate center of mass for Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(inout) :: C (d) public pure subroutine compute_cov (d, n, X, Y, C) Calculate covariance matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(in) :: Y (d,*) real(kind=RK), intent(inout) :: C (d,d) public pure subroutine covcopy (d, n, X, CX, Y) Compute for Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(in) :: CX (d) real(kind=RK), intent(inout) :: Y (d,*)","tags":"","loc":"module/mod_dimspec_functions.html"},{"title":"mod_rotation – mobbrmsd","text":"Calculate the rotation matrix that minimizes |X-RY|&#94;2 for D=2. Here, RR&#94;T=I and det(R)=1 are satisfied. This code is based on the method of Theobald.\n doi : 10.1107/S0108767305015266 Uses mod_kinds Contents Functions sdmin_worksize rotation_worksize Subroutines estimate_rcmax estimate_sdmin estimate_rotation Functions public pure elemental function sdmin_worksize () result(res) Inquire function for memory size of estimate_sdmin. Arguments None Return Value integer(kind=IK) public pure elemental function rotation_worksize () result(res) Inquire function for memory size of rotation. Arguments None Return Value integer(kind=IK) Subroutines public pure subroutine estimate_rcmax (g, cov, w) Compute . Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g sum of auto covariance matrix real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_sdmin(). public pure subroutine estimate_sdmin (g, cov, w) Compute the least-squares sum_i&#94;n |x_i-Ry_i|&#94;2 from cov = YX&#94;T and g = tr[XX&#94;T] + tr[YY&#94;T]. Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g sum of auto covariance matrix real(kind=RK), intent(in) :: cov (*) target d*d array real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_sdmin(). public pure subroutine estimate_rotation (g, cov, rot, w) Compute the transpose rotation matrix for minimize tr[CR] from cov = YX&#94;T and g = tr[XX&#94;T] + tr[YY&#94;T]. Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g g = tr[XX&#94;T] + tr[YY&#94;T] real(kind=RK), intent(in) :: cov (*) covariance dxd matrix, YX&#94;T real(kind=RK), intent(inout) :: rot (*) rotation dxd matrix real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_rotation().","tags":"","loc":"module/mod_rotation.html"},{"title":"mod_dimspec_functions – mobbrmsd","text":"Define spatial dimension, ,\n and provide an optimized blas/lapack interface. Uses mod_kinds Contents Variables D DD ND Subroutines setup_dimension compute_com compute_cov covcopy Variables Type Visibility Attributes Name Initial integer(kind=IK), public, parameter :: D = 3 Spatial dimension. integer(kind=IK), public, parameter :: DD = 9 Square spatial dimension. integer(kind=IK), public, parameter :: ND = DD+2 Node memory size, defined by .\n Let be a node,\n where and . Subroutines public subroutine setup_dimension (d_) Sets the dimensions of the space. Caution, this routine affects global. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d_ public pure subroutine compute_com (d, n, X, C) Calculate center of mass for Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(inout) :: C (d) public pure subroutine compute_cov (d, n, X, Y, C) Calculate covariance matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(in) :: Y (d,*) real(kind=RK), intent(inout) :: C (d,d) public pure subroutine covcopy (d, n, X, CX, Y) Compute for Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(in) :: CX (d) real(kind=RK), intent(inout) :: Y (d,*)","tags":"","loc":"module/mod_dimspec_functions~2.html"},{"title":"mod_rotation – mobbrmsd","text":"Calculate the rotation matrix that minimizes for . Here, and are satisfied. This code is based on the method of Coutsias et.al.\n doi : 10.1002/jcc.25802 Uses mod_kinds Contents Functions sdmin_worksize rotation_worksize Subroutines estimate_rcmax estimate_sdmin estimate_rotation Functions public pure elemental function sdmin_worksize () result(res) Inquire function for memory size of estimate_sdmin. Arguments None Return Value integer(kind=IK) public pure elemental function rotation_worksize () result(res) Inquire function for memory size of rotation. Arguments None Return Value integer(kind=IK) Subroutines public pure subroutine estimate_rcmax (g, cov, w) Compute . Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g sum of auto covariance matrix real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_sdmin(). public pure subroutine estimate_sdmin (g, cov, w) Compute the least-squares sum_i&#94;n |x_i-Ry_i|&#94;2 from cov = YX&#94;T and g = tr[XX&#94;T] + tr[YY&#94;T]. Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g sum of auto covariance matrix real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_sdmin(). public pure subroutine estimate_rotation (g, cov, rot, w) Compute the transpose rotation matrix for minimize tr[CR] from cov = YX&#94;T and g = tr[XX&#94;T] + tr[YY&#94;T].\n This subroutine is based on the method of Coutsias et.al. 10.1002/jcc.25802 Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g g = tr[XX&#94;T] + tr[YY&#94;T] real(kind=RK), intent(in) :: cov (*) covariance dxd matrix, YX&#94;T real(kind=RK), intent(inout) :: rot (*) rotation dxd matrix real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_rotation().","tags":"","loc":"module/mod_rotation~2.html"},{"title":"mod_dimspec_functions – mobbrmsd","text":"Define spatial dimension, ,\n and provide optimized functions for dimension. Uses mod_kinds Contents Variables D DD ND Subroutines setup_dimension compute_com compute_cov covcopy Variables Type Visibility Attributes Name Initial integer(kind=IK), public, save :: D = 3 Spatial dimension, . integer(kind=IK), public, save :: DD = 9 Square spatial dimension, . integer(kind=IK), public, save :: ND = 9+2 Node memory size, defined by .\n Let be a node,\n where and . Subroutines public subroutine setup_dimension (d_) Sets the dimensions of the space. Caution, this routine affects global. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d_ public pure subroutine compute_com (d, n, X, C) Calculate center of mass. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(inout) :: C (d) public pure subroutine compute_cov (d, n, X, Y, C) Calculate covariance matrix. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(in) :: Y (d,*) real(kind=RK), intent(inout) :: C (d,d) public pure subroutine covcopy (d, n, X, CX, Y) Compute . Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: d integer(kind=IK), intent(in) :: n real(kind=RK), intent(in) :: X (d,*) real(kind=RK), intent(in) :: CX (d) real(kind=RK), intent(inout) :: Y (d,*)","tags":"","loc":"module/mod_dimspec_functions~3.html"},{"title":"mod_rotation – mobbrmsd","text":"Calculate the rotation matrix that minimizes . Here, and are satisfied. This code is based on the Kabsch algorithm.\n doi : 10.1107/S0567739476001873 Uses mod_kinds mod_dimspec_functions Contents Functions sdmin_worksize rotation_worksize Subroutines estimate_rcmax estimate_sdmin estimate_rotation Functions public pure elemental function sdmin_worksize () result(res) Inquire function for memory size of estimate_sdmin. Arguments None Return Value integer(kind=IK) public pure elemental function rotation_worksize () result(res) Inquire function for memory size of estimate_rotation(). Arguments None Return Value integer(kind=IK) Subroutines public pure subroutine estimate_rcmax (g, cov, w) Compute . Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g sum of auto covariance matrix real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_sdmin(). public pure subroutine estimate_sdmin (g, cov, w) Compute ,\n where Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g sum of auto covariance matrix real(kind=RK), intent(in) :: cov (*) target d*n array real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_sdmin(). public pure subroutine estimate_rotation (g, cov, rot, w) Compute the transpose of rotation matrix that maximize . Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: g . real(kind=RK), intent(in) :: cov (*) covariance matrix rotation real(kind=RK), intent(inout) :: rot (*) rotation matrix, . real(kind=RK), intent(inout) :: w (*) work array, must be larger than worksize_rotation().","tags":"","loc":"module/mod_rotation~3.html"},{"title":"mod_f_matrix.f90 – mobbrmsd","text":"Contents Modules mod_f_matrix Source Code mod_f_matrix.f90 Source Code !| Module for managing free rotation cost matrix, \\mathbf{F}. <br> !   \\mathbf{F}_{IJ} = \\min_{\\mathbf{R},s}\\text{Tr}\\left[\\mathbf{C}_{IJs} \\mathbf{R} \\right]  !   \\mathbf{C}_{IJs}  :: Covariance matrix of  \\mathbf{X}_I  and  \\mathbf{Y}_I  with  s -th molecular permutation.<br> !   \\mathbf{R}  :: Rotation matrix on  \\mathbb{R}&#94;{d} .<br> module mod_f_matrix use mod_dimspec_functions , only : D , DD use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO , RHUGE use mod_c_matrix use mod_mol_block use mod_rotation use mod_Hungarian implicit none private public :: f_matrix public :: f_matrix_memsize public :: f_matrix_worksize public :: f_matrix_eval ! integer ( IK ), parameter :: header_size = 1 integer ( IK ), parameter :: nn = 1 ! !| F matrix manager. !  This derived type is mainly used for passing during initialization. type f_matrix integer ( IK ) :: q ( header_size ) !! header end type f_matrix ! !| Constructer interface f_matrix module procedure f_matrix_new end interface f_matrix ! contains ! !| Constructer pure function f_matrix_new ( b ) result ( res ) integer ( IK ), intent ( in ) :: b ( * ) !! mol_block, must be initialized type ( f_matrix ) :: res ! res % q ( nn ) = mol_block_nmol ( b ) ** 2 ! end function f_matrix_new ! !| Inquire memsize of f_matrix pure function f_matrix_memsize ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! f_matrix integer ( IK ) :: res res = q ( nn ) end function f_matrix_memsize ! !| Inquire worksize of f_matrix pure function f_matrix_worksize ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! f_matrix integer ( IK ) :: res res = q ( nn ) * ( sdmin_worksize () + 1 ) end function f_matrix_worksize ! !| Evaluation the D matrix pure subroutine f_matrix_eval ( q , qc , C , F , W ) integer ( IK ), intent ( in ) :: q ( * ) !! header of f_matrix integer ( IK ), intent ( in ) :: qc ( * ) !! header of covariacne matrix C. real ( RK ), intent ( inout ) :: C ( * ) !! covariacne matrix c. real ( RK ), intent ( inout ) :: F ( * ) !! main memory of F. real ( RK ), intent ( inout ) :: W ( * ) !! work array. integer ( IK ) :: i , cb , nw ! cb = c_matrix_blocksize ( qc ) nw = sdmin_worksize () + 1 ! do concurrent ( i = 1 : q ( nn )) block integer ( IK ) :: ic , iw ic = cb * ( i - 1 ) + 1 iw = nw * ( i - 1 ) + 1 call eval_f_matrix ( cb , C ( ic ), W ( iw )) F ( i ) = W ( iw ) end block end do ! end subroutine f_matrix_eval ! pure subroutine eval_f_matrix ( cb , C , W ) integer ( IK ), intent ( in ) :: cb real ( RK ), intent ( in ) :: C ( cb ) real ( RK ), intent ( inout ) :: W ( * ) integer ( IK ) :: i !   get - max tr[CR] W ( 1 ) = RHUGE do i = 2 , cb , DD call estimate_rcmax ( C ( 1 ), C ( i ), W ( 2 )) W ( 1 ) = MIN ( W ( 1 ), - W ( 2 )) end do end subroutine eval_f_matrix ! end module mod_f_matrix","tags":"","loc":"sourcefile/mod_f_matrix.f90.html"},{"title":"mod_mol_block.f90 – mobbrmsd","text":"Contents Modules mod_mol_block Source Code mod_mol_block.f90 Source Code !| Module for molecular coodinate block indicator.<br> !  Coordinates must be stored in the 3-D array, X(d, n, M).<br> !   <br> !    - d :: spatial dimension.<br> !    - n :: number of atom in a molecule.<br> !    - M :: number of molecule.<br> module mod_mol_block use mod_dimspec_functions , only : D use mod_params , only : IK , RK use mod_group_permutation implicit none private public :: mol_block public :: mol_block_each_size public :: mol_block_total_size public :: mol_block_natm public :: mol_block_nmol public :: mol_block_napm public :: mol_block_nsym public :: mol_block_swap public :: mol_block_inverse_swap ! integer ( IK ), parameter :: pn = 1 integer ( IK ), parameter :: pm = 2 integer ( IK ), parameter :: pg = 3 ! !| molecular block !  This is mainly used for passing during initialization. type mol_block sequence !| header integer ( IK ), allocatable :: q (:) end type mol_block ! interface mol_block module procedure mol_block_new end interface mol_block ! contains ! !| Constructer pure function mol_block_new ( n , M , sym ) result ( res ) integer ( IK ), intent ( in ) :: n !! number of atoms per molecule integer ( IK ), intent ( in ) :: M !! number of molecules integer ( IK ), intent ( in ), optional :: sym (:, :) !! symmetric codomains, sym(n, S) !!  [[\\nu_1&#94;{(1)},\\dots,\\nu_n&#94;{(1)}],[\\nu_1&#94;{(2)},\\dots,\\nu_n&#94;{(2)}]],\\dots, [\\nu_1&#94;{(S)},\\dots,\\nu_n&#94;{(S)}]] type ( mol_block ) :: res type ( group_permutation ) :: s integer ( IK ) :: napm ! s = group_permutation ( sym ) napm = MAX ( n , 0 ) if ( PRESENT ( sym )) napm = MAX ( napm , SIZE ( sym , 1 )) res % q = [ napm , MAX ( M , 1 ), s % q ] ! end function mol_block_new ! !| number of atoms, defined by nM. pure function mol_block_natm ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! mol_block integer ( IK ) :: res res = q ( pm ) * q ( pn ) end function mol_block_natm ! !| number of molecules, M. pure function mol_block_nmol ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! mol_block integer ( IK ) :: res res = q ( pm ) end function mol_block_nmol ! !| number of atoms per molecule, n pure function mol_block_napm ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! mol_block integer ( IK ) :: res res = q ( pn ) end function mol_block_napm ! !| number of molecular symmetry, S. pure function mol_block_nsym ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! mol_block integer ( IK ) :: res res = group_permutation_nsym ( q ( pg )) end function mol_block_nsym ! !| memory blocksize per molecule, defined by dn. pure function mol_block_each_size ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! mol_block integer ( IK ) :: res res = D * q ( pn ) end function mol_block_each_size ! !| memory blocksize, defined by dnM. pure function mol_block_total_size ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! mol_block integer ( IK ) :: res res = D * q ( pn ) * q ( pm ) end function mol_block_total_size ! !| Compute molecular symmetry permutation according to isym. pure subroutine mol_block_swap ( q , isym , X ) integer ( IK ), intent ( in ) :: q ( * ) !! mol_block integer ( IK ), intent ( in ) :: isym !! symmetry id real ( RK ), intent ( inout ) :: X ( * ) !! work array ! call group_permutation_swap ( q ( pg ), isym , D , X ) ! end subroutine mol_block_swap ! !| Compute molecular symmetry inverse permutation according to isym. pure subroutine mol_block_inverse_swap ( q , isym , X ) integer ( IK ), intent ( in ) :: q ( * ) !! mol_block integer ( IK ), intent ( in ) :: isym !! symmetry id. real ( RK ), intent ( inout ) :: X ( * ) !! work array ! call group_permutation_inverse ( q ( pg ), isym , D , X ) ! end subroutine mol_block_inverse_swap ! end module mod_mol_block","tags":"","loc":"sourcefile/mod_mol_block.f90.html"},{"title":"mod_group_permutation.f90 – mobbrmsd","text":"Contents Modules mod_group_permutation Source Code mod_group_permutation.f90 Source Code !| Module for order permutation by decomposed cyclic groups. <br> !  This module provides swap operations on sequences equivalent to X(:, :) = X(:, perm(:)). <br> !  A given swap index perm(:) is decomposed into periodic substitutions. <br> !  @note !    group permutations are encoded in header integer array, in the following. <br> !     \\mathbf{q} = [S, p_2, ..., p_S, \\mathbf{w}_1, \\mathbf{w}_2, ..., \\mathbf{w}_S]  <br> !     S    :: number of permutation. <br> !     p_s  :: pointer to  \\mathbf{w}_2  to  \\mathbf{w}_S . <br> !     p_1  is equiv to  S + 1  <br> !    Swap indeces are stored in work array, in the following. <br> !     \\mathbf{w}_i = [T, r_2, ..., r_T, \\mathbf{b}_1, \\mathbf{b}_2, ..., \\mathbf{b}_T]  <br> !     T    :: number of order - 1. <br> !     r_j  :: pointer to b_i+1. <br> !     \\mathbf{b}_j  :: body. <br> !    body is constructed as follows. <br> !     \\mathbf{b}_j = [n, s, \\mathbf{v}_1, ..., \\mathbf{v}_n]  <br> !     n  :: number of permutation. <br> !     s  :: order of cycle. <br> !     \\mathbf{v}_j  :: mapping sequence,  v_1, v_2,\\dots,v_s . <br> !    - memsize is 2 + ns !  @endnote module mod_group_permutation use mod_params , only : IK , RK implicit none private public :: group_permutation public :: group_permutation_nsym public :: group_permutation_swap public :: group_permutation_inverse ! !| A structure that references an array representing a replacement operation. <br> !  It is possible to hold s permutation mapping of starting from [1,2,...,N]. !  This is mainly used for passing during initialization. type :: group_permutation integer ( IK ), allocatable :: q (:) !! q array. contains final :: group_permutation_destroy end type group_permutation ! interface group_permutation module procedure group_permutation_new end interface group_permutation ! contains ! !| Constructor. pure function group_permutation_new ( perm ) result ( res ) integer ( IK ), intent ( in ), optional :: perm (:, :) !! codomains, [[a1,a2,...,am],[b1,b2,...,bm],...]. type ( group_permutation ) :: res !! return value. integer ( IK ), allocatable :: t (:), c (:,:) integer ( IK ) :: i , m , p , s ! if ( PRESENT ( perm )) then m = SIZE ( perm , 1 ) s = SIZE ( perm , 2 ) c = perm (:, count_perm ( m , s , perm )) s = SIZE ( c , 2 ) else s = 0 end if ! if ( s < 1 ) then res % q = [ 1 ] return else res % q = [( 0 , i = 1 , s )] end if ! p = s + 1 do i = 1 , s res % q ( i ) = p t = decompose_to_cyclic ( perm (:, i )) p = p + SIZE ( t ) res % q = [ res % q , t ] end do ! contains ! pure function count_perm ( m , s , perm ) result ( res ) integer ( IK ), intent ( in ) :: m , s , perm ( m , s ) integer ( IK ), allocatable :: res (:) integer ( IK ) :: i , j allocate ( res ( 0 )) do i = 1 , s if ( is_not_permutation ( m , perm )) cycle if ( ALL ( perm (:, i ) == [( j , j = 1 , m )])) cycle if ( ANY ([( ALL ( perm (:, i ) == perm (:, j )), j = 1 , i - 1 )])) cycle res = [ res , i ] end do end function count_perm ! end function group_permutation_new ! pure function decompose_to_cyclic ( perm ) result ( res ) integer ( IK ), intent ( in ) :: perm (:) integer ( IK ), allocatable :: res (:) integer ( IK ) :: n ! !   early return ! n = SIZE ( perm ) ALLOCATE ( res , source = [ 0 ]) ! if ( n < 2 ) then return elseif ( n == 2 ) then if ( ALL ( perm ( 1 : 2 ) == [ 2 , 1 ])) res = [ 2 , 1 , 2 , 1 , 2 ] return elseif ( n == 3 ) then if ( ALL ( perm ( 1 : 3 ) == [ 1 , 3 , 2 ])) then res = [ 2 , 1 , 2 , 2 , 3 ] elseif ( ALL ( perm ( 1 : 3 ) == [ 2 , 1 , 3 ])) then res = [ 2 , 1 , 2 , 1 , 2 ] elseif ( ALL ( perm ( 1 : 3 ) == [ 2 , 3 , 1 ])) then res = [ 2 , 1 , 3 , 1 , 2 , 3 ] elseif ( ALL ( perm ( 1 : 3 ) == [ 3 , 1 , 2 ])) then res = [ 2 , 1 , 3 , 1 , 3 , 2 ] elseif ( ALL ( perm ( 1 : 3 ) == [ 3 , 2 , 1 ])) then res = [ 2 , 1 , 2 , 1 , 3 ] end if return elseif ( is_not_permutation ( n , perm )) then return end if ! !   decompose to cyclic permutations. ! block integer ( IK ) :: i , j , k , l , w ( 4 * n ) ! do concurrent ( i = 1 : n + n ) w ( i ) = - 1 end do do concurrent ( i = 1 : n ) w ( n + n + i ) = perm ( i ) end do ! i = 1 j = n + 1 k = n + n ! do l = 1 , n k = k + 1 if ( w ( k ) < 0 ) cycle call count_permutation ( n , w ( n + n + 1 ), l , w ( i ), w ( j )) i = i + w ( j ) j = j + 1 end do ! l = j - n - 1 k = n + l ! !     w(1:n) is now stored [b1, b2, ..., bl] !     w(n+1:n+l) is now stored [s1, s2, ..., sl] ! do concurrent ( i = 1 : l ) w ( k + i ) = w ( n + i ) end do call uniq ( l , k , w ( n + l + 1 )) ! !     k                  :: n, number of uniq cyclic order (without 1). !     w(n+l+1:n+l+k)     :: [t1, ..., tk], uniq cyclic order list. !     w(n+l+k+1:n+l+k+k) :: [n1, ..., nk], count of ti. ! !     w is now stored [b1, b2, ..., bl, s1, s2, ..., sl, t1, ..., tk, n1, ..., nk] ! if ( k < 1 ) return ! !     count array size j = 3 * k + SUM ([( w ( n + l + i ) * w ( n + l + k + i ), i = 1 , k )]) ! !     pack w to array. res = proc_w ( n , j , k , l , w ( 1 ), w ( n + 1 ), w ( n + l + k + 1 ), w ( n + l + 1 )) ! end block ! end function decompose_to_cyclic ! pure function proc_w ( nd , nj , nk , nl , b , s , n , t ) result ( res ) integer ( IK ), intent ( in ) :: nd , nj , nk , nl integer ( IK ), intent ( in ) :: n ( nk ), t ( nk ), b ( nd ), s ( nl ) integer ( IK ) :: res ( nj ) integer ( IK ) :: i , j ! res ( 1 ) = nk + 1 res ( nk + 1 ) = n ( 1 ) res ( nk + 2 ) = t ( 1 ) call proc ( nd , nl , t ( 1 ), b , s ( 1 ), res ( nk + 3 )) j = nk + 1 do i = 2 , nk j = j + 2 + t ( i - 1 ) * n ( i - 1 ) res ( i ) = j res ( j ) = n ( i ) res ( j + 1 ) = t ( i ) call proc ( nd , nl , t ( i ), b , s , res ( j + 2 )) end do ! end function proc_w ! pure subroutine proc ( nd , l , t , b , s , res ) integer ( IK ), intent ( in ) :: nd , l , t , b ( nd ), s ( l ) integer ( IK ), intent ( inout ) :: res ( * ) integer ( IK ) :: i , j , k ! j = 1 k = 1 ! do i = 1 , l if ( t == s ( i )) then res ( j : j + t - 1 ) = b ( k : k + t - 1 ) j = j + s ( i ) endif k = k + s ( i ) end do ! end subroutine proc ! !| returns true when perm is not permutation. pure function is_not_permutation ( n , perm ) result ( res ) integer ( IK ), intent ( in ) :: n , perm ( * ) logical :: res integer ( IK ) :: i do i = 1 , n - 1 res = perm ( i ) < 1 . or . n < perm ( i ) . or . ANY ( perm ( i ) == perm ( i + 1 : n )) if ( res ) return end do res = perm ( n ) < 1 . or . n < perm ( n ) end function is_not_permutation ! !| returns cyclic indices and its order. pure subroutine count_permutation ( n , perm , s , l , c ) integer ( IK ), intent ( in ) :: n , s integer ( IK ), intent ( inout ) :: perm ( * ), l ( * ), c integer ( IK ) :: e0 , e ! c = 1 l ( 1 ) = s e0 = s e = perm ( s ) perm ( s ) = - perm ( s ) ! do if ( e < 1 . or . n < e ) then c = - 1 ; return end if if ( e0 == e ) return c = c + 1 l ( c ) = e e = perm ( e ) perm ( l ( c )) = - perm ( l ( c )) end do ! end subroutine count_permutation ! !| returns uniq integer list without 1. pure subroutine uniq ( n , u , res ) integer ( IK ), intent ( in ) :: n integer ( IK ), intent ( inout ) :: u , res ( * ) integer ( IK ) :: i , j ! u = 0 if ( n > 1 ) call qsi ( n , res ) if ( res ( 1 ) > 1 ) u = 1 ! do concurrent ( i = n + 1 + u : n + n + 1 ) res ( i ) = 0 end do ! j = n + 1 + u ! do i = 1 , n - 1 res ( j ) = res ( j ) + 1 if ( res ( i ) == res ( i + 1 )) cycle u = u + 1 j = j + 1 res ( u ) = res ( i + 1 ) end do ! res ( j ) = res ( j ) + 1 ! do concurrent ( i = 1 : u ) res ( u + i ) = res ( n + i + 1 ) end do ! end subroutine uniq ! pure recursive subroutine qsi ( n , s ) integer ( IK ), intent ( in ) :: n integer ( IK ), intent ( inout ) :: s ( n ) integer ( IK ) :: i , j , p , t ! j = n ; i = 1 ; p = j / 2 ! do ! do while ( s ( i ) < s ( p )); i = i + 1 ; end do do while ( s ( j ) > s ( p )); j = j - 1 ; end do ! if ( i >= j ) exit ! t = s ( i ); s ( i ) = s ( j ); s ( j ) = t if ( i == p ) then ; p = j elseif ( j == p ) then ; p = i end if i = i + 1 ; j = j - 1 ! end do ! if ( 2 < i ) call qsi ( i - 1 , s (: i - 1 )) if ( j + 1 < n ) call qsi ( n - j , s ( j + 1 :)) ! end subroutine qsi ! !| nsym of group_permutation pure function group_permutation_nsym ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! work array. integer ( IK ) :: res res = q ( 1 ) end function group_permutation_nsym ! !| Replaces an array of real numbers according to the map s. <br> pure subroutine group_permutation_swap ( q , s , d , X ) integer ( IK ), intent ( in ) :: q ( * ) !! work array. integer ( IK ), intent ( in ) :: s !! permutation index. integer ( IK ), intent ( in ) :: d !! leading dimension of x real ( RK ), intent ( inout ) :: X ( * ) !! data array. ! if ( s < 1 . or . q ( 1 ) <= s ) return ! identity map call swap_real ( q ( q ( s )), d , X ) ! end subroutine group_permutation_swap ! pure subroutine swap_real ( q , d , X ) integer ( IK ), intent ( in ) :: q ( * ) !! swap indices. integer ( IK ), intent ( in ) :: d !! leading dimension of x real ( RK ), intent ( inout ) :: X ( * ) !! data array. integer ( IK ) :: i , m ! m = q ( 1 ) - 1 ! do concurrent ( i = 1 : m ) block integer ( IK ) :: j , p , n , s , ns p = q ( i ) n = q ( p ) p = p + 1 s = q ( p ) p = p + 1 ns = p + ( n - 1 ) * s do concurrent ( j = p : ns : s ) call cyclic_swap_real ( d , s , q ( j ), X ) end do end block end do ! end subroutine swap_real ! !| Replaces an array of real numbers according to the inverse map s. <br> pure subroutine group_permutation_inverse ( q , s , d , X ) integer ( IK ), intent ( in ) :: q ( * ) !! work array. integer ( IK ), intent ( in ) :: s !! permutation index. integer ( IK ), intent ( in ) :: d !! leading dimension of x real ( RK ), intent ( inout ) :: X ( * ) !! data array. ! if ( s < 1 . or . q ( 1 ) <= s ) return ! identity map call inverse_real ( q ( q ( s )), d , X ) ! end subroutine group_permutation_inverse ! pure subroutine inverse_real ( q , d , X ) integer ( IK ), intent ( in ) :: q ( * ) !! swap indices. integer ( IK ), intent ( in ) :: d !! leading dimension of x real ( RK ), intent ( inout ) :: X ( * ) !! data array. integer ( IK ) :: i , m ! m = q ( 1 ) - 1 ! do concurrent ( i = 1 : m ) block integer ( IK ) :: j , p , n , s , ns p = q ( i ) n = q ( p ) p = p + 1 s = q ( p ) p = p + 1 ns = p + ( n - 1 ) * s do concurrent ( j = p : ns : s ) call cyclic_inverse_real ( d , s , q ( j ), X ) end do end block end do ! end subroutine inverse_real ! ! pure subroutine cyclic_swap_int(d, s, q, X) !   integer(IK), intent(in)    :: d, s, q(*) !   integer(IK), intent(inout) :: X(d, *) !   integer(IK)                :: T(d) !   integer(IK)                :: i, j !   do concurrent(i=1:d) !     T(i) = X(i, q(1)) !   end do !   do j = 1, s - 1 !     do concurrent(i=1:d) !       X(i, q(j)) = X(i, q(j + 1)) !     end do !   end do !   do concurrent(i=1:d) !     X(i, q(s)) = T(i) !   end do ! end subroutine cyclic_swap_int ! pure subroutine cyclic_swap_real ( d , s , q , X ) integer ( IK ), intent ( in ) :: d , s , q ( * ) real ( RK ), intent ( inout ) :: X ( d , * ) real ( RK ) :: T ( d ) integer ( IK ) :: i , j do concurrent ( i = 1 : d ) T ( i ) = X ( i , q ( 1 )) end do do j = 1 , s - 1 do concurrent ( i = 1 : d ) X ( i , q ( j )) = X ( i , q ( j + 1 )) end do end do do concurrent ( i = 1 : d ) X ( i , q ( s )) = T ( i ) end do end subroutine cyclic_swap_real ! pure subroutine cyclic_inverse_real ( d , s , q , X ) integer ( IK ), intent ( in ) :: d , s , q ( * ) real ( RK ), intent ( inout ) :: X ( d , * ) real ( RK ) :: T ( d ) integer ( IK ) :: i , j do concurrent ( i = 1 : d ) T ( i ) = X ( i , q ( s )) end do do j = s - 1 , 1 , - 1 do concurrent ( i = 1 : d ) X ( i , q ( j + 1 )) = X ( i , q ( j )) end do end do do concurrent ( i = 1 : d ) X ( i , q ( 1 )) = T ( i ) end do end subroutine cyclic_inverse_real ! pure elemental subroutine group_permutation_destroy ( this ) type ( group_permutation ), intent ( inout ) :: this if ( ALLOCATED ( this % q )) deallocate ( this % q ) end subroutine group_permutation_destroy ! end module mod_group_permutation","tags":"","loc":"sourcefile/mod_group_permutation.f90.html"},{"title":"mod_kinds.f90 – mobbrmsd","text":"Contents Modules mod_kinds Source Code mod_kinds.f90 Source Code !| variable kinds correction module mod_kinds ! use , intrinsic :: ISO_FORTRAN_ENV , only : & & R4 => REAL32 , & & R8 => REAL64 , & & RQ => REAL128 , & & I1 => INT8 , & & I2 => INT16 , & & I4 => INT32 , & & I8 => INT64 ! implicit none private public :: I1 , I2 , I4 , I8 public :: R4 , R8 , RQ public :: RK , IK ! integer , parameter :: IK = KIND ( 0 ) !! Selected integer kind. integer , parameter :: RK = KIND ( 0.0_R8 ) !! Selected real kind. ! end module mod_kinds","tags":"","loc":"sourcefile/mod_kinds.f90.html"},{"title":"mod_c_matrix.f90 – mobbrmsd","text":"Contents Modules mod_c_matrix Source Code mod_c_matrix.f90 Source Code !| A module for managing c-matrices, tensor of covariance matrices. <br> !   \\{\\mathbf{C}_{IJs}\\}_{IJs}  is third-order ( M\\times M\\times s  ) tensor of matrix  \\mathbf{C}_{IJs}\\in\\mathbb{R}&#94;{d\\times d} , !  defined by<br> !   \\mathbf{C}_{IJs} = \\mathbf{Y}_J \\mathbf{Q}_s \\mathbf{X}_I&#94;\\top  !   \\mathbf{X}_I  ::  I -th molecule in reference coordinate,  \\mathbf{X} \\in\\mathbb{R}&#94;{d\\times n}.<br> !   \\mathbf{Y}_J  ::  J -th molecule in target coordinate,     \\mathbf{Y} \\in\\mathbb{R}&#94;{d\\times n} .<br> !   \\mathbf{Q}_s  :: Molecular permutation matrix on  n . <br> !  To quickly find the rotation matrix,  \\mathbf{C}_{IJs}  is stored with autocorrelation  G_{IJ} , defined by <br> !   G_{IJ} = \\text{Tr}\\left[\\mathbf{X}_I\\mathbf{X}_I&#94;\\top\\right] + \\text{Tr}\\left[\\mathbf{Y}_J\\mathbf{Y}_J&#94;\\top\\right]  !  @note !     G_{IJ}  does not change with respect to molecular symmetry permutation index,  s . <br> !    Therefore, data blocks are stored in three-dimensional array C(bs,M,M) !    with the leading dimension with  \\text{bs}=1 + Sd&#94;2 . <br> !    Data blocks are defined by  \\left[ G_{IJ}, \\mathbf{C}_{IJ1}, \\mathbf{C}_{IJ2}, \\dots, \\mathbf{C}_{IJS} \\right]  <br> !  @endnote module mod_c_matrix use mod_dimspec_functions , only : D , DD , compute_cov , covcopy use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO , RHUGE use mod_mol_block implicit none private public :: c_matrix public :: c_matrix_memsize public :: c_matrix_worksize public :: c_matrix_blocksize public :: c_matrix_autocorr public :: c_matrix_eval public :: c_matrix_add public :: c_matrix_swap_indices ! integer ( IK ), parameter :: header_size = 4 ! integer ( IK ), parameter :: nl = 1 !! number of row. nl = n. integer ( IK ), parameter :: cb = 2 !! number of elements in a sell. cb = DD * res%b%s + 1. integer ( IK ), parameter :: cl = 3 !! number of elements in a line. cl = cb * n. integer ( IK ), parameter :: nw = 4 !! number of work array. nw = MAX(dmn + dm, n + n) ! !| C matrix manager. !   This derived type is mainly used for passing during initialization. type c_matrix integer ( IK ) :: q ( header_size ) !! header integer ( IK ), allocatable :: s (:) !! state contains final :: c_matrix_destroy end type c_matrix ! !| Constructer interface c_matrix module procedure c_matrix_new end interface c_matrix ! contains ! !| Constructer pure function c_matrix_new ( b ) result ( res ) integer ( IK ), intent ( in ) :: b ( * ) !! mol_block header, must be initialized. type ( c_matrix ) :: res res % q ( cb ) = 1 + DD * mol_block_nsym ( b ) res % q ( nl ) = mol_block_nmol ( b ) res % q ( cl ) = res % q ( cb ) * res % q ( nl ) res % q ( nw ) = MAX ( & & mol_block_total_size ( b ) + mol_block_each_size ( b ), & & 2 * res % q ( nl ) & & ) allocate ( res % s ( res % q ( nl ))) end function c_matrix_new ! !| Inquire blocksize of c_matrix. pure function c_matrix_blocksize ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! c_matrix header. integer ( IK ) :: res res = q ( cb ) end function c_matrix_blocksize ! !| Inquire memsize of c_matrix. pure function c_matrix_memsize ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! c_matrix header. integer ( IK ) :: res res = q ( cl ) * q ( nl ) end function c_matrix_memsize ! !| Inquire worksize of c_matrix evaluation. pure function c_matrix_worksize ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! c_matrix header. integer ( IK ) :: res res = MERGE ( q ( nw ), 0 , q ( nl ) > 0 ) end function c_matrix_worksize ! !| Evaluation the c-matrix.<br> !  g-matrix is also calculated at the same time.<br> !  At the end of the calculation, save the c-matrix C(cb,M,M) to C(\\*). <br> !  workarray W(\\*) must be larger than c_matrix_worksize(q). <br> pure subroutine c_matrix_eval ( q , b , s , X , Y , CX , CY , C , W , sort_by_g ) integer ( IK ), intent ( in ) :: q ( * ) !! c_matrix header. integer ( IK ), intent ( in ) :: b ( * ) !! mol block header. integer ( IK ), intent ( inout ) :: s ( * ) !! swap_indice real ( RK ), intent ( in ) :: X ( * ) !! reference coordinate, !  \\mathbf{X}. Arrays must be stored as X(D, n_apm, n_mol). real ( RK ), intent ( in ) :: Y ( * ) !! target coordinate, ! \\mathbf{Y}. Arrays must be stored as Y(D, n_apm, n_mol). real ( RK ), intent ( in ) :: CX ( * ) !! centroid of \\mathbf{X}. real ( RK ), intent ( in ) :: CY ( * ) !! centroid of \\mathbf{Y}. real ( RK ), intent ( inout ) :: C ( * ) !! main memory real ( RK ), intent ( inout ) :: W ( * ) !! work memory logical , intent ( in ), optional :: sort_by_g !! if true, row is sorted respect to G of reference coordinate. integer ( IK ), parameter :: gx = 1 integer ( IK ), parameter :: wx = 1 integer ( IK ) :: n_sym , n_apm , gy , wy , i associate ( n_blk => q ( cb ), n_mol => q ( nl )) n_apm = mol_block_napm ( b ) do concurrent ( i = 1 : n_mol ) s ( i ) = i end do if ( n_apm < 1 ) then call zfill ( q ( cl ) * q ( nl ), C , 1 ) return end if n_sym = mol_block_nsym ( b ) gy = gx + n_mol wy = wx + mol_block_total_size ( b ) call eval_g ( D , n_apm , n_mol , X , CX , W ( gx )) call eval_g ( D , n_apm , n_mol , Y , CY , W ( gy )) if ( PRESENT ( sort_by_g )) then if ( sort_by_g . and . n_mol > 1 ) call qs ( n_mol , s , W ( gx )) else if ( n_mol > 1 ) call qs ( n_mol , s , W ( gx )) end if call set_g ( n_mol , n_blk , W ( gx ), W ( gy ), C ) call eval_c_matrix ( b , s , n_sym , n_apm , n_mol , n_blk , X , Y , CX , CY , C , W ( wx ), W ( wy )) end associate end subroutine c_matrix_eval ! ! trace of self correlation matrix pure subroutine eval_g ( D , n_apm , n_mol , X , CX , G ) integer ( IK ), intent ( in ) :: D , n_apm , n_mol real ( RK ), intent ( in ) :: X ( D , n_apm , n_mol ), CX ( D ) real ( RK ), intent ( inout ) :: G ( n_mol ) integer ( IK ) :: i , j , k do concurrent ( k = 1 : n_mol ) G ( k ) = ZERO do j = 1 , n_apm do i = 1 , D G ( k ) = G ( k ) + ( X ( i , j , k ) - CX ( i )) ** 2 end do end do end do end subroutine eval_g ! ! trace of self correlation matrix pure subroutine set_g ( n_mol , n_blk , GX , GY , C ) integer ( IK ), intent ( in ) :: n_mol , n_blk real ( RK ), intent ( in ) :: GX ( * ), GY ( * ) real ( RK ), intent ( inout ) :: C ( n_blk , n_mol , n_mol ) integer ( IK ) :: i , j do concurrent ( i = 1 : n_mol , j = 1 : n_mol ) C ( 1 , i , j ) = GX ( i ) + GY ( j ) end do end subroutine set_g ! ! get correlation matrix \\mathbf{C} = \\mathbf{Y}&#94;{\\top}\\mathbf{X} ! and optimal rotation \\mathbf{R}&#94;{\\top} pure subroutine eval_c_matrix ( b , s , n_sym , n_apm , n_mol , n_blk , X , Y , CX , CY , C , WX , WY ) integer ( IK ), intent ( in ) :: b ( * ), s ( * ), n_sym , n_apm , n_mol , n_blk real ( RK ), intent ( in ) :: X ( D , n_apm , n_mol ), Y ( D , n_apm , n_mol ) real ( RK ), intent ( in ) :: CX ( D ), CY ( D ) real ( RK ), intent ( inout ) :: C ( n_blk , n_mol , n_mol ), WX ( D , n_apm , n_mol ), WY ( D , n_apm ) integer ( IK ) :: i do concurrent ( i = 1 : n_mol ) call covcopy ( D , n_apm , X ( 1 , 1 , s ( i )), CX , WX ( 1 , 1 , i )) end do do i = 1 , n_mol call covcopy ( D , n_apm , Y ( 1 , 1 , i ), CY , WY ) call calc_covariance ( b , n_sym , n_apm , n_mol , n_blk , WX , WY , C ( 1 , 1 , i )) end do end subroutine eval_c_matrix ! pure subroutine calc_covariance ( b , n_sym , n_apm , n_mol , n_blk , WX , WY , C ) integer ( IK ), intent ( in ) :: b ( * ), n_sym , n_apm , n_mol , n_blk real ( RK ), intent ( in ) :: WX ( D , n_apm , n_mol ) real ( RK ), intent ( inout ) :: WY ( D , n_apm ), C ( n_blk , n_mol ) integer ( IK ) :: i , j , ic ic = 2 do concurrent ( i = 1 : n_mol ) call compute_cov ( D , n_apm , WX ( 1 , 1 , i ), WY , C ( ic , i )) end do do j = 1 , n_sym - 1 ic = ic + DD call mol_block_swap ( b , j , WY ) do concurrent ( i = 1 : n_mol ) call compute_cov ( D , n_apm , WX ( 1 , 1 , i ), WY , C ( ic , i )) end do call mol_block_inverse_swap ( b , j , WY ) end do end subroutine calc_covariance ! !| Calc  G:=\\text{tr}[\\mathbf{X}\\mathbf{X}&#94;\\top]+\\text{tr}[\\mathbf{Y}\\mathbf{Y}&#94;\\top] . <br> pure subroutine c_matrix_autocorr ( q , C , G ) integer ( IK ), intent ( in ) :: q ( * ) !! c_matrix real ( RK ), intent ( in ) :: C ( * ) !! main memory, calculated by c_matrix_eval. real ( RK ), intent ( inout ) :: G !! partial covariance matrix, must be larger than d&#94;2. integer ( IK ) :: i , nn , nc nn = q ( nl ) * q ( nl ) * q ( cb ) nc = ( 1 + q ( nl )) * q ( cb ) G = ZERO do i = 1 , nn , nc G = G + C ( i ) end do end subroutine c_matrix_autocorr ! !| Adds  G_{IJ}  and  \\mathbf{C}_{IJs}  specified by index  i, j, s  to the arguments. <br> !  This routine adds directly to G and C(:DD), so they must be initialized. <br> !  If indices outside the area defined by q(*) is specified, operation results are not guaranteed. <br> pure subroutine c_matrix_add ( q , i , j , s , C , G , Cp ) integer ( IK ), intent ( in ) :: q ( * ) !! c_matrix integer ( IK ), intent ( in ) :: i !! row index integer ( IK ), intent ( in ) :: j !! collumn index integer ( IK ), intent ( in ) :: s !! symmetry index real ( RK ), intent ( in ) :: C ( * ) !! main memory, calculated by c_matrix_eval. real ( RK ), intent ( inout ) :: G !! partial auto variance matrix. real ( RK ), intent ( inout ) :: Cp ( * ) !! partial covariance matrix, must be larger than d&#94;2. integer ( IK ) :: k ! k = q ( cl ) * ( i - 1 ) + q ( cb ) * ( j - 1 ) + 1 G = G + C ( k ) k = k + 1 + DD * ( s - 1 ) call xpy ( DD , C ( k ), Cp ) ! end subroutine c_matrix_add ! !| returns swap(z) pure subroutine c_matrix_swap_indices ( q , s , z , res ) integer ( IK ), intent ( in ) :: q ( * ) !! header integer ( IK ), intent ( in ) :: s ( * ) !! state integer ( IK ), intent ( in ) :: z ( * ) !! permutation integer ( IK ), intent ( inout ) :: res ( * ) !! swap indice integer ( IK ) :: i do concurrent ( i = 1 : q ( nl )) res ( i ) = s ( z ( i )) end do end subroutine c_matrix_swap_indices ! pure elemental subroutine c_matrix_destroy ( this ) type ( c_matrix ), intent ( inout ) :: this if ( ALLOCATED ( this % s )) deallocate ( this % s ) end subroutine c_matrix_destroy ! ! --- ! pure subroutine zfill ( d , x , ld ) integer ( IK ), intent ( in ) :: d real ( RK ), intent ( inout ) :: x ( * ) integer ( IK ), intent ( in ) :: ld integer ( IK ) :: i , dld dld = d * ld do concurrent ( i = 1 : dld : ld ) x ( i ) = ZERO end do end subroutine zfill ! pure subroutine xpy ( N , X , Y ) integer ( IK ), intent ( in ) :: N real ( RK ), intent ( in ) :: X ( * ) real ( RK ), intent ( inout ) :: Y ( * ) integer ( IK ) :: i do concurrent ( i = 1 : N ) Y ( i ) = X ( i ) + Y ( i ) end do end subroutine xpy ! ! pure subroutine copy(N, X, Y) !   integer(IK), intent(in) :: N !   real(RK), intent(in)    :: X(*) !   real(RK), intent(inout) :: Y(*) !   integer(IK)             :: i !   do concurrent(i=1:N) !     Y(i) = X(i) !   end do ! end subroutine copy ! !| Quick sort pure recursive subroutine qs ( n , s , g ) integer , intent ( in ) :: n integer , intent ( inout ) :: s ( * ) real ( RK ), intent ( inout ) :: g ( * ) real ( RK ) :: h integer :: i , j , p , t j = n ; i = 1 ; p = j / 2 do do while ( g ( i ) > g ( p )); i = i + 1 ; end do do while ( g ( j ) < g ( p )); j = j - 1 ; end do if ( i >= j ) exit h = g ( i ); g ( i ) = g ( j ); g ( j ) = h t = s ( i ); s ( i ) = s ( j ); s ( j ) = t if ( i == p ) then ; p = j elseif ( j == p ) then ; p = i end if i = i + 1 ; j = j - 1 end do if ( 2 < i ) call qs ( i - 1 , s ( 1 ), g ( 1 )) if ( j < n - 1 ) call qs ( n - j , s ( j + 1 ), g ( j + 1 )) end subroutine qs ! end module mod_c_matrix","tags":"","loc":"sourcefile/mod_c_matrix.f90.html"},{"title":"mod_bb_list.f90 – mobbrmsd","text":"Contents Modules mod_bb_list Source Code mod_bb_list.f90 Source Code !| Manage multiple bb_blocks and execute multi-component Branch-and-Bound. module mod_bb_list use mod_params , only : IK , RK , ONE => RONE , HALF => RHALF , ZERO => RZERO , RHUGE use mod_dimspec_functions , only : D , DD , compute_com use mod_bb_block use mod_rotation implicit none private public :: bb_list public :: bb_list_memsize public :: bb_list_n_block public :: bb_list_n_atoms public :: bb_list_log_n_nodes public :: bb_list_setup public :: bb_list_run public :: bb_list_swap_y public :: bb_list_rotation_matrix public :: bb_list_is_finished public :: bb_list_INDEX_TO_AUTOCORR public :: bb_list_INDEX_TO_UPPERBOUND public :: bb_list_INDEX_TO_LOWERBOUND public :: bb_list_INDEX_TO_N_EVAL public :: bb_list_INDEX_TO_LOG_N_COMB ! integer ( IK ), parameter :: header_size = 1 integer ( IK ), parameter :: bb_list_NUMBER_OF_SPEACIES = 1 ! number of block ! integer ( IK ), parameter :: header_sttsize = 1 integer ( IK ), parameter :: bb_list_INDEX_TO_SPEACIES = 1 integer ( IK ), parameter :: bb_list_INDEX_TO_BESTSTATE = 2 ! pointer to best state vector ! integer ( IK ), parameter :: bb_list_INDEX_TO_AUTOCORR = 1 integer ( IK ), parameter :: bb_list_INDEX_TO_UPPERBOUND = 2 integer ( IK ), parameter :: bb_list_INDEX_TO_LOWERBOUND = 3 integer ( IK ), parameter :: bb_list_INDEX_TO_N_EVAL = 4 integer ( IK ), parameter :: bb_list_INDEX_TO_LOG_N_COMB = 5 integer ( IK ), parameter :: header_memsize = & & SIZE ([ & & bb_list_INDEX_TO_AUTOCORR , & & bb_list_INDEX_TO_UPPERBOUND , & & bb_list_INDEX_TO_LOWERBOUND , & & bb_list_INDEX_TO_N_EVAL , & & bb_list_INDEX_TO_LOG_N_COMB & & ]) !| This derived type is mainly used for passing during initialization. type bb_list integer ( IK ), allocatable :: q (:) !! integer array integer ( IK ), allocatable :: s (:) !! work integer array contains final :: bb_list_destroy end type bb_list ! !| Constructer interface bb_list module procedure bb_list_new end interface bb_list ! contains !| Constructer pure function bb_list_new ( blk ) result ( res ) type ( bb_block ), intent ( in ) :: blk (:) type ( bb_list ) :: res integer ( IK ) :: q ( header_size ), s ( header_sttsize ) integer ( IK ) :: pq ( SIZE ( blk )), px ( SIZE ( blk )), ps ( SIZE ( blk )), pw ( SIZE ( blk )) integer ( IK ) :: i , j , nstat associate ( & & nb => q ( bb_list_NUMBER_OF_SPEACIES ), & & sb => s ( bb_list_INDEX_TO_SPEACIES ) & & ) nb = SIZE ( blk ) sb = 0 ! j = header_size + 4 * nb + 1 do i = 1 , nb pq ( i ) = j j = j + SIZE ( blk ( i )% q ) end do nstat = SUM ([( bb_block_statesize ( blk ( i )% q ), i = 1 , nb )]) j = header_sttsize + nstat + 1 do i = 1 , nb ps ( i ) = j j = j + SIZE ( blk ( i )% s ) end do j = header_memsize + 1 do i = 1 , nb pw ( i ) = j j = j + bb_block_memsize ( blk ( i )% q ) + bb_block_worksize ( blk ( i )% q ) end do j = 1 do i = 1 , nb px ( i ) = j j = j + bb_block_molsize ( blk ( i )% q ) end do ! allocate ( res % q , source = [ q , pq , ps , pw , px , [( blk ( i )% q , i = 1 , SIZE ( blk ))]]) allocate ( res % s , source = [ s , [( - 1 , i = 1 , nstat )], [( blk ( i )% s , i = 1 , SIZE ( blk ))]]) end associate end function bb_list_new ! !| Inquire worksize of f_matrix. pure function bb_list_memsize ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! bb_block. integer ( IK ) :: res , i , j associate ( n => q ( bb_list_NUMBER_OF_SPEACIES )) res = header_memsize j = q_pointer ( q ) do i = 1 , n res = res + bb_block_memsize ( q ( q ( j ))) + bb_block_worksize ( q ( q ( j ))) j = j + 1 end do end associate end function bb_list_memsize ! !| Setup pure subroutine bb_list_setup ( q , s , X , Y , W , remove_com , sort_by_g ) integer ( IK ), intent ( in ) :: q ( * ) !! header integer ( IK ), intent ( inout ) :: s ( * ) !! state real ( RK ), intent ( in ) :: X ( * ) !! reference coordinate real ( RK ), intent ( in ) :: Y ( * ) !! target coordinate real ( RK ), intent ( inout ) :: W ( * ) !! work array logical , intent ( in ), optional :: remove_com !! if true, remove centroids. default [.true.] logical , intent ( in ), optional :: sort_by_g !! if true, row is sorted respect to G of reference coordinate. default [.true.] real ( RK ) :: CX ( D ), CY ( D ) !! centroids integer ( IK ) :: i , ps , pq , px , pw , n_atoms associate ( & n_block => q ( bb_list_NUMBER_OF_SPEACIES ), & & sb => s ( bb_list_INDEX_TO_SPEACIES ), & & ac => W ( bb_list_INDEX_TO_AUTOCORR ), & & ub => W ( bb_list_INDEX_TO_UPPERBOUND ), & & lb => W ( bb_list_INDEX_TO_LOWERBOUND ), & & nv => W ( bb_list_INDEX_TO_N_EVAL ), & & cm => W ( bb_list_INDEX_TO_LOG_N_COMB ) & & ) sb = 0 ub = RHUGE lb = - RHUGE nv = ZERO ps = s_pointer ( q ) px = x_pointer ( q ) pw = w_pointer ( q ) pq = q_pointer ( q ) ! n_atoms = bb_list_n_atoms ( q ) ! if ( PRESENT ( remove_com )) then if ( remove_com ) then call compute_com ( D , n_atoms , X , CX ) call compute_com ( D , n_atoms , Y , CY ) else CX = ZERO ; CY = ZERO end if else call compute_com ( D , n_atoms , X , CX ) call compute_com ( D , n_atoms , Y , CY ) end if ! do concurrent ( i = 0 : n_block - 1 ) call bb_block_setup ( & & q ( q ( pq + i )), & & X ( q ( px + i )), & & Y ( q ( px + i )), & & CX , CY , & & s ( q ( ps + i )), W ( q ( pw + i )), & & zfill = ( i == 0 ),& & sort_by_g = sort_by_g & & ) end do ! ac = ZERO do i = n_block - 1 , 0 , - 1 call bb_block_set_ub_offset ( W ( q ( pw + i )), ac ) ac = ac + bb_block_lowerbound ( W ( q ( pw + i ))) end do ac = ZERO do i = 0 , n_block - 1 ac = ac + bb_block_autocorr ( q ( q ( pq + i )), W ( q ( pw + i ))) end do cm = ZERO do i = 0 , n_block - 1 cm = cm + bb_block_log_ncomb ( q ( q ( pq + i ))) end do call save_state ( q ( pq ), q ( ps ), q , s ) end associate end subroutine bb_list_setup ! !| run branch and bound pure subroutine bb_list_run ( q , s , W , cutoff , difflim , maxeval ) integer ( IK ), intent ( in ) :: q ( * ) !! header integer ( IK ), intent ( inout ) :: s ( * ) !! state real ( RK ), intent ( inout ) :: W ( * ) !! work array real ( RK ), intent ( in ), optional :: cutoff !! The search ends when lowerbound is determined !  to be greater than to cutoff (in RMSD). real ( RK ), intent ( in ), optional :: difflim !! The search ends when the difference !  between the lower and upper bounds is less than difflim. integer ( IK ), intent ( in ), optional :: maxeval !! The search ends when ncount exceeds maxiter. !  If maxeval=0, run only once, and early return. real ( RK ) :: coff , diff , nlim integer ( IK ) :: pq , ps , pw associate ( & & b => s ( bb_list_INDEX_TO_SPEACIES ), & & au => W ( bb_list_INDEX_TO_AUTOCORR ), & & ub => W ( bb_list_INDEX_TO_UPPERBOUND ), & & lb => W ( bb_list_INDEX_TO_LOWERBOUND ), & & nv => W ( bb_list_INDEX_TO_N_EVAL ) & & ) b = MAX ( b , 1 ) pq = q_pointer ( q ) ps = s_pointer ( q ) pw = w_pointer ( q ) if ( PRESENT ( cutoff )) then coff = MIN ( ZERO , HALF * ( cutoff ** 2 * bb_list_n_atoms ( q ) - au )) else coff = RHUGE end if if ( PRESENT ( difflim )) then diff = MAX ( ZERO , difflim ) else diff = ZERO end if ! if ( PRESENT ( maxeval )) then if ( maxeval == 0 ) then call run_bb ( q ( pq ), q ( ps ), q ( pw ), q , s , W ) ! run only once, and early return. return elseif ( maxeval > 0 ) then nlim = real ( maxeval , RK ) ! finite run else nlim = RHUGE ! unlimited run if maxeval < 0 end if else nlim = RHUGE ! unlimited run end if ! call update_lowerbound ( b , q ( pq ), q ( ps ), q ( pw ), q , s , W ) ! do while ( nv < nlim & & . and . lb < coff & & . and . lb + diff <= ub ) call run_bb ( q ( pq ), q ( ps ), q ( pw ), q , s , W ) if ( bb_list_is_finished ( q , s )) exit end do end associate end subroutine bb_list_run ! pure subroutine run_bb ( pq , ps , pw , q , s , W ) integer ( IK ), intent ( in ) :: pq ( * ), ps ( * ), pw ( * ), q ( * ) integer ( IK ), intent ( inout ) :: s ( * ) real ( RK ), intent ( inout ) :: W ( * ) associate ( & & n => q ( bb_list_NUMBER_OF_SPEACIES ), & & b => s ( bb_list_INDEX_TO_SPEACIES ), & & ub => W ( bb_list_INDEX_TO_UPPERBOUND ), & & lb => W ( bb_list_INDEX_TO_LOWERBOUND ), & & nv => W ( bb_list_INDEX_TO_N_EVAL ) & & ) ! !     Expansion process ! do call bb_block_expand ( ub , q ( pq ( b )), s ( ps ( b )), W ( pw ( b ))) if ( b == n . or . bb_block_tree_is_empty ( q ( pq ( b )), s ( ps ( b )))) exit b = b + 1 call bb_block_inheritance ( q ( pq ( b )), s ( ps ( b )), W ( pw ( b )), & & q ( pq ( b - 1 )), s ( ps ( b - 1 )), W ( pw ( b - 1 ))) end do ! !     Update upperbound and state ! if ( bb_block_is_bottom ( q ( pq ( b )), s ( ps ( b ))) . and . b == n ) then block real ( RK ) :: cv cv = bb_block_current_value ( q ( pq ( b )), s ( ps ( b )), W ( pw ( b ))) if ( ub > cv ) then ub = cv call save_state ( pq , ps , q , s ) end if end block end if ! !     Update lowerbound ! call update_lowerbound ( b , pq , ps , pw , q , s , W ) ! !     Closure process ! do call bb_block_closure ( ub , q ( pq ( b )), s ( ps ( b )), W ( pw ( b ))) if ( b == 1 . or . bb_block_is_left ( ub , q ( pq ( b )), s ( ps ( b )), W ( pw ( b )))) exit b = b - 1 end do ! block integer ( IK ) :: i nv = ZERO do i = 1 , n nv = nv + bb_block_evaluation_count ( W ( pw ( i ))) end do end block end associate end subroutine run_bb ! pure subroutine update_lowerbound ( n , pq , ps , pw , q , s , W ) integer ( IK ), intent ( in ) :: n , pq ( n ), ps ( n ), pw ( n ) integer ( IK ), intent ( in ) :: q ( * ), s ( * ) real ( RK ), intent ( inout ) :: W ( * ) real ( RK ) :: lv integer ( IK ) :: b associate ( & & ub => W ( bb_list_INDEX_TO_UPPERBOUND ), & & lb => W ( bb_list_INDEX_TO_LOWERBOUND ) & & ) lv = RHUGE do b = 1 , n lv = MIN ( lv , bb_block_lowest_value ( q ( pq ( b )), s ( ps ( b )), W ( pw ( b )))) end do lb = MIN ( MAX ( lb , lv ), ub ) end associate end subroutine update_lowerbound ! pure subroutine save_state ( pq , ps , q , s ) integer ( IK ), intent ( in ) :: pq ( * ), ps ( * ) integer ( IK ), intent ( in ) :: q ( * ) integer ( IK ), intent ( inout ) :: s ( * ) integer ( IK ) :: i , j associate ( n => q ( bb_list_NUMBER_OF_SPEACIES )) j = bb_list_INDEX_TO_BESTSTATE do i = 1 , n call bb_block_save_state ( q ( pq ( i )), s ( ps ( i )), s ( j )) j = j + bb_block_statesize ( q ( pq ( i ))) end do end associate end subroutine save_state ! !| Swap target coordinate. pure subroutine bb_list_swap_y ( q , s , Y ) integer ( IK ), intent ( in ) :: q ( * ) !! header integer ( IK ), intent ( in ) :: s ( * ) !! state real ( RK ), intent ( inout ) :: Y ( * ) !! target coordinate integer ( IK ) :: i , pb , pq , ps , px associate ( n_block => q ( bb_list_NUMBER_OF_SPEACIES )) px = x_pointer ( q ) ps = s_pointer ( q ) pq = q_pointer ( q ) pb = bb_list_INDEX_TO_BESTSTATE ! do i = 0 , n_block - 1 call bb_block_swap_y ( q ( q ( pq + i )), s ( q ( ps + i )), s ( pb ), Y ( q ( px + i ))) pb = pb + bb_block_statesize ( q ( q ( pq + i ))) end do end associate end subroutine bb_list_swap_y ! !| Sum covariance matrix by saved state z. pure subroutine bb_list_rotation_matrix ( q , s , W , R ) integer ( IK ), intent ( in ) :: q ( * ) !! integer array integer ( IK ), intent ( in ) :: s ( * ) !! state real ( RK ), intent ( in ) :: W ( * ) !! main memory real ( RK ), intent ( inout ) :: R ( * ) !! rotation matrix real ( RK ) :: G , C ( DD ), V ( rotation_worksize ()) integer ( IK ) :: i , pb , pq , pw associate ( n_block => q ( bb_list_NUMBER_OF_SPEACIES )) pb = bb_list_INDEX_TO_BESTSTATE pw = w_pointer ( q ) pq = q_pointer ( q ) ! G = ZERO C = ZERO ! do i = 0 , n_block - 1 call bb_block_covmat_add ( q ( q ( pq + i )), s ( pb ), W ( q ( pw + i )), G , C ) pb = pb + bb_block_nmol ( q ( q ( pq + i ))) end do ! call estimate_rotation ( G , C , R , V ) end associate end subroutine bb_list_rotation_matrix ! !| Returns number of molecular blocks. pure function bb_list_n_block ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! bb_block. integer ( IK ) :: res associate ( n_block => q ( bb_list_NUMBER_OF_SPEACIES )) res = n_block end associate end function bb_list_n_block ! !| Returns number of total atoms. pure function bb_list_n_atoms ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! bb_block. integer ( IK ) :: res , i , j associate ( n_block => q ( bb_list_NUMBER_OF_SPEACIES )) res = 0 j = q_pointer ( q ) do i = 1 , n_block res = res + bb_block_natm ( q ( q ( j ))) j = j + 1 end do end associate end function bb_list_n_atoms ! !| Returns the logarithm of the total number of nodes. pure function bb_list_log_n_nodes ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! bb_block. integer ( IK ) :: i , j real ( RK ) :: res associate ( n_block => q ( bb_list_NUMBER_OF_SPEACIES )) res = ZERO j = q_pointer ( q ) do i = 1 , n_block res = res + bb_block_log_ncomb ( q ( q ( j ))) j = j + 1 end do end associate end function bb_list_log_n_nodes ! !| Returns bb is finished. pure function bb_list_is_finished ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! header integer ( IK ), intent ( in ) :: s ( * ) !! state logical :: res integer ( IK ) :: bq , bs associate ( sb => s ( bb_list_INDEX_TO_SPEACIES )) !     early return res = sb == 1 ; if (. not . res ) return bq = q ( q_pointer ( q ) + sb - 1 ) bs = q ( s_pointer ( q ) + sb - 1 ) res = bb_block_tree_is_finished ( q ( bq ), s ( bs )) end associate end function bb_list_is_finished ! !| destractor pure elemental subroutine bb_list_destroy ( this ) type ( bb_list ), intent ( inout ) :: this if ( ALLOCATED ( this % q )) deallocate ( this % q ) end subroutine bb_list_destroy ! !  --- ! pure function s_pointer ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) integer ( IK ) :: res res = header_size + q ( bb_list_NUMBER_OF_SPEACIES ) + 1 end function s_pointer ! pure function w_pointer ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) integer ( IK ) :: res res = header_size + 2 * q ( bb_list_NUMBER_OF_SPEACIES ) + 1 end function w_pointer ! pure function x_pointer ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) integer ( IK ) :: res res = header_size + 3 * q ( bb_list_NUMBER_OF_SPEACIES ) + 1 end function x_pointer ! pure function q_pointer ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) integer ( IK ) :: res res = header_size + 1 end function q_pointer ! end module mod_bb_list","tags":"","loc":"sourcefile/mod_bb_list.f90.html"},{"title":"mod_tree.f90 – mobbrmsd","text":"Contents Modules mod_tree Source Code mod_tree.f90 Source Code !| Factorial tree for branch and bound. <br> !   This structure handles factorial trees with nodes of constant memory size, ld. <br> ! !   The factorial tree is completely defined by the number of level M\\in\\mathbb Z and a constant S\\in\\mathbb Z. !   A node in level p\\in \\{1,2,\\dots,M\\} has (M-p)S childs, !   and each level has S&#94;p \\prod_{i=1}&#94;p (M-i+1) nodes. !   Here, only M-p+1 nodes for level p=1,2,\\dots,M are kept as state vector. !   All other information is discarded. <br> ! !   The tree informations are kept by header q(\\*) and state vector s(\\*). <br> ! !   @note !   q(\\*) constant and should be treated as an immutable variable. <br> !   However, it is defined as an integer array !   so that it can be treated as part of a data structure !   at a higher level imprementation. !   @endnote ! !   The tree type has states p and \\mathbf{q}&#94;{(p)}, !   where p=1,2,\\dots,M is the current level !   and \\mathbf{q}&#94;{(p)}=\\{q_1&#94;{(p)},q_2&#94;{(p)},\\dots,q_p&#94;{(p)}\\} is the selected node indices. !   Let q&#94;*:=q_p&#94;{(p)} be current node, !   and a retained nodes belonging to p is defined as a p-queue. <br> ! !   A p-queue has one of the following states, !   corresponding to the state of the current node. <br> !   - Node i is selected :: q_i&#94;{(p)} \\in [0,1,\\dots,(M-p+1)S-1]<br> !   - p-queue is unexplored :: q_i&#94;{(p)} = -1<br> !   - p-queue is explored :: q_i&#94;{(p)} < -1<br> ! !   The real data is kept in an external heap in the form W(ld, \\*). !   The value stored in W(1, \\*) is treated as a node evaluation value. !   (to be implemented by the user). <br> ! !   @note !   W can be updated dynamically, !   but changes to the memory referenced by nodes !   in the hierarchy below p will destroy the tree structure. !   The user should control when to update W. <br> !   @endnote ! module mod_tree use mod_params , only : IK , RK , ONE => RONE , TEN => RTEN , ZERO => RZERO , RHUGE , LN_TO_L10 implicit none private public :: tree public :: tree_nnodes public :: tree_current_level public :: tree_current_state public :: tree_current_nnodes public :: tree_current_iper public :: tree_current_isym public :: tree_queue_pointer public :: tree_current_pointer public :: tree_node_pointer public :: tree_current_sequence public :: tree_current_permutation public :: tree_sequence_to_permutation public :: tree_current_mapping public :: tree_sequence_to_mapping public :: tree_expand public :: tree_leave public :: tree_select_top_node public :: tree_lowest_value public :: tree_reset public :: tree_n_sym public :: tree_n_perm public :: tree_n_depth public :: tree_log_ncomb public :: tree_ncomb_frac public :: tree_ncomb_exp public :: tree_is_empty public :: tree_is_unexplored public :: tree_queue_is_empty public :: tree_queue_is_selected public :: tree_queue_is_left public :: tree_queue_is_explored public :: tree_queue_is_unexplored public :: tree_queue_is_root public :: tree_queue_is_bottom ! !| Factorial tree.<br> !   @note !   This type is mainly used for passing during initialization. !   @endnote type tree integer ( IK ), allocatable :: q (:) !!  header integer ( IK ), allocatable :: s (:) !!  state contains final :: tree_destroy end type tree ! ! Constructer interface tree module procedure tree_new end interface tree ! ! --- pointers. integer ( IK ), parameter :: queue_headersize = 2 integer ( IK ), parameter :: qs = 1 ! scaling. integer ( IK ), parameter :: qd = 2 ! tree depth. integer ( IK ), parameter :: qr = 3 ! pointer to top node ! integer ( IK ), parameter :: queue_blocksize = 2 integer ( IK ), parameter :: qp = 1 integer ( IK ), parameter :: qn = 2 ! integer ( IK ), parameter :: state_headersize = 1 integer ( IK ), parameter :: sl = 1 ! current level integer ( IK ), parameter :: sr = 2 ! top node state. ! integer ( IK ), parameter :: state_blocksize = 1 integer ( IK ), parameter :: ss = 1 ! queue state ! ! ---state parameter. integer ( IK ), parameter :: is_unexplored = - 1 integer ( IK ), parameter :: is_explored = - 2 ! contains ! !| Constructer pure function tree_new ( nmol , nsym ) result ( res ) integer ( IK ), intent ( in ) :: nmol !! number of molecule integer ( IK ), intent ( in ) :: nsym !! number of molecular symmetry type ( tree ) :: res integer ( IK ) :: i , j , k , l ! allocate ( res % q ( queue_headersize + queue_blocksize * nmol )) allocate ( res % s ( state_headersize + state_blocksize * nmol )) ! res % q ( qs ) = nsym res % q ( qd ) = nmol ! j = res % q ( qs ) * res % q ( qd ) k = 1 l = qr ! top node pointer ! do i = 1 , res % q ( qd ) call queue_init ( j , k , res % q ( l )) k = k + j j = j - res % q ( qs ) l = l + queue_blocksize end do ! call tree_reset ( res % q , res % s ) ! end function tree_new ! !| Initializer of queue pure subroutine queue_init ( n_nodes , p , q ) integer ( IK ), intent ( in ) :: n_nodes !!  n_nodes :: number of nodes in queue, n_nodes>0. integer ( IK ), intent ( in ) :: p !!  p :: offset of pointer integer ( IK ), intent ( inout ) :: q ( * ) !!  q :: queue array !   q(qi) = is_unexplored    ! current state -> unexplored q ( qp ) = p ! pointer to work array. q ( qn ) = MAX ( 1 , n_nodes ) ! max number of nodes in this queue. end subroutine queue_init ! !| Reset the state pure subroutine tree_reset ( q , s ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( inout ) :: s ( * ) !!  state integer ( IK ) :: i ! s ( sl ) = 1 ! current level do concurrent ( i = 1 : q ( qd )) s ( sr + state_blocksize * ( i - 1 ) + ss - 1 ) = is_unexplored ! queue state end do ! end subroutine tree_reset ! !| Inquire number of nodes, !  defined by S\\sum_{i=1}&#94;{M}(M-i+1)=SM(M+1)/2. pure function tree_nnodes ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ) :: res , i res = 0 do i = 1 , q ( qd ) res = res + queue_nnodes ( q ( qr ), i ) end do end function tree_nnodes ! !| Returns current level, p. pure function tree_current_level ( s ) result ( res ) integer ( IK ), intent ( in ) :: s ( * ) !!  state integer ( IK ) :: res res = s ( sl ) end function tree_current_level ! !| Returns the state of current node, q&#94;*. pure function tree_current_state ( s ) result ( res ) integer ( IK ), intent ( in ) :: s ( * ) !!  state integer ( IK ) :: res res = queue_state ( s ( sr ), s ( sl )) end function tree_current_state ! !| Returns the number of nodes in p-queue. pure function tree_current_nnodes ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state integer ( IK ) :: res res = queue_nnodes ( q ( qr ), s ( sl )) end function tree_current_nnodes ! !| Returns current permutation indices of q&#94;*. pure function tree_current_iper ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state integer ( IK ) :: res res = queue_state ( s ( sr ), s ( sl )) / q ( qs ) end function tree_current_iper ! !| Returns current mapping index of q&#94;*. pure function tree_current_isym ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state integer ( IK ) :: res res = MODULO ( queue_state ( s ( sr ), s ( sl )), q ( qs )) end function tree_current_isym ! !| Returns a pointer to the current queue. pure function tree_queue_pointer ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state integer ( IK ) :: res res = queue_pointer ( q ( qr ), s ( sl )) end function tree_queue_pointer ! !| Returns a pointer to the current node, q&#94;*. pure function tree_current_pointer ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state integer ( IK ) :: res res = queue_node_pointer ( q ( qr ), s , queue_state ( s ( sr ), s ( sl ))) end function tree_current_pointer ! !| Returns a pointer to a node specified by iper, isym. pure function tree_node_pointer ( q , s , iper , isym ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state integer ( IK ), intent ( in ) :: iper !!  permutation index, must be [0,1,...,q%n/s-1]. integer ( IK ), intent ( in ) :: isym !!  mapping index, must be [0,1,...,s-1]. integer ( IK ) :: res res = queue_node_pointer ( q ( qr ), s , iper * q ( qs ) + isym ) end function tree_node_pointer ! !| Returns current sequence indices. pure function tree_current_sequence ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state integer ( IK ) :: i , res ( q ( qd )) do concurrent ( i = 1 : q ( qd )) res ( i ) = queue_state ( s ( sr ), i ) end do end function tree_current_sequence ! !| Returns current permutation indices. pure function tree_current_permutation ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state integer ( IK ) :: res ( q ( qd )) integer ( IK ) :: i , j , p , t do concurrent ( i = 1 : q ( qd )) res ( i ) = i end do do i = 1 , s ( sl ) p = queue_state ( s ( sr ), i ) if ( p < 0 ) return if ( p < q ( qs )) cycle ! cyclic swap res(i:p) p = i + p / q ( qs ) t = res ( p ) do j = p , i + 1 , - 1 res ( j ) = res ( j - 1 ) end do res ( i ) = t end do end function tree_current_permutation ! !| Convert sequence to permutation. pure function tree_sequence_to_permutation ( q , z ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: z ( * ) !!  state integer ( IK ) :: res ( q ( qd )) integer ( IK ) :: i , j , p , t do concurrent ( i = 1 : q ( qd )) res ( i ) = i end do do i = 1 , q ( qd ) if ( z ( i ) < 0 ) return if ( z ( i ) < q ( qs )) cycle ! cyclic swap res(i:p) p = i + z ( i ) / q ( qs ) t = res ( p ) do j = p , i + 1 , - 1 res ( j ) = res ( j - 1 ) end do res ( i ) = t end do end function tree_sequence_to_permutation ! !| Returns current mapping indices. pure function tree_current_mapping ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state integer ( IK ) :: i , res ( q ( qd )) do concurrent ( i = 1 : q ( qd )) res ( i ) = MODULO ( queue_state ( s ( sr ), i ), q ( qs )) end do end function tree_current_mapping ! !| Convert sequence to mapping. pure function tree_sequence_to_mapping ( q , z ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: z ( * ) !!  state integer ( IK ) :: i , res ( q ( qd )) do concurrent ( i = 1 : q ( qd )) res ( i ) = MODULO ( z ( i ), q ( qs )) end do end function tree_sequence_to_mapping ! !| Expand current node. pure subroutine tree_expand ( q , s ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( inout ) :: s ( * ) !!  state if ( tree_queue_is_bottom ( q , s )) return s ( sl ) = s ( sl ) + 1 call set_state ( s , is_unexplored ) end subroutine tree_expand ! !| Leave current node. pure subroutine tree_leave ( q , s ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( inout ) :: s ( * ) !!  state if ( s ( sl ) > 1 ) s ( sl ) = s ( sl ) - 1 end subroutine tree_leave ! !| Select top node, using W(1, \\*). pure subroutine tree_select_top_node ( q , s , ld , UB , W ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( inout ) :: s ( * ) !!  state integer ( IK ), intent ( in ) :: ld !!  leading dimension real ( RK ), intent ( in ) :: UB !!  upperbound real ( RK ), intent ( in ) :: W ( ld , * ) !!  work array real ( RK ) :: uv , lv integer ( IK ) :: i , p1 , pn , cp ! uv = UB ! if ( tree_queue_is_explored ( q , s )) then return elseif ( tree_queue_is_unexplored ( q , s )) then cp = tree_queue_pointer ( q , s ) - 1 lv = - RHUGE else cp = tree_current_pointer ( q , s ) lv = W ( 1 , cp ) end if ! call set_state ( s , is_explored ) ! if ( uv < lv ) return ! p1 = tree_queue_pointer ( q , s ) pn = p1 + queue_nnodes ( q ( qr ), s ( sl )) - 1 ! do i = p1 , cp - 1 if ( lv < W ( 1 , i ) . and . W ( 1 , i ) < uv ) then call set_state ( s , i - p1 ) uv = W ( 1 , i ) end if end do ! do i = cp + 1 , pn if ( lv < W ( 1 , i ) . and . W ( 1 , i ) < uv ) then call set_state ( s , i - p1 ) uv = W ( 1 , i ) end if end do ! end subroutine tree_select_top_node ! !| Returns the minimum value of the surviving nodes, excluding the current value. !  If tree is empty, Returns -infty. pure function tree_lowest_value ( q , s , ld , W ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state integer ( IK ), intent ( in ) :: ld !!  leading dimension real ( RK ), intent ( in ) :: W ( ld , * ) !!  work array real ( RK ) :: res integer ( IK ) :: i associate ( ncur => s ( sl )) if ( tree_is_unexplored ( q , s )) then res = - RHUGE return end if res = RHUGE do i = 1 , ncur if ( queue_state ( s ( sr ), i ) < 0 ) cycle call queue_second_value ( q ( qr ), s ( sr ), i , ld , W , res ) end do end associate end function tree_lowest_value ! pure subroutine queue_second_value ( r , s , ri , ld , W , res ) integer ( IK ), intent ( in ) :: r ( queue_blocksize , * ), s ( * ), ri , ld real ( RK ), intent ( in ) :: W ( ld , * ) real ( RK ), intent ( inout ) :: res integer ( IK ) :: i , c , u associate ( l => r ( qp , ri )) u = l + r ( qn , ri ) - 1 c = l + s ( ri ) do i = l , c - 1 if ( W ( 1 , i ) < W ( 1 , c )) cycle res = MIN ( W ( 1 , i ), res ) end do do i = c + 1 , u if ( W ( 1 , i ) < W ( 1 , c )) cycle res = MIN ( W ( 1 , i ), res ) end do end associate end subroutine queue_second_value ! !| Returns number of symmetry in queue. pure function tree_n_sym ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ) :: res res = q ( qs ) end function tree_n_sym ! !| Returns number of permutation in queue. pure function tree_n_perm ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state integer ( IK ) :: res res = queue_nnodes ( q ( qr ), s ( sl )) / q ( qs ) end function tree_n_perm ! !| Returns number tree depth (without root node). pure function tree_n_depth ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ) :: res res = q ( qd ) end function tree_n_depth ! !| Returns number of nodes in tree. pure function tree_log_ncomb ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header real ( RK ) :: tmp , res integer ( IK ) :: i , j ! res = ZERO tmp = ZERO j = qr + ( q ( qd ) - 1 ) * queue_blocksize + qn - 1 do i = q ( qd ), 1 , - 1 tmp = tmp - LOG ( real ( q ( j ), RK )) res = res + EXP ( tmp ) j = j - queue_blocksize end do res = ONE + res - EXP ( tmp ) ! if ( res < 1.E-24_RK ) then ; res = - RHUGE else ; res = LOG ( res ) - tmp end if ! end function tree_log_ncomb ! !| Returns number of nodes in fraction. pure function tree_ncomb_frac ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header real ( RK ) :: tmp , res tmp = LN_TO_L10 * tree_log_ncomb ( q ) res = TEN ** ( tmp - real ( INT ( tmp ), RK )) end function tree_ncomb_frac ! !| Returns number of nodes in exp. pure function tree_ncomb_exp ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ) :: res ! res = INT ( LN_TO_L10 * tree_log_ncomb ( q ), IK ) ! end function tree_ncomb_exp ! !| Returns true if current node is unexplored. pure function tree_queue_is_unexplored ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state logical :: res res = queue_state ( s ( sr ), s ( sl )) == is_unexplored end function tree_queue_is_unexplored ! !| Returns true if current node is explored. pure function tree_queue_is_explored ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state logical :: res res = queue_state ( s ( sr ), s ( sl )) < is_unexplored end function tree_queue_is_explored ! !| Returns true if p-queue is empty. pure function tree_is_empty ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state logical :: res res = tree_queue_is_empty ( q , s ) . and . tree_queue_is_bottom ( q , s ) end function tree_is_empty ! !| Returns true if tree is unexplored. pure function tree_is_unexplored ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state logical :: res res = tree_queue_is_root ( q , s ) . and . tree_queue_is_root ( q , s ) end function tree_is_unexplored ! !| Returns true if p-queue is explored. pure function tree_queue_is_empty ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state logical :: res res = queue_state ( s ( sr ), s ( sl )) < 0 end function tree_queue_is_empty ! !| Returns true if p-queue has current node. pure function tree_queue_is_selected ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state logical :: res res = queue_state ( s ( sr ), s ( sl )) >= 0 end function tree_queue_is_selected ! !| Returns true if p-queue has an unexplored node other than the selected node. pure function tree_queue_is_left ( q , s , ld , UB , W ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state integer ( IK ), intent ( in ) :: ld !!  leading dimension real ( RK ), intent ( in ) :: UB !!  upperbound real ( RK ), intent ( in ) :: W ( ld , * ) !!  work array real ( RK ) :: uv , lv integer ( IK ) :: i , p1 , pn , cp logical :: res res = . false . uv = UB ! if ( tree_queue_is_explored ( q , s )) then return elseif ( tree_queue_is_unexplored ( q , s )) then cp = tree_queue_pointer ( q , s ) - 1 lv = - RHUGE else cp = tree_current_pointer ( q , s ) lv = W ( 1 , cp ) end if ! if ( uv < lv ) return ! p1 = tree_queue_pointer ( q , s ) pn = p1 + queue_nnodes ( q ( qr ), s ( sl )) - 1 ! do i = p1 , cp - 1 if ( lv < W ( 1 , i ) . and . W ( 1 , i ) < uv ) then res = . true . return end if end do do i = cp + 1 , pn if ( lv < W ( 1 , i ) . and . W ( 1 , i ) < uv ) then res = . true . return end if end do end function tree_queue_is_left ! !| Returns true if p=1. pure function tree_queue_is_root ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state logical :: res res = s ( sl ) == 1 end function tree_queue_is_root ! !| Returns true if p=M. pure function tree_queue_is_bottom ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !!  header integer ( IK ), intent ( in ) :: s ( * ) !!  state logical :: res res = s ( sl ) == q ( qd ) end function tree_queue_is_bottom ! !| Destoructer pure elemental subroutine tree_destroy ( this ) type ( tree ), intent ( inout ) :: this if ( ALLOCATED ( this % q )) deallocate ( this % q ) if ( ALLOCATED ( this % s )) deallocate ( this % s ) end subroutine tree_destroy ! ! module functions ! pure function queue_state ( s , l ) result ( res ) integer ( IK ), intent ( in ) :: s ( state_blocksize , * ) integer ( IK ), intent ( in ) :: l integer ( IK ) :: res res = s ( ss , l ) end function queue_state ! pure subroutine set_state ( s , t ) integer ( IK ), intent ( inout ) :: s ( * ) ! state vector integer ( IK ), intent ( in ) :: t ! state integer ( IK ) :: i i = state_blocksize * ( s ( sl ) - 1 ) + sr + ss - 1 s ( i ) = t end subroutine set_state ! pure function queue_pointer ( r , s ) result ( res ) integer ( IK ), intent ( in ) :: r ( queue_blocksize , * ) integer ( IK ), intent ( in ) :: s ( * ) integer ( IK ) :: res res = r ( qp , s ( sl )) end function queue_pointer ! pure function queue_node_pointer ( r , s , n ) result ( res ) integer ( IK ), intent ( in ) :: r ( queue_blocksize , * ) integer ( IK ), intent ( in ) :: s ( * ) integer ( IK ), intent ( in ) :: n integer ( IK ) :: res res = r ( qp , s ( sl )) + n end function queue_node_pointer ! pure function queue_nnodes ( r , i ) result ( res ) integer ( IK ), intent ( in ) :: r ( queue_blocksize , * ) integer ( IK ), intent ( in ) :: i integer ( IK ) :: res res = r ( qn , i ) end function queue_nnodes ! end module mod_tree","tags":"","loc":"sourcefile/mod_tree.f90.html"},{"title":"mod_params.f90 – mobbrmsd","text":"Contents Modules mod_params Source Code mod_params.f90 Source Code !| Module with constant collection. module mod_params ! use :: mod_kinds , only : I1 , I2 , I4 , I8 , R4 , R8 , RQ , RK , IK ! implicit none private public :: I1 , I2 , I4 , I8 public :: R4 , R8 , RQ public :: RK , IK public :: RZERO , RONE , RHALF , RFOUR , RTEN public :: RPI , RNAPIER , RHUGE , LN_TO_L10 ! !&< ! real ( RK ), parameter :: RZERO = 0.0_RK !! Real zero. real ( RK ), parameter :: RONE = 1.0_RK !! Real one. real ( RK ), parameter :: RHALF = 0.5_RK !! Real 1/2. real ( RK ), parameter :: RFOUR = 4.0_RK !! Real four. real ( RK ), parameter :: RTEN = 1 0.0_RK !! Real ten. real ( RK ), parameter :: RPI = ACOS ( RZERO ) !! Real circular constant. real ( RK ), parameter :: RNAPIER = 2.71828182846_RK !! Napier constant. real ( RK ), parameter :: RHUGE = HUGE ( RZERO ) !! Real large numbe real ( RK ), parameter :: LN_TO_L10 = LOG10 ( RNAPIER ) !! Scaling factor, LOG10(x) =LN_TO_L10 * LN(x) ! !&> ! end module mod_params","tags":"","loc":"sourcefile/mod_params.f90.html"},{"title":"mod_Hungarian.f90 – mobbrmsd","text":"Contents Modules mod_Hungarian Source Code mod_Hungarian.f90 Source Code ! !| Calculate the minimum linear assignment cost using Hungarian method. module mod_Hungarian use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO , RHUGE implicit none private public :: Hungarian_worksize public :: Hungarian ! contains ! !| query work array size pure elemental function Hungarian_worksize ( m , n ) result ( res ) !| matrix dimension 1. integer ( IK ), intent ( in ) :: m !| matrix dimension 2. integer ( IK ), intent ( in ) :: n integer ( IK ) :: res if ( n > 0 . and . m > 0 ) then res = MAX ( n , m ) * 2 + 5 else res = 0 end if end function Hungarian_worksize ! !| Calculate the minimum linear assignment cost using Hungarian method. !  If m and n are different, the sum of the linear assignments of the smaller is returned. !  If m>0 and n>0, W(1) stores the minimum linear assignment cost. !  If m==0 or n==0, do nothing. !  If (m<0 or n<0) and (|m|>0 and |n|>0), W(1) stores the required memory size for C(|m|,|n|). pure subroutine Hungarian ( m , n , C , W ) !| matrix dimension 1. integer ( IK ), intent ( in ) :: m !| matrix dimension 2. integer ( IK ), intent ( in ) :: n !| score matrix C(m, n). real ( RK ), intent ( in ) :: C ( * ) !| work array. real ( RK ), intent ( inout ) :: W ( * ) ! if ( n == 0 . or . m == 0 ) then W ( 1 ) = ZERO return elseif ( n < 0 . or . m < 0 ) then ! query work array size W ( 1 ) = MAX ( ABS ( n ), ABS ( m )) * 2 + 5 elseif ( m <= n ) then block integer ( IK ) :: iw ( n + n + n + 3 ) call get_piv ( m , n , C , iw ( 1 ), iw ( n + 2 ), iw ( n + n + 3 ), & & W ( 5 ), W ( n + 5 ), W ( 2 ), W ( 3 ), W ( 4 ), W ( 1 )) end block elseif ( m > n ) then block integer ( IK ) :: iw ( m + m + m + 3 ) call get_piv_T ( m , n , C , iw ( 1 ), iw ( m + 2 ), iw ( m + m + 3 ), & & W ( 5 ), W ( m + 5 ), W ( 2 ), W ( 3 ), W ( 4 ), W ( 1 )) end block end if ! end subroutine Hungarian ! pure subroutine get_piv ( m , n , C , piv , is_visited , prv , y , cij , minc , edge , cedg , res ) integer ( IK ), intent ( in ) :: m , n real ( RK ), intent ( in ) :: C ( m , n ) integer ( IK ), intent ( inout ) :: piv ( * ), is_visited ( * ), prv ( * ) real ( RK ), intent ( inout ) :: y ( * ), cij ( * ), minc , edge , cedg , res integer ( IK ) :: l , i , j , ic , ix ! l = n + 1 do concurrent ( i = 1 : l ) piv ( i ) = - 1 end do do concurrent ( i = 1 : l ) y ( i ) = ZERO end do ! res = ZERO ! do j = 1 , m ! do concurrent ( i = 1 : l ) is_visited ( i ) = 0 end do do concurrent ( i = 1 : l ) prv ( i ) = - 1 end do do concurrent ( i = 1 : n ) cij ( i ) = RHUGE end do cij ( l ) = ZERO ! ic = l piv ( ic ) = j ! do while ( piv ( ic ) /= - 1 ) minc = RHUGE is_visited ( ic ) = 1 ix = - 1 do i = 1 , n if ( is_visited ( i ) == 0 ) then edge = C ( piv ( ic ), i ) - y ( i ) if ( ic < l ) edge = edge - C ( piv ( ic ), ic ) + y ( ic ) cedg = cij ( ic ) + edge if ( cij ( i ) > cedg ) then prv ( i ) = ic cij ( i ) = cedg end if if ( minc > cij ( i )) then ix = i minc = cij ( i ) end if end if end do ic = ix end do ! do concurrent ( i = 1 : n ) if ( i /= ic ) cij ( i ) = MIN ( cij ( i ), cij ( ic )) end do do concurrent ( i = 1 : n ) y ( i ) = y ( i ) + cij ( i ) end do ! res = res + y ( ic ) ! do while ( ic /= l ) i = prv ( ic ) piv ( ic ) = piv ( i ) ic = i end do ! end do ! end subroutine get_piv ! pure subroutine get_piv_T ( m , n , C , piv , is_visited , prv , y , cij , minc , edge , cedg , res ) integer ( IK ), intent ( in ) :: m , n real ( RK ), intent ( in ) :: C ( m , n ) integer ( IK ), intent ( inout ) :: piv ( * ), is_visited ( * ), prv ( * ) real ( RK ), intent ( inout ) :: y ( * ), cij ( * ), minc , edge , cedg , res integer ( IK ) :: l , i , j , ic , ix ! l = m + 1 do concurrent ( i = 1 : l ) piv ( i ) = - 1 end do ! do concurrent ( i = 1 : l ) y ( i ) = ZERO end do ! res = ZERO ! do j = 1 , n ! do concurrent ( i = 1 : l ) is_visited ( i ) = 0 end do ! do concurrent ( i = 1 : l ) prv ( i ) = - 1 end do ! do concurrent ( i = 1 : m ) cij ( i ) = RHUGE end do cij ( l ) = ZERO ! ic = l piv ( ic ) = j ! do while ( piv ( ic ) /= - 1 ) minc = RHUGE is_visited ( ic ) = 1 ix = - 1 do i = 1 , m if ( is_visited ( i ) == 0 ) then edge = C ( i , piv ( ic )) - y ( i ) if ( ic < l ) edge = edge - C ( ic , piv ( ic )) + y ( ic ) cedg = cij ( ic ) + edge if ( cij ( i ) > cedg ) then prv ( i ) = ic cij ( i ) = cedg end if if ( minc > cij ( i )) then ix = i minc = cij ( i ) end if end if end do ic = ix end do ! do concurrent ( i = 1 : m ) if ( i /= ic ) cij ( i ) = MIN ( cij ( i ), cij ( ic )) end do do concurrent ( i = 1 : m ) y ( i ) = y ( i ) + cij ( i ) end do ! res = res + y ( ic ) ! do while ( ic /= l ) i = prv ( ic ) piv ( ic ) = piv ( i ) ic = i end do ! end do ! end subroutine get_piv_T ! end module mod_Hungarian","tags":"","loc":"sourcefile/mod_hungarian.f90.html"},{"title":"mod_mobbrmsd.f90 – mobbrmsd","text":"Contents Modules mod_mobbrmsd Source Code mod_mobbrmsd.f90 Source Code !| molecular orientation corrected RMSD with branch-and-bound. module mod_mobbrmsd use mod_dimspec_functions , only : D , setup_dimension use mod_params , only : & & IK , & & RK , & & ONE => RONE , & & ZERO => RZERO , & & RHUGE use mod_bb_list use mod_bb_block use mod_mobbrmsd_header use mod_mobbrmsd_state implicit none public :: setup_dimension public :: mobbrmsd_input public :: mol_block_input public :: mol_block_input_add public :: mobbrmsd public :: mobbrmsd_header public :: mobbrmsd_state public :: mobbrmsd_run public :: mobbrmsd_restart public :: mobbrmsd_is_finished ! !| mobbrmsd_input type mobbrmsd_input private type ( mol_block_input ), allocatable :: blk (:) contains procedure :: add => mobbrmsd_input_add final :: mobbrmsd_input_destroy end type mobbrmsd_input ! !| mol_block_input (for python interface) type mol_block_input private integer ( IK ) :: m !! number of atoms per molecule integer ( IK ) :: n !! number of molecule integer ( IK ), allocatable :: sym (:, :) !! molecular symmetry contains final :: mol_block_input_destroy end type mol_block_input ! !| mobbrmsd type mobbrmsd type ( mobbrmsd_header ) :: h !! mobbrmsd_header type ( mobbrmsd_state ) :: s !! mobbrmsd_state contains final :: mobbrmsd_destroy end type mobbrmsd ! interface mobbrmsd module procedure mobbrmsd_new , mobbrmsd_new_from_block end interface mobbrmsd ! contains ! !| add molecule pure subroutine mobbrmsd_input_add ( this , m , n , sym ) class ( mobbrmsd_input ), intent ( inout ) :: this !! mol_block_input array integer ( IK ), intent ( in ) :: m !! number of atoms per molecule integer ( IK ), intent ( in ) :: n !! number of molecule integer ( IK ), intent ( in ), optional :: sym (:, :) !! molecular symmetry, sym(m, s-1) call mol_block_input_add ( this % blk , m , n , sym ) end subroutine mobbrmsd_input_add ! !| destractor pure elemental subroutine mobbrmsd_input_destroy ( this ) type ( mobbrmsd_input ), intent ( inout ) :: this if ( ALLOCATED ( this % blk )) deallocate ( this % blk ) end subroutine mobbrmsd_input_destroy ! ! ------ ! !| add molecule pure subroutine mol_block_input_add ( this , m , n , sym ) type ( mol_block_input ), allocatable , intent ( inout ) :: this (:) !! mol_block_input array integer ( IK ), intent ( in ) :: m !! number of atoms per molecule integer ( IK ), intent ( in ) :: n !! number of molecule integer ( IK ), intent ( in ), optional :: sym (:, :) !! molecular symmetry type ( mol_block_input ), allocatable :: blocks (:) integer ( IK ) :: nblock , i ! nblock = 1 if ( ALLOCATED ( this )) nblock = nblock + SIZE ( this ) ! allocate ( blocks ( nblock )) do concurrent ( i = 1 : nblock - 1 ) blocks ( i )% m = this ( i )% m blocks ( i )% n = this ( i )% n call MOVE_ALLOC ( from = this ( i )% sym , to = blocks ( i )% sym ) end do ! blocks ( nblock )% m = m blocks ( nblock )% n = n if ( PRESENT ( sym )) then if ( SIZE ( sym ) > 0 ) blocks ( nblock )% sym = sym end if ! call MOVE_ALLOC ( from = blocks , to = this ) ! end subroutine mol_block_input_add ! !| destractor pure elemental subroutine mol_block_input_destroy ( this ) type ( mol_block_input ), intent ( inout ) :: this if ( ALLOCATED ( this % sym )) deallocate ( this % sym ) end subroutine mol_block_input_destroy ! ! ------ ! !| constructor pure elemental function mobbrmsd_new ( inp ) result ( res ) type ( mobbrmsd_input ), intent ( in ) :: inp !! mobbrmsd_input type ( mobbrmsd ) :: res ! res = mobbrmsd_new_from_block ( inp % blk ) ! end function mobbrmsd_new ! !| constructor, from mol_block_input. (for python interface) pure function mobbrmsd_new_from_block ( blocks ) result ( res ) type ( mol_block_input ), intent ( in ) :: blocks (:) !! mol_block_input array type ( mobbrmsd ) :: res integer ( IK ) :: nblock ! nblock = SIZE ( blocks ) ! block type ( bb_block ) :: bbblk ( nblock ) type ( bb_list ) :: bblst integer ( IK ) :: i ! do concurrent ( i = 1 : nblock ) if ( ALLOCATED ( blocks ( i )% sym )) then bbblk ( i ) = bb_block ( blocks ( i )% m , blocks ( i )% n , sym = blocks ( i )% sym ) else bbblk ( i ) = bb_block ( blocks ( i )% m , blocks ( i )% n ) end if end do ! bblst = bb_list ( bbblk ) res % h = mobbrmsd_header ( bblst % q , bblst % s ) res % s = mobbrmsd_state ( res % h ) end block ! end function mobbrmsd_new_from_block ! !| run mobbrmsd pure subroutine mobbrmsd_run ( & & header , & & state , & & X , Y , W , & & cutoff , & & difflim , & & maxeval , & & remove_com , & & sort_by_g & & ) type ( mobbrmsd_header ), intent ( in ) :: header !! mobbrmsd_header type ( mobbrmsd_state ), intent ( inout ) :: state !! mobbrmsd_state, the result is contained in this structure. real ( RK ), intent ( in ) :: X ( * ) !! reference coordinate real ( RK ), intent ( in ) :: Y ( * ) !! target coordinate real ( RK ), intent ( inout ), optional :: W ( * ) !! work array, must be > header%memsize() real ( RK ), intent ( in ), optional :: cutoff !! The search ends when lowerbound is determined to be greater than to cutoff. real ( RK ), intent ( in ), optional :: difflim !! The search ends when the difference between the lower and upper bounds is less than difflim. integer ( IK ), intent ( in ), optional :: maxeval !! The search ends when ncount exceeds maxiter. logical , intent ( in ), optional :: remove_com !! if true, remove centroids. default [.true.] logical , intent ( in ), optional :: sort_by_g !! if true, row is sorted respect to G of reference coordinate. default [.true.] ! if ( PRESENT ( W )) then call bb_list_setup (& & header % q , & & state % s , & & X , & & Y , & & W , & & remove_com = remove_com , & & sort_by_g = sort_by_g & & ) call mobbrmsd_restart ( & & header , & & state , & & W , & & cutoff = cutoff , & & difflim = difflim , & & maxeval = maxeval ) else block real ( RK ), allocatable :: T (:) allocate ( T ( header % memsize ())) call bb_list_setup (& & header % q , & & state % s , & & X , & & Y , & & T , & & remove_com = remove_com & & ) call mobbrmsd_restart ( header , & & state , & & T , & & cutoff = cutoff , & & difflim = difflim , & & maxeval = maxeval ) end block end if end subroutine mobbrmsd_run ! !| run mobbrmsd pure subroutine mobbrmsd_restart ( header , state , W , & & cutoff , difflim , maxeval ) type ( mobbrmsd_header ), intent ( in ) :: header !! mobbrmsd_header type ( mobbrmsd_state ), intent ( inout ) :: state !! mobbrmsd_state, the result is contained in this structure. real ( RK ), intent ( inout ) :: W ( * ) !! work array, must be > header%memsize() real ( RK ), intent ( in ), optional :: cutoff !! The search ends when lowerbound is determined to be greater than to cutoff. real ( RK ), intent ( in ), optional :: difflim !! The search ends when the difference between the lower and upper bounds is less than difflim. integer ( IK ), intent ( in ), optional :: maxeval !! The search ends when ncount exceeds maxiter. call bb_list_run ( header % q , state % s , W , cutoff = cutoff , difflim = difflim , maxeval = maxeval ) call mobbrmsd_state_update ( state , header , W ) end subroutine mobbrmsd_restart ! !| update mobbrmsd_state pure subroutine mobbrmsd_state_update ( this , header , W ) type ( mobbrmsd_state ), intent ( inout ) :: this !! mobbrmsd header type ( mobbrmsd_header ), intent ( in ) :: header !! mobbrmsd header real ( RK ), intent ( in ) :: W ( * ) !! mobbrmsd workarray associate ( & & ac => this % z ( mobbrmsd_state_INDEX_TO_AUTOCORR ), & & ub => this % z ( mobbrmsd_state_INDEX_TO_UPPERBOUND ), & & lb => this % z ( mobbrmsd_state_INDEX_TO_LOWERBOUND ), & & ne => this % z ( mobbrmsd_state_INDEX_TO_N_EVAL ), & & lr => this % z ( mobbrmsd_state_INDEX_TO_LOG_RATIO ), & & rt => mobbrmsd_state_INDEX_TO_ROTMAT , & & bbac => W ( bb_list_INDEX_TO_AUTOCORR ), & & bbub => W ( bb_list_INDEX_TO_UPPERBOUND ), & & bblb => W ( bb_list_INDEX_TO_LOWERBOUND ), & & bbne => W ( bb_list_INDEX_TO_N_EVAL ), & & bbln => W ( bb_list_INDEX_TO_LOG_N_COMB ) & ) ac = bbac ub = bbub lb = bblb ne = bbne lr = LOG ( bbne ) - bbln call bb_list_rotation_matrix ( header % q , this % s , W , this % z ( rt )) end associate end subroutine mobbrmsd_state_update ! !| Returns bb process is finished. pure function mobbrmsd_is_finished ( header , state ) result ( res ) class ( mobbrmsd_header ), intent ( in ) :: header !! mobbrmsd_header class ( mobbrmsd_state ), intent ( in ) :: state !! mobbrmsd_state logical :: res res = bb_list_is_finished ( header % q , state % s ) end function mobbrmsd_is_finished ! pure elemental subroutine mobbrmsd_destroy ( this ) type ( mobbrmsd ), intent ( inout ) :: this end subroutine mobbrmsd_destroy end module mod_mobbrmsd","tags":"","loc":"sourcefile/mod_mobbrmsd.f90.html"},{"title":"mod_mobbrmsd_header.f90 – mobbrmsd","text":"Contents Modules mod_mobbrmsd_header Source Code mod_mobbrmsd_header.f90 Source Code !| molecular orientation corrected RMSD with branch-and-bound. module mod_mobbrmsd_header use mod_dimspec_functions , only : D use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO , TEN => RTEN , LN_TO_L10 , RHUGE use mod_bb_list use mod_bb_block implicit none public :: mobbrmsd_header ! !| mobbrmsd_header type mobbrmsd_header private integer ( IK ) :: d !! spatial dimension integer ( IK ), allocatable , public :: q (:) !! header array integer ( IK ), allocatable :: s (:) !! state template contains procedure :: n_dims => mobbrmsd_header_n_dims procedure :: n_block => mobbrmsd_header_n_block procedure :: n_atoms => mobbrmsd_header_n_atoms procedure :: log_n_nodes => mobbrmsd_header_log_n_nodes procedure :: frac_n_nodes => mobbrmsd_header_frac_n_nodes procedure :: exp_n_nodes => mobbrmsd_header_exp_n_nodes procedure :: memsize => mobbrmsd_header_memsize procedure :: state_template => mobbrmsd_header_state_template procedure :: dump => mobbrmsd_header_dump procedure :: load => mobbrmsd_header_load final :: mobbrmsd_header_destroy end type mobbrmsd_header ! interface mobbrmsd_header module procedure :: mobbrmsd_header_new end interface mobbrmsd_header ! contains ! !| Returns spatial dimension pure function mobbrmsd_header_new ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q (:) !! mobbrmsd_header sequence integer ( IK ), intent ( in ) :: s (:) !! mobbrmsd_state template sequence type ( mobbrmsd_header ) :: res res % d = D allocate ( res % q , source = q ) allocate ( res % s , source = s ) end function mobbrmsd_header_new ! !| Returns spatial dimension pure elemental function mobbrmsd_header_n_dims ( this ) result ( res ) class ( mobbrmsd_header ), intent ( in ) :: this !! this integer ( IK ) :: res res = this % d end function mobbrmsd_header_n_dims ! !| Returns number of molecular blocks pure elemental function mobbrmsd_header_n_block ( this ) result ( res ) class ( mobbrmsd_header ), intent ( in ) :: this !! this integer ( IK ) :: res res = bb_list_n_block ( this % q ) end function mobbrmsd_header_n_block ! !| Returns header_memsize pure elemental function mobbrmsd_header_memsize ( this ) result ( res ) class ( mobbrmsd_header ), intent ( in ) :: this !! this integer ( IK ) :: res res = bb_list_memsize ( this % q ) end function mobbrmsd_header_memsize ! !| Returns n_atoms pure elemental function mobbrmsd_header_n_atoms ( this ) result ( res ) class ( mobbrmsd_header ), intent ( in ) :: this !! this integer ( IK ) :: res res = bb_list_n_atoms ( this % q ) end function mobbrmsd_header_n_atoms ! !| Returns log_n_nodes pure elemental function mobbrmsd_header_log_n_nodes ( this ) result ( res ) class ( mobbrmsd_header ), intent ( in ) :: this !! this real ( RK ) :: res res = bb_list_log_n_nodes ( this % q ) end function mobbrmsd_header_log_n_nodes ! !| returns number of nodes in fraction. pure function mobbrmsd_header_frac_n_nodes ( this ) result ( res ) class ( mobbrmsd_header ), intent ( in ) :: this !! this real ( RK ) :: tmp , res tmp = LN_TO_L10 * bb_list_log_n_nodes ( this % q ) res = TEN ** ( tmp - real ( INT ( tmp ), RK )) end function mobbrmsd_header_frac_n_nodes ! !| returns number of nodes in exp. pure function mobbrmsd_header_exp_n_nodes ( this ) result ( res ) class ( mobbrmsd_header ), intent ( in ) :: this !! this integer ( IK ) :: res res = INT ( LN_TO_L10 * bb_list_log_n_nodes ( this % q ), IK ) end function mobbrmsd_header_exp_n_nodes ! !| dump state template as integer array pure function mobbrmsd_header_state_template ( this ) result ( res ) class ( mobbrmsd_header ), intent ( in ) :: this !! this integer ( IK ), allocatable :: res (:) ! allocate ( res , source = this % s ) ! end function mobbrmsd_header_state_template ! !| dump header as integer array pure function mobbrmsd_header_dump ( this ) result ( res ) class ( mobbrmsd_header ), intent ( in ) :: this !! this integer ( IK ), allocatable :: res (:) ! allocate ( res , source = [ this % d , SIZE ( this % q ), this % q , this % s ]) ! end function mobbrmsd_header_dump ! !| load integer array as header pure subroutine mobbrmsd_header_load ( this , q ) class ( mobbrmsd_header ), intent ( inout ) :: this !! this integer ( IK ), intent ( in ) :: q (:) !! header array integer ( IK ) :: sq , i this % d = q ( 1 ) sq = q ( 2 ) if ( sq < 1 ) then this % q = [( 0 , i = 1 , 0 )] this % s = [( 0 , i = 1 , 0 )] return else this % q = q ( 3 : 2 + sq ) this % s = q ( 3 + sq :) end if end subroutine mobbrmsd_header_load ! !| destructer pure elemental subroutine mobbrmsd_header_destroy ( this ) type ( mobbrmsd_header ), intent ( inout ) :: this if ( ALLOCATED ( this % q )) deallocate ( this % q ) if ( ALLOCATED ( this % s )) deallocate ( this % s ) end subroutine mobbrmsd_header_destroy ! end module mod_mobbrmsd_header","tags":"","loc":"sourcefile/mod_mobbrmsd_header.f90.html"},{"title":"mod_mobbrmsd_batch_run.f90 – mobbrmsd","text":"Contents Modules mod_mobbrmsd_batch_run Source Code mod_mobbrmsd_batch_run.f90 Source Code !| molecular orientation corrected RMSD with branch-and-bound. module mod_mobbrmsd_batch_run !$ use omp_lib use mod_params , only : & & IK , & & RK , & & ONE => RONE , & & ZERO => RZERO , & & RHUGE use mod_mobbrmsd_header use mod_mobbrmsd_state use mod_mobbrmsd use mod_forbar use mod_forbar_collections implicit none public :: mobbrmsd_batch_run ! contains ! !| batch parallel run subroutine mobbrmsd_batch_run ( n_target , header , state , & & X , Y , W , & & cutoff , difflim , maxeval , & & remove_com , sort_by_g , & & rotate_y ) integer ( IK ), intent ( in ) :: n_target !! number of target coordinates type ( mobbrmsd_header ), intent ( in ) :: header !! mobbrmsd_header type ( mobbrmsd_state ), intent ( inout ) :: state ( n_target ) !! mobbrmsd_state, the result is contained in this structure. real ( RK ), intent ( in ) :: X ( * ) !! reference coordinate real ( RK ), intent ( inout ) :: Y ( * ) !! target coordinate real ( RK ), intent ( inout ) :: W ( * ) !! work memory, must be larger than header%memsize() * mobbrmsd_num_threads() real ( RK ), intent ( in ), optional :: cutoff !! The search ends when lowerbound is determined to be greater than to cutoff. real ( RK ), intent ( in ), optional :: difflim !! The search ends when the difference between the lower and upper bounds is less than difflim. integer ( IK ), intent ( in ), optional :: maxeval !! The search ends when ncount exceeds maxiter. logical , intent ( in ), optional :: remove_com !! if true, remove centroids. default [.true.] logical , intent ( in ), optional :: sort_by_g !! if true, row is sorted respect to G of reference coordinate. default [.true.] logical , intent ( in ), optional :: rotate_y !! The search ends when ncount exceeds maxiter. integer ( kind = IK ) :: i , itgt , ijob , ypnt , wpnt , ldy , ldw ! i = 0 ldy = header % n_dims () * header % n_atoms () ldw = header % memsize () ! !$omp parallel private(itgt, ijob, ypnt, wpnt) do !$omp critical i = i + 1 itgt = i !$omp end critical if ( itgt > n_target ) exit wpnt = ldw * omp_get_thread_num () + 1 ypnt = ( itgt - 1 ) * ldy + 1 call mobbrmsd_run ( header , state ( itgt ), X , Y ( ypnt ), W ( wpnt ), & & cutoff = cutoff , difflim = difflim , maxeval = maxeval , & & remove_com = remove_com , sort_by_g = sort_by_g & & ) if ( rotate_y ) call state ( itgt )% rotation ( header , Y ( ypnt )) end do !$omp end parallel ! end subroutine mobbrmsd_batch_run ! end module mod_mobbrmsd_batch_run","tags":"","loc":"sourcefile/mod_mobbrmsd_batch_run.f90.html"},{"title":"mod_mobbrmsd_state.f90 – mobbrmsd","text":"Contents Modules mod_mobbrmsd_state Source Code mod_mobbrmsd_state.f90 Source Code !| molecular orientation corrected RMSD with branch-and-bound. module mod_mobbrmsd_state use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO , TEN => RTEN , LN_TO_L10 , RHUGE use mod_mobbrmsd_header use mod_bb_list implicit none public :: mobbrmsd_state public :: mobbrmsd_state_INDEX_TO_RCP_N_ATOMS public :: mobbrmsd_state_INDEX_TO_AUTOCORR public :: mobbrmsd_state_INDEX_TO_UPPERBOUND public :: mobbrmsd_state_INDEX_TO_LOWERBOUND public :: mobbrmsd_state_INDEX_TO_N_EVAL public :: mobbrmsd_state_INDEX_TO_LOG_RATIO public :: mobbrmsd_state_INDEX_TO_ROTMAT !&< integer ( IK ), parameter :: mobbrmsd_state_INDEX_TO_RCP_N_ATOMS = 1 !! Index of reciprocal natom of dumped state integer ( IK ), parameter :: mobbrmsd_state_INDEX_TO_AUTOCORR = 2 !! Index to auto correlation integer ( IK ), parameter :: mobbrmsd_state_INDEX_TO_UPPERBOUND = 3 !! Index of upperbound of dumped state integer ( IK ), parameter :: mobbrmsd_state_INDEX_TO_LOWERBOUND = 4 !! Index of lowerbound of dumped state integer ( IK ), parameter :: mobbrmsd_state_INDEX_TO_N_EVAL = 5 !! Index of n_eval of dumped state integer ( IK ), parameter :: mobbrmsd_state_INDEX_TO_LOG_RATIO = 6 !! Index of log_ratio of dumped state integer ( IK ), parameter :: mobbrmsd_state_INDEX_TO_ROTMAT = 7 !! Index to rotmatrix of dumped state !&> !| mobbrmsd_state type mobbrmsd_state integer ( IK ), allocatable :: s (:) real ( RK ), allocatable :: z (:) contains procedure :: upperbound => mobbrmsd_state_upperbound !! upperbound procedure :: lowerbound => mobbrmsd_state_lowerbound !! lowerbound procedure :: autovariance => mobbrmsd_state_autovariance !! lowerbound procedure :: squared_deviation => mobbrmsd_state_squared_deviation !! sqrared_deviation procedure :: mean_squared_deviation => mobbrmsd_state_mean_squared_deviation !! sqrared_deviation procedure :: rmsd => mobbrmsd_state_rmsd !! rmsd procedure :: lowerbound_as_rmsd => mobbrmsd_state_lowerbound_as_rmsd !! lowerbound_as_rmsd procedure :: n_eval => mobbrmsd_state_n_eval !! number of lowerbound evaluation procedure :: eval_ratio => mobbrmsd_state_eval_ratio !! ratio of evaluated node procedure :: log_eval_ratio => mobbrmsd_state_log_eval_ratio !! log ratio of evaluated node procedure :: rotation => mobbrmsd_state_rotation !! rotate given coordinate procedure :: dump => mobbrmsd_state_dump !! dump current state procedure :: dump_real => mobbrmsd_state_dump_real !! dump real part of current state procedure :: load => mobbrmsd_state_load !! load state final :: mobbrmsd_state_destroy !! destracter end type mobbrmsd_state ! interface mobbrmsd_state module procedure mobbrmsd_state_new end interface mobbrmsd_state ! contains ! ------ ! !| returns upperbound pure elemental function mobbrmsd_state_new ( header ) result ( res ) type ( mobbrmsd_header ), intent ( in ) :: header !! mobbrmsd header type ( mobbrmsd_state ) :: res real ( RK ) :: z ( 6 + header % n_dims () ** 2 ) associate ( & & RN => mobbrmsd_state_INDEX_TO_RCP_N_ATOMS , & & AC => mobbrmsd_state_INDEX_TO_AUTOCORR , & & UB => mobbrmsd_state_INDEX_TO_UPPERBOUND , & & LB => mobbrmsd_state_INDEX_TO_LOWERBOUND , & & NE => mobbrmsd_state_INDEX_TO_N_EVAL , & & LR => mobbrmsd_state_INDEX_TO_LOG_RATIO , & & RT => mobbrmsd_state_INDEX_TO_ROTMAT & ) z ( RN ) = ONE / real ( header % n_atoms (), RK ) z ( AC ) = ZERO z ( UB ) = RHUGE z ( LB ) = - RHUGE z ( NE ) = - RHUGE z ( LR ) = ZERO call eye ( header % n_dims (), z ( RT )) ! allocate ( res % s , source = header % state_template ()) allocate ( res % z , source = z ) end associate contains pure subroutine eye ( n_dims , e ) integer ( IK ), intent ( in ) :: n_dims real ( RK ), intent ( inout ) :: e ( n_dims , n_dims ) integer ( IK ) :: i , j do concurrent ( i = 1 : n_dims , j = 1 : n_dims ) e ( i , j ) = MERGE ( ONE , ZERO , i == j ) end do end subroutine eye end function mobbrmsd_state_new ! !| returns upperbound pure elemental function mobbrmsd_state_upperbound ( this ) result ( res ) class ( mobbrmsd_state ), intent ( in ) :: this !! this real ( RK ) :: res res = this % z ( mobbrmsd_state_INDEX_TO_UPPERBOUND ) end function mobbrmsd_state_upperbound ! !| returns lowerbound pure elemental function mobbrmsd_state_lowerbound ( this ) result ( res ) class ( mobbrmsd_state ), intent ( in ) :: this !! this real ( RK ) :: res res = this % z ( mobbrmsd_state_INDEX_TO_LOWERBOUND ) end function mobbrmsd_state_lowerbound ! !| returns autovariance pure elemental function mobbrmsd_state_autovariance ( this ) result ( res ) class ( mobbrmsd_state ), intent ( in ) :: this !! this real ( RK ) :: res res = this % z ( mobbrmsd_state_INDEX_TO_AUTOCORR ) end function mobbrmsd_state_autovariance ! !| returns squared deviation pure elemental function mobbrmsd_state_squared_deviation ( this ) result ( res ) class ( mobbrmsd_state ), intent ( in ) :: this !! this real ( RK ) :: res associate (& & ac => this % z ( mobbrmsd_state_INDEX_TO_AUTOCORR ), & & ub => this % z ( mobbrmsd_state_INDEX_TO_UPPERBOUND ) & & ) res = MAX ( ZERO , ac + ub + ub ) end associate end function mobbrmsd_state_squared_deviation ! !| returns squared deviation pure elemental function mobbrmsd_state_mean_squared_deviation ( this ) result ( res ) class ( mobbrmsd_state ), intent ( in ) :: this !! this real ( RK ) :: res associate (& & rn => this % z ( mobbrmsd_state_INDEX_TO_RCP_N_ATOMS ), & & ac => this % z ( mobbrmsd_state_INDEX_TO_AUTOCORR ), & & ub => this % z ( mobbrmsd_state_INDEX_TO_UPPERBOUND ) & & ) res = MAX ( ZERO , ( ac + ub + ub ) * rn ) end associate end function mobbrmsd_state_mean_squared_deviation ! !| returns rmsd pure elemental function mobbrmsd_state_rmsd ( this ) result ( res ) class ( mobbrmsd_state ), intent ( in ) :: this !! this real ( RK ) :: res associate (& & rn => this % z ( mobbrmsd_state_INDEX_TO_RCP_N_ATOMS ), & & ac => this % z ( mobbrmsd_state_INDEX_TO_AUTOCORR ), & & ub => this % z ( mobbrmsd_state_INDEX_TO_UPPERBOUND ) & & ) res = SQRT ( MAX ( ZERO , ( ac + ub + ub ) * rn )) end associate end function mobbrmsd_state_rmsd ! !| returns lowerbound as rmsd pure elemental function mobbrmsd_state_lowerbound_as_rmsd ( this ) result ( res ) class ( mobbrmsd_state ), intent ( in ) :: this !! this real ( RK ) :: res associate (& & rn => this % z ( mobbrmsd_state_INDEX_TO_RCP_N_ATOMS ), & & ac => this % z ( mobbrmsd_state_INDEX_TO_AUTOCORR ), & & lb => this % z ( mobbrmsd_state_INDEX_TO_LOWERBOUND ) & & ) res = SQRT ( MAX ( ZERO , ( ac + lb + lb ) * rn )) end associate end function mobbrmsd_state_lowerbound_as_rmsd ! !| returns n_eval pure elemental function mobbrmsd_state_n_eval ( this ) result ( res ) class ( mobbrmsd_state ), intent ( in ) :: this !! this integer ( IK ) :: res associate ( ne => this % z ( mobbrmsd_state_INDEX_TO_N_EVAL )) res = NINT ( ne , IK ) end associate end function mobbrmsd_state_n_eval ! !| returns eval_ratio pure elemental function mobbrmsd_state_eval_ratio ( this ) result ( res ) class ( mobbrmsd_state ), intent ( in ) :: this !! this real ( RK ) :: res associate ( LR => mobbrmsd_state_INDEX_TO_LOG_RATIO ) res = EXP ( this % z ( LR )) end associate end function mobbrmsd_state_eval_ratio ! !| returns eval_ratio pure subroutine mobbrmsd_state_rotation ( this , header , X ) class ( mobbrmsd_state ), intent ( in ) :: this !! this type ( mobbrmsd_header ), intent ( in ) :: header !! mobbrmsd header real ( RK ), intent ( inout ) :: X ( * ) !! coordinate associate ( rt => mobbrmsd_state_INDEX_TO_ROTMAT ) call bb_list_swap_y ( header % q , this % s , X ) call rotate ( header % n_dims (), header % n_atoms (), this % z ( rt ), X ) end associate contains pure subroutine rotate ( n_dims , n_atoms , R , X ) integer ( IK ), intent ( in ) :: n_dims , n_atoms real ( RK ), intent ( in ) :: R ( n_dims , n_dims ) real ( RK ), intent ( inout ) :: X ( n_dims , n_atoms ) real ( RK ) :: T ( n_dims , n_atoms ) T = MATMUL ( TRANSPOSE ( R ), X ) X = T end subroutine rotate end subroutine mobbrmsd_state_rotation ! !| returns log_eval_ratio pure elemental function mobbrmsd_state_log_eval_ratio ( this ) result ( res ) class ( mobbrmsd_state ), intent ( in ) :: this real ( RK ) :: res res = this % z ( mobbrmsd_state_INDEX_TO_LOG_RATIO ) end function mobbrmsd_state_log_eval_ratio ! !| dump header as integer array (for python interface api) pure function mobbrmsd_state_dump ( this ) result ( res ) class ( mobbrmsd_state ), intent ( in ) :: this !! mobbrmsd_header integer ( IK ), allocatable :: res (:) allocate ( res , source = this % s ) end function mobbrmsd_state_dump ! !| dump header as integer array (for python interface api) pure function mobbrmsd_state_dump_real ( this ) result ( res ) class ( mobbrmsd_state ), intent ( in ) :: this !! mobbrmsd_header real ( RK ), allocatable :: res (:) allocate ( res , source = this % z ) end function mobbrmsd_state_dump_real ! !| load integer array as header (for python interface api) pure subroutine mobbrmsd_state_load ( this , s , z ) class ( mobbrmsd_state ), intent ( inout ) :: this !! mobbrmsd_header integer ( IK ), intent ( in ) :: s (:) !! state integer array real ( RK ), intent ( in ) :: z (:) !! state real array integer ( IK ), allocatable :: s_ (:) real ( RK ), allocatable :: z_ (:) allocate ( s_ , source = s ) allocate ( z_ , source = z ) call MOVE_ALLOC ( from = s_ , to = this % s ) call MOVE_ALLOC ( from = z_ , to = this % z ) end subroutine mobbrmsd_state_load ! pure elemental subroutine mobbrmsd_state_destroy ( this ) type ( mobbrmsd_state ), intent ( inout ) :: this if ( ALLOCATED ( this % s )) deallocate ( this % s ) if ( ALLOCATED ( this % z )) deallocate ( this % z ) end subroutine mobbrmsd_state_destroy end module mod_mobbrmsd_state","tags":"","loc":"sourcefile/mod_mobbrmsd_state.f90.html"},{"title":"mod_mobbrmsd_mst.f90 – mobbrmsd","text":"Contents Modules mod_mobbrmsd_mst Source Code mod_mobbrmsd_mst.f90 Source Code !| Configure a minimum global tree with mobbrmsd. <br> !  MST construction is based on the Prim's algorithm, !  but the useless calculations are reduced using the cutoff possibilities of mobbrmsd. module mod_mobbrmsd_mst !$ use omp_lib use mod_params , only : & & IK , & & RK , & & ONE => RONE , & & ZERO => RZERO , & & RHUGE use mod_mobbrmsd_header use mod_mobbrmsd_state use mod_mobbrmsd use mod_forbar use mod_forbar_collections implicit none private public :: mobbrmsd_min_span_tree ! type priority_list sequence integer ( IK ) :: i real ( RK ) :: u end type priority_list ! contains ! !| nearest_neighbor calculation subroutine mobbrmsd_nearest_neighbor ( n_target , header , state , X , Y , W , & & cutoff , difflim , maxeval , & & remove_com , sort_by_g , & & mask , nnval , nnidx ) integer ( IK ), intent ( in ) :: n_target !! number of target coordinates type ( mobbrmsd_header ), intent ( in ) :: header !! mobbrmsd_header type ( mobbrmsd_state ), intent ( inout ) :: state ( n_target ) !! mobbrmsd_state, the result is contained in this structure. real ( kind = RK ), intent ( in ) :: X ( * ) !! reference coordinate real ( kind = RK ), intent ( in ) :: y ( * ) !! target coordinate real ( kind = RK ), intent ( inout ) :: W ( * ) !! work memory, must be larger than header%memsize() * mobbrmsd_num_threads() real ( RK ), intent ( in ), optional :: cutoff !! The search ends when lowerbound is determined to be greater than to cutoff. real ( RK ), intent ( in ), optional :: difflim !! The search ends when the difference between the lower and upper bounds is less than difflim. integer ( IK ), intent ( in ), optional :: maxeval !! The search ends when ncount exceeds maxiter. logical , intent ( in ), optional :: remove_com !! if true, remove centroids. default [.true.] logical , intent ( in ), optional :: sort_by_g !! if true, row is sorted respect to G of reference coordinate. default [.true.] logical , intent ( in ), optional :: mask ( n_target ) !! If .false., skip the calculation. real ( RK ), intent ( out ), optional :: nnval !! nearest neighbor index integer ( IK ), intent ( out ), optional :: nnidx !! nearest neighbor index type ( priority_list ), allocatable :: pl (:) real ( kind = RK ) :: cutoff_global , ub integer ( kind = IK ) :: i , j , itgt , ntgt , ypnt , wpnt , ldy , ldw ! ldy = header % n_dims () * header % n_atoms () ldw = header % memsize () ! if ( PRESENT ( cutoff )) then cutoff_global = MERGE ( RHUGE , cutoff , cutoff < ZERO ) else cutoff_global = RHUGE end if ! if ( PRESENT ( mask )) then cutoff_global = MIN ( MINVAL ( state % rmsd (), mask ), cutoff_global ) ntgt = COUNT ( mask ) else cutoff_global = MIN ( MINVAL ( state % rmsd ()), cutoff_global ) ntgt = n_target end if ! allocate ( pl ( ntgt )) ! if ( PRESENT ( mask )) then j = 0 do i = 1 , n_target if (. not . mask ( i )) cycle j = j + 1 pl ( j ) = priority_list ( i , state ( i )% upperbound ()) end do else do concurrent ( i = 1 : ntgt ) pl ( i ) = priority_list ( i , state ( i )% upperbound ()) end do end if ! if ( ntgt > 1 ) call qs ( ntgt , pl ) ! i = 0 ! !$omp parallel private(itgt, ub) do !$omp critical i = i + 1 itgt = i ub = cutoff_global !$omp end critical ! if ( itgt > ntgt ) exit ! itgt = pl ( itgt )% i ! if ( bb_list_is_finished ( header % q , state ( itgt )% s )) cycle if ( ub < state ( itgt )% lowerbound_as_rmsd ()) cycle ! wpnt = ldw * omp_get_thread_num () + 1 ypnt = ( itgt - 1 ) * ldy + 1 ! call mobbrmsd_run ( & & header , state ( itgt ), & & X , Y ( ypnt ), W ( wpnt ), & & cutoff = ub , & & difflim = difflim , & & maxeval = maxeval , & & remove_com = remove_com , & & sort_by_g = sort_by_g & & ) ub = state ( itgt )% rmsd () ! !$omp critical cutoff_global = MIN ( ub , cutoff_global ) !$omp end critical end do !$omp end parallel ! if ( PRESENT ( mask )) then if ( PRESENT ( nnval )) nnval = MINVAL ( state % rmsd (), mask ) if ( PRESENT ( nnidx )) nnidx = MINLOC ( state % rmsd (), 1 , mask ) else if ( PRESENT ( nnval )) nnval = MINVAL ( state % rmsd ()) if ( PRESENT ( nnidx )) nnidx = MINLOC ( state % rmsd (), 1 ) end if ! end subroutine mobbrmsd_nearest_neighbor ! !| min_span_tree construction subroutine mobbrmsd_min_span_tree ( n_target , header , state , X , W , & & cutoff , difflim , maxeval , & & remove_com , sort_by_g , & & edges , weights , show_progress , & & verbose & ) integer ( IK ), intent ( in ) :: n_target !! number of coordinates type ( mobbrmsd_header ), intent ( in ) :: header !! mobbrmsd_header type ( mobbrmsd_state ), intent ( inout ) :: state ( n_target , n_target ) !! mobbrmsd_state, the result is contained in this structure. real ( kind = RK ), intent ( in ) :: X ( * ) !! coordinate sequence real ( kind = RK ), intent ( inout ) :: W ( * ) !! work memory, must be larger than header%memsize() * mobbrmsd_num_threads() real ( RK ), intent ( in ), optional :: cutoff !! The search ends when lowerbound is determined to be greater than to cutoff. real ( RK ), intent ( in ), optional :: difflim !! The search ends when the difference between the lower and upper bounds is less than difflim. integer ( IK ), intent ( in ), optional :: maxeval !! The search ends when ncount exceeds maxiter. logical , intent ( in ), optional :: remove_com !! if true, remove centroids. default [.true.] logical , intent ( in ), optional :: sort_by_g !! if true, row is sorted respect to G of reference coordinate. default [.true.] integer ( IK ), intent ( out ), optional :: edges ( 2 , n_target - 1 ) !! minimum spanning tree edges real ( RK ), intent ( out ), optional :: weights ( n_target - 1 ) !! minimum spanning tree weights logical , intent ( in ), optional :: show_progress !! if true, show progress bar logical , intent ( in ), optional :: verbose !! show progress bar type ( forbar ) :: fbar logical :: verbose_ logical :: mask ( n_target ) integer ( kind = IK ) :: list ( 2 , n_target ) real ( RK ) :: vval ( n_target - 1 ), nnval , cutoff_ integer ( kind = IK ) :: i , j , xpnt , ldx , nnidx ! ldx = header % n_dims () * header % n_atoms () ! !   Initialize header do concurrent ( i = 1 : n_target , j = 1 : n_target ) state ( i , j ) = mobbrmsd_state ( header ) end do ! mask (:) = . true . mask ( 1 ) = . false . list ( 1 , 1 ) = 0 list ( 2 , 1 ) = 1 ! if ( PRESENT ( verbose )) then verbose_ = verbose else verbose_ = . false . end if ! if ( verbose_ ) then fbar = progress_bar ( limit = n_target - 1 ) end if ! do j = 1 , n_target - 1 ! if ( verbose_ ) call fbar % update_and_display () ! vval ( j ) = RHUGE if ( PRESENT ( cutoff )) then cutoff_ = MIN ( RHUGE , MAX ( cutoff , ZERO )) else cutoff_ = RHUGE end if ! do i = 1 , j ! xpnt = ( list ( 2 , i ) - 1 ) * ldx + 1 ! call mobbrmsd_nearest_neighbor ( & & n_target , header , & & state (:, list ( 2 , i )), & & X ( xpnt ), X , W , & & cutoff = cutoff_ , & & difflim = difflim , & & maxeval = maxeval , & & remove_com = remove_com , & & sort_by_g = sort_by_g , & & mask = mask , & & nnval = nnval ,& & nnidx = nnidx ) ! if ( nnval < vval ( j )) then vval ( j ) = nnval cutoff_ = MIN ( cutoff_ , vval ( j )) list ( 1 , j + 1 ) = list ( 2 , i ) list ( 2 , j + 1 ) = nnidx end if ! end do ! mask ( list ( 2 , j + 1 )) = . false . ! end do ! if ( verbose_ ) call fbar % clean_up () ! do j = 1 , n_target do i = 1 , j - 1 if ( state ( i , j )% upperbound () < state ( j , i )% upperbound ()) then state ( j , i ) = state ( i , j ) else state ( i , j ) = state ( j , i ) end if end do end do ! if ( PRESENT ( edges )) then do concurrent ( i = 1 : n_target - 1 ) edges ( 1 , i ) = list ( 1 , i + 1 ) edges ( 2 , i ) = list ( 2 , i + 1 ) end do end if ! if ( PRESENT ( weights )) then do concurrent ( i = 1 : n_target - 1 ) weights ( i ) = vval ( i ) end do end if ! end subroutine mobbrmsd_min_span_tree ! ! --- ! pure recursive subroutine qs ( n , q ) integer , intent ( in ) :: n type ( priority_list ), intent ( inout ) :: q ( * ) type ( priority_list ) :: t integer :: i , j , p j = n ; i = 1 ; p = j / 2 do do while ( q ( i )% u < q ( p )% u ); i = i + 1 ; end do do while ( q ( j )% u > q ( p )% u ); j = j - 1 ; end do if ( i >= j ) exit t = q ( i ); q ( i ) = q ( j ); q ( j ) = t if ( i == p ) then ; p = j elseif ( j == p ) then ; p = i end if i = i + 1 ; j = j - 1 end do if ( 2 < i ) call qs ( i - 1 , q ( 1 )) if ( j < n - 1 ) call qs ( n - j , q ( j + 1 )) end subroutine qs ! end module mod_mobbrmsd_mst","tags":"","loc":"sourcefile/mod_mobbrmsd_mst.f90.html"},{"title":"mod_bb_block.f90 – mobbrmsd","text":"Contents Modules mod_bb_block Source Code mod_bb_block.f90 Source Code !| Module for handling  \\{\\mathbf{C}\\}_{IJs}, \\mathbf{F}  and the factrial tree. <br> !  This module provides procedures for performing branch-and-bound algorithms (BB) !  on assemblies consisting of homologous molecules. <br> !  Since the BB procedure is implemented for multi-component systems, !  this module does not provide the BB itself. <br> !  @note !    Node data block is defined by  [l_p, G_p, \\mathbf{C}_p], here <br> !     l_p           : scalar, lowerbound.<br> !     l_p = - \\max_{\\mathbf{R}} \\text{Tr} \\left[ \\mathbf{C}_p\\mathbf{R}\\right] - \\max_{\\nu'}\\sum_{I=p+1}&#94;M F_{I\\nu'(I)}  !     G_p           : scalar, partial sum of auto variance.<br> !     G_p = \\sum_{I=1}&#94;p \\mathbf{G}_{I\\nu(I)}  !     \\mathbf{C}_p  : partial sum of covariance. <br> !     \\mathbf{C}_p = \\sum_{I=1}&#94;p \\mathbf{C}_{I\\nu(I)\\sigma(I)}  !  @endnote module mod_bb_block use mod_params , only : IK , RK , ONE => RONE , ZERO => RZERO , RHUGE use mod_dimspec_functions , only : D , ND use mod_mol_block use mod_c_matrix use mod_f_matrix use mod_rotation use mod_Hungarian use mod_tree implicit none private public :: bb_block public :: bb_block_nmol public :: bb_block_natm public :: bb_block_molsize public :: bb_block_statesize public :: bb_block_memsize public :: bb_block_worksize public :: bb_block_setup public :: bb_block_inheritance public :: bb_block_expand public :: bb_block_closure public :: bb_block_is_left public :: bb_block_tree_is_empty public :: bb_block_tree_is_finished public :: bb_block_is_bottom public :: bb_block_current_level public :: bb_block_current_value public :: bb_block_lowest_value public :: bb_block_lowerbound public :: bb_block_set_ub_offset public :: bb_block_autocorr public :: bb_block_log_ncomb public :: bb_block_evaluation_count public :: bb_block_save_state public :: bb_block_swap_y public :: bb_block_covmat_add ! integer ( IK ), parameter :: mmap_L = 1 integer ( IK ), parameter :: mmap_G = 2 integer ( IK ), parameter :: mmap_C = 3 ! integer ( IK ), parameter :: INDEX_TO_Q_COV = 1 !! pointer to c_matrix interger array integer ( IK ), parameter :: INDEX_TO_Q_FRE = 2 !! pointer to f_matrix interger array integer ( IK ), parameter :: INDEX_TO_Q_TREE = 3 !! pointer to tree interger array integer ( IK ), parameter :: INDEX_TO_X_FRE = 4 !! pointer to f_matrix memory integer ( IK ), parameter :: INDEX_TO_X_TREE = 5 !! pointer to tree memory integer ( IK ), parameter :: INDEX_TO_W_COV = 6 !! pointer to c_matrix work memory integer ( IK ), parameter :: INDEX_TO_W_FRE = 7 !! pointer to f_matrix work memory integer ( IK ), parameter :: INDEX_TO_S_COV = 8 !! pointer to f_matrix work memory integer ( IK ), parameter :: bb_block_HEADER_FIXED_SIZE & & = SIZE ([ INDEX_TO_Q_COV , & & INDEX_TO_Q_FRE , & & INDEX_TO_Q_TREE , & & INDEX_TO_X_FRE , & & INDEX_TO_X_TREE , & & INDEX_TO_W_COV , & & INDEX_TO_W_FRE , & & INDEX_TO_S_COV & & ]) ! integer ( IK ), parameter :: q_POINTER_TO_Q_MOL = bb_block_HEADER_FIXED_SIZE + 1 !! pointer to mol_block header (fixed) integer ( IK ), parameter :: s_POINTER_TO_S_TREE = 1 !! pointer to tree state (fixed) ! integer ( IK ), parameter :: INDEX_TO_N_EVAL = 1 integer ( IK ), parameter :: INDEX_TO_LBOUND = 2 integer ( IK ), parameter :: INDEX_TO_OFFSET = 3 integer ( IK ), parameter :: bb_block_MEM_FIXED_SIZE & & = SIZE ([ INDEX_TO_N_EVAL , & & INDEX_TO_LBOUND , & & INDEX_TO_OFFSET & & ]) !! pointer to evaluation count (fixed) integer ( IK ), parameter :: w_POINTER_TO_X_COV = bb_block_MEM_FIXED_SIZE + 1 !! pointer to c_matrix array (fixed) ! !| bb_block<br> !  This is mainly used for passing during initialization. type bb_block integer ( IK ), allocatable :: q (:) !! static integer array integer ( IK ), allocatable :: s (:) !! work integer array contains final :: bb_block_destroy end type bb_block ! interface bb_block module procedure bb_block_new end interface bb_block ! contains ! !| Constructer pure function bb_block_new ( n_apm , n_mol , sym ) result ( res ) integer ( IK ), intent ( in ) :: n_apm !! number of molecules. integer ( IK ), intent ( in ) :: n_mol !! number of atoms per molecule. integer ( IK ), intent ( in ), optional :: sym (:, :) !! symmetric codomains, [[a1,a2,...,am], [b1,b2,...,bm], ...]. type ( mol_block ) :: b type ( c_matrix ) :: c type ( f_matrix ) :: f type ( tree ) :: t type ( bb_block ) :: res integer ( IK ) :: q ( bb_block_HEADER_FIXED_SIZE ) associate ( & & qmol => q_POINTER_TO_Q_MOL , & & qcov => q ( INDEX_TO_Q_COV ), & & qfre => q ( INDEX_TO_Q_FRE ), & & qtree => q ( INDEX_TO_Q_TREE ), & & xfre => q ( INDEX_TO_X_FRE ), & & xtree => q ( INDEX_TO_X_TREE ), & & wcov => q ( INDEX_TO_W_COV ), & & wfre => q ( INDEX_TO_W_FRE ), & & scov => q ( INDEX_TO_S_COV ), & & stree => s_POINTER_TO_S_TREE & & ) b = mol_block ( n_apm , n_mol , sym ) c = c_matrix ( b % q ) f = f_matrix ( b % q ) t = tree ( mol_block_nmol ( b % q ), mol_block_nsym ( b % q )) ! qcov = qmol + SIZE ( b % q ) qfre = qcov + SIZE ( c % q ) qtree = qfre + SIZE ( f % q ) ! scov = stree + SIZE ( t % s ) ! wcov = w_POINTER_TO_X_COV + c_matrix_memsize ( c % q ) xfre = wcov wfre = xfre + f_matrix_memsize ( f % q ) xtree = wfre ! allocate ( res % q , source = [ q , b % q , c % q , f % q , t % q ]) allocate ( res % s , source = [ t % s , c % s ]) end associate end function bb_block_new ! !| Returns the memory size array size. pure function bb_block_memsize ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! bb_block header array. integer ( IK ) :: res associate ( & & qcov => q ( INDEX_TO_Q_COV ), & & qfre => q ( INDEX_TO_Q_FRE ), & & qtree => q ( INDEX_TO_Q_TREE ) & & ) res = bb_block_MEM_FIXED_SIZE & & + c_matrix_memsize ( q ( qcov )) & & + f_matrix_memsize ( q ( qfre )) & & + tree_nnodes ( q ( qtree )) * ND end associate end function bb_block_memsize ! !| Returns the work memory size array size. pure function bb_block_worksize ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! header. integer ( IK ) :: p , nmol , nsym , buf , tmp , swrk , hwrk , fwrk , cwrk integer ( IK ) :: res associate (& & qmol => q_POINTER_TO_Q_MOL , & & qcov => q ( INDEX_TO_Q_COV ), & & qfre => q ( INDEX_TO_Q_FRE ), & & qtree => q ( INDEX_TO_Q_TREE ) & & ) nmol = mol_block_nmol ( q ( qmol )) nsym = mol_block_nsym ( q ( qmol )) swrk = sdmin_worksize () fwrk = f_matrix_worksize ( q ( qfre )) cwrk = c_matrix_worksize ( q ( qcov )) buf = bb_block_memsize ( q ) res = 0 do p = 1 , nmol hwrk = Hungarian_worksize ( p , p ) tmp = MAX ( p ** 2 + hwrk , swrk * nsym + 1 ) res = MAX ( res , buf + tmp ) buf = buf - p * nsym * ND end do hwrk = Hungarian_worksize ( nmol , nmol ) res = MAX ( res , buf + MAX ( hwrk , fwrk )) res = MAX ( res , c_matrix_memsize ( q ( qcov )) + cwrk ) end associate end function bb_block_worksize ! !| Returns the number of molecules. pure function bb_block_nmol ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! header. integer ( IK ) :: res associate ( qmol => q_POINTER_TO_Q_MOL ) res = mol_block_nmol ( q ( qmol )) end associate end function bb_block_nmol ! !| Returns the number of molecules. pure function bb_block_natm ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! header. integer ( IK ) :: res associate ( qmol => q_POINTER_TO_Q_MOL ) res = mol_block_natm ( q ( qmol )) end associate end function bb_block_natm ! !| Returns the memory size of molecular block size. pure function bb_block_molsize ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! bb_block header array. integer ( IK ) :: res associate ( qmol => q_POINTER_TO_Q_MOL ) res = mol_block_total_size ( q ( qmol )) end associate end function bb_block_molsize ! !| Returns size of saved state. pure function bb_block_statesize ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! header. integer ( IK ) :: res associate ( qmol => q_POINTER_TO_Q_MOL ) res = mol_block_nmol ( q ( qmol )) end associate end function bb_block_statesize ! !| Setup C matrix and F matrix in root node. pure subroutine bb_block_setup ( q , X , Y , CX , CY , s , W , zfill , sort_by_g ) integer ( IK ), intent ( in ) :: q ( * ) !! integer array real ( RK ), intent ( in ) :: X ( * ) !! reference coordinate real ( RK ), intent ( in ) :: Y ( * ) !! target coordinate real ( RK ), intent ( in ) :: CX ( * ) !! centroid of X real ( RK ), intent ( in ) :: CY ( * ) !! centroid of Y integer ( IK ), intent ( inout ) :: s ( * ) !! integer work array real ( RK ), intent ( inout ) :: W ( * ) !! work integer array logical , intent ( in ) :: zfill !! if true, the root node is filled by zero. logical , intent ( in ), optional :: sort_by_g !! if true, row is sorted respect to G of reference coordinate. integer ( IK ) :: nmol associate ( & & qmol => q_POINTER_TO_Q_MOL , & & neval => W ( INDEX_TO_N_EVAL ), & & lboud => W ( INDEX_TO_LBOUND ), & & ubofs => W ( INDEX_TO_OFFSET ), & & scov => q ( INDEX_TO_S_COV ), & & stree => s_POINTER_TO_S_TREE , & & qtree => q ( INDEX_TO_Q_TREE ), & & qcov => q ( INDEX_TO_Q_COV ), & & qfre => q ( INDEX_TO_Q_FRE ), & & xcov => w_POINTER_TO_X_COV , & & xtree => q ( INDEX_TO_X_TREE ), & & wfre => q ( INDEX_TO_X_FRE ), & & wcov => q ( INDEX_TO_W_COV ), & & fwork => q ( INDEX_TO_W_FRE ) & & ) nmol = mol_block_nmol ( q ( qmol )) neval = ZERO call tree_reset ( q ( qtree ), s ( stree )) call c_matrix_eval ( & & q ( qcov ), & & q ( qmol ), & & s ( scov ), & & X , & & Y , & & CX , & & CY , & & W ( xcov ), & & W ( wcov ), & & sort_by_g = sort_by_g & & ) call f_matrix_eval ( q ( qfre ), q ( qcov ), W ( xcov ), W ( wfre ), W ( fwork )) call Hungarian ( nmol , nmol , W ( wfre ), W ( fwork )) lboud = W ( fwork ) ubofs = ZERO ! if (. not . zfill ) return ! block real ( RK ) :: ZEROS ( ND ) ZEROS = ZERO call evaluate_nodes ( nmol , q , s , ZEROS , W , W ( xtree ), neval ) end block end associate end subroutine bb_block_setup ! !| Expands the latest node of the parent block to the top-level queue of the child block. pure subroutine bb_block_inheritance ( q , s , W , p , r , Z ) integer ( IK ), intent ( in ) :: q ( * ) !! work integer array integer ( IK ), intent ( inout ) :: s ( * ) !! work integer array real ( RK ), intent ( inout ) :: W ( * ) !! main memory integer ( IK ), intent ( in ) :: p ( * ) !! parent integer array integer ( ik ), intent ( in ) :: r ( * ) !! parent integer work array real ( RK ), intent ( in ) :: Z ( * ) !! parent work array integer ( IK ) :: znode , nmol associate ( & & qmol => q_POINTER_TO_Q_MOL , & & neval => W ( INDEX_TO_N_EVAL ), & & qtree => q ( INDEX_TO_Q_TREE ), & & qcov => q ( INDEX_TO_Q_COV ), & & qfre => q ( INDEX_TO_Q_FRE ), & & stree => s_POINTER_TO_S_TREE , & & xtree => q ( INDEX_TO_X_TREE ), & & wfre => q ( INDEX_TO_X_FRE ), & & xcov => w_POINTER_TO_X_COV , & & ptree => p ( INDEX_TO_Q_TREE ), & & ztree => p ( INDEX_TO_X_TREE ), & & rtree => s_POINTER_TO_S_TREE & & ) nmol = mol_block_nmol ( q ( qmol )) znode = ztree + ( tree_current_pointer ( p ( ptree ), r ( rtree )) - 1 ) * ND call tree_reset ( q ( qtree ), s ( stree )) call evaluate_nodes ( nmol , q , s , Z ( znode ), W , W ( xtree ), neval ) end associate end subroutine bb_block_inheritance ! !| Expand top node in queue. pure subroutine bb_block_expand ( UB , q , s , W ) real ( RK ), intent ( in ) :: UB !! upper bound integer ( IK ), intent ( in ) :: q ( * ) !! header integer ( IK ), intent ( inout ) :: s ( * ) !! state real ( RK ), intent ( inout ) :: W ( * ) !! main memory real ( RK ) :: ubval integer ( IK ) :: nmol integer ( IK ) :: pp ! previous current node associate ( & & qmol => q_POINTER_TO_Q_MOL , & & neval => W ( INDEX_TO_N_EVAL ), & & ubofs => W ( INDEX_TO_OFFSET ), & & stree => s_POINTER_TO_S_TREE , & & qtree => q ( INDEX_TO_Q_TREE ),& & xcov => w_POINTER_TO_X_COV , & & xtree => q ( INDEX_TO_X_TREE ),& & qcov => q ( INDEX_TO_Q_COV ), & & wfrx => q ( INDEX_TO_X_FRE )& & ) nmol = mol_block_nmol ( q ( qmol )) ubval = UB - ubofs block do call tree_select_top_node ( q ( qtree ), s ( stree ), ND , ubval , W ( xtree )) if ( tree_queue_is_bottom ( q ( qtree ), s ( stree )) & & . or . tree_queue_is_empty ( q ( qtree ), s ( stree ))) exit pp = xtree + ( tree_current_pointer ( q ( qtree ), s ( stree )) - 1 ) * ND call tree_expand ( q ( qtree ), s ( stree )) call evaluate_nodes ( nmol , q , s , W ( pp ), W , W ( xtree ), neval ) end do end block end associate end subroutine bb_block_expand ! !| closure current node. pure subroutine bb_block_closure ( UB , q , s , W ) real ( RK ), intent ( in ) :: UB !! upper bound integer ( IK ), intent ( in ) :: q ( * ) !! work integer array integer ( IK ), intent ( inout ) :: s ( * ) !! work integer array real ( RK ), intent ( in ) :: W ( * ) real ( RK ) :: ubval !! main memory associate (& & ubofs => W ( INDEX_TO_OFFSET ), & & stree => s_POINTER_TO_S_TREE , & & qtree => q ( INDEX_TO_Q_TREE ), & & xtree => q ( INDEX_TO_X_TREE ) & & ) ubval = UB - ubofs do if ( tree_queue_is_left ( q ( qtree ), s ( stree ), ND , ubval , W ( xtree )) & & . or . tree_queue_is_root ( q ( qtree ), s ( stree ))) exit call tree_leave ( q ( qtree ), s ( stree )) end do end associate end subroutine bb_block_closure ! !| Evaluate nodes in tree_current_level. pure subroutine evaluate_nodes ( nmol , q , s , Z , W , xtree , neval ) integer ( IK ), intent ( in ) :: nmol , q ( * ), s ( * ) real ( RK ), intent ( in ) :: Z ( ND ), W ( * ) real ( RK ), intent ( inout ) :: xtree ( ND , * ), neval integer ( IK ) :: l , px , pw , m , nw , nh , nper , nsym , iper , perm ( nmol ) associate (& & qcov => q ( INDEX_TO_Q_COV ), & & stree => s_POINTER_TO_S_TREE , & & qtree => q ( INDEX_TO_Q_TREE ), & & xcov => w_POINTER_TO_X_COV , & & xfre => q ( INDEX_TO_X_FRE ) & & ) l = tree_current_level ( s ( stree )) m = nmol - l ! residual dimension nw = sdmin_worksize () nh = Hungarian_worksize ( m , m ) px = tree_queue_pointer ( q ( qtree ), s ( stree )) ! nsym = tree_n_sym ( q ( qtree )) nper = tree_n_perm ( q ( qtree ), s ( stree )) perm = tree_current_permutation ( q ( qtree ), s ( stree )) pw = px + nsym ! do iper = 1 , nper call evaluate_queue ( iper , perm ( l + iper - 1 ), l , & & m , nw , nh , nsym , nper , nmol , q ( qcov ), perm , & & W ( xcov ), W ( xfre ), Z , xtree ( 1 , px ), & & xtree ( 1 , pw ), xtree ( 2 , pw )) pw = pw + nsym end do ! neval = neval + real ( nsym * nper , RK ) end associate end subroutine evaluate_nodes ! !| Evaluate nodes in tree_current_level and iper. pure subroutine evaluate_queue ( iper , iabp , l , m , nw , nh , nsym , nper , nmol , qcov , perm , C , F , Z , X , W1 , W2 ) integer ( IK ), intent ( in ) :: iper , iabp , l , m , nw , nh , nsym , nper , nmol integer ( IK ), intent ( in ) :: qcov ( * ), perm ( * ) real ( RK ), intent ( in ) :: C ( * ), F ( * ), Z ( ND ) real ( RK ), intent ( inout ) :: X ( ND , nsym , nper ), W1 ( * ), W2 ( nw , * ) integer ( IK ) :: isym if ( m == 0 ) then W1 ( 1 ) = ZERO else call subm ( l , nmol , iper , perm , F , W1 ( nh + 1 )) call Hungarian ( m , m , W1 ( nh + 1 ), W1 ( 1 )) end if do concurrent ( isym = 1 : nsym ) call copy ( ND , Z , X ( 1 , isym , iper )) call c_matrix_add ( qcov , l , iabp , isym , C , X ( mmap_G , isym , iper ), X ( mmap_C , isym , iper )) call estimate_rcmax ( X ( mmap_G , isym , iper ), X ( mmap_C , isym , iper ), W2 ( 1 , isym )) X ( mmap_L , isym , iper ) = W1 ( 1 ) - W2 ( 1 , isym ) end do end subroutine evaluate_queue ! pure subroutine subm ( l , n , r , perm , X , Y ) integer ( IK ), intent ( in ) :: l , n , r , perm ( * ) real ( RK ), intent ( in ) :: X ( n , n ) real ( RK ), intent ( inout ) :: Y ( n - l , n - l ) integer ( IK ) :: i , j ! do concurrent ( j = l + 1 : n ) do concurrent ( i = l : l + r - 2 ) Y ( i - l + 1 , j - l ) = X ( perm ( i ), j ) end do do concurrent ( i = l + r : n ) Y ( i - l , j - l ) = X ( perm ( i ), j ) end do end do ! end subroutine subm ! !| Returns true when tree is empty pure function bb_block_is_left ( UB , q , s , W ) result ( res ) real ( RK ), intent ( in ) :: UB !! upper bound integer ( IK ), intent ( in ) :: q ( * ) !! integer array integer ( IK ), intent ( in ) :: s ( * ) !! work integer array real ( RK ), intent ( in ) :: W ( * ) !! main memory real ( RK ) :: ubval logical :: res associate ( & & ubofs => W ( INDEX_TO_OFFSET ), & & stree => s_POINTER_TO_S_TREE , & & qtree => q ( INDEX_TO_Q_TREE ), & & wtree => q ( INDEX_TO_X_TREE ) & & ) ubval = UB - ubofs res = tree_queue_is_left ( q ( qtree ), s ( stree ), ND , ubval , W ( wtree )) end associate end function bb_block_is_left ! !| Returns true when tree is empty pure function bb_block_tree_is_empty ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! integer array integer ( IK ), intent ( in ) :: s ( * ) !! work integer array logical :: res associate (& & stree => s_POINTER_TO_S_TREE , & & qtree => q ( INDEX_TO_Q_TREE ) & & ) res = tree_queue_is_empty ( q ( qtree ), s ( stree )) end associate end function bb_block_tree_is_empty ! !| Returns true when tree is finished pure function bb_block_tree_is_finished ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! integer array integer ( IK ), intent ( in ) :: s ( * ) !! work integer array logical :: res associate ( & & stree => s_POINTER_TO_S_TREE , & & qtree => q ( INDEX_TO_Q_TREE )) res = tree_queue_is_empty ( q ( qtree ), s ( stree )) & &. and . tree_queue_is_root ( q ( qtree ), s ( stree )) end associate end function bb_block_tree_is_finished ! !| Returns true when tree is bottom pure function bb_block_is_bottom ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! integer array integer ( IK ), intent ( in ) :: s ( * ) !! work integer array logical :: res associate ( & & stree => s_POINTER_TO_S_TREE , & & qtree => q ( INDEX_TO_Q_TREE ) & & ) res = tree_queue_is_selected ( q ( qtree ), s ( stree )) & &. and . tree_queue_is_bottom ( q ( qtree ), s ( stree )) end associate end function bb_block_is_bottom ! !| Returns current level. pure function bb_block_current_level ( q , s ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! header integer ( IK ), intent ( in ) :: s ( * ) !! work integer array integer ( IK ) :: res associate ( & & stree => s_POINTER_TO_S_TREE & & ) res = tree_current_level ( s ( stree )) end associate end function bb_block_current_level ! !| Returns current L value. pure function bb_block_current_value ( q , s , W ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! integer array integer ( IK ), intent ( in ) :: s ( * ) !! work integer array real ( RK ), intent ( in ) :: W ( * ) !! main memory real ( RK ) :: res integer ( IK ) :: t associate ( & & stree => s_POINTER_TO_S_TREE , & & qtree => q ( INDEX_TO_Q_TREE ), & & wtree => q ( INDEX_TO_X_TREE ) & & ) t = wtree + mmap_L - 1 + ND * ( tree_current_pointer ( q ( qtree ), s ( stree )) - 1 ) res = W ( t ) end associate end function bb_block_current_value ! !| Returns the minimum value of the surviving nodes, excluding the current value. pure function bb_block_lowest_value ( q , s , W ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! header integer ( IK ), intent ( in ) :: s ( * ) !! state real ( RK ), intent ( in ) :: W ( * ) !! main memory real ( RK ) :: res associate (& & stree => s_POINTER_TO_S_TREE , & & qtree => q ( INDEX_TO_Q_TREE ), & & wtree => q ( INDEX_TO_X_TREE )) res = tree_lowest_value ( q ( qtree ), s ( stree ), ND , W ( wtree )) + W ( INDEX_TO_OFFSET ) end associate end function bb_block_lowest_value ! !| Set ub offset value pure subroutine bb_block_set_ub_offset ( W , ubofs ) real ( RK ), intent ( inout ) :: W ( * ) !! main memory real ( RK ), intent ( in ) :: ubofs !! main memory W ( INDEX_TO_OFFSET ) = ubofs end subroutine bb_block_set_ub_offset ! !| Returns the minimum value of the surviving nodes, excluding the current value. pure function bb_block_lowerbound ( W ) result ( res ) real ( RK ), intent ( in ) :: W ( * ) !! main memory real ( RK ) :: res res = W ( INDEX_TO_LBOUND ) end function bb_block_lowerbound ! !| Returns the minimum value of the surviving nodes, excluding the current value. pure function bb_block_evaluation_count ( W ) result ( res ) real ( RK ), intent ( in ) :: W ( * ) !! main memory real ( RK ) :: res res = W ( INDEX_TO_N_EVAL ) end function bb_block_evaluation_count ! !| Returns the minimum value of the surviving nodes, excluding the current value. pure function bb_block_log_ncomb ( q ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! integer array real ( RK ) :: res associate ( qtree => q ( INDEX_TO_Q_TREE )) res = tree_log_ncomb ( q ( qtree )) end associate end function bb_block_log_ncomb ! !| Returns the minimum value of the surviving nodes, excluding the current value. pure function bb_block_autocorr ( q , W ) result ( res ) integer ( IK ), intent ( in ) :: q ( * ) !! header real ( RK ), intent ( in ) :: W ( * ) !! main memory real ( RK ) :: res associate ( & & qcov => q ( INDEX_TO_Q_COV ), & & xcov => w_POINTER_TO_X_COV & & ) call c_matrix_autocorr ( q ( qcov ), W ( xcov ), res ) end associate end function bb_block_autocorr ! !| Save current state. pure subroutine bb_block_save_state ( q , s , z ) integer ( IK ), intent ( in ) :: q ( * ) !! integer array integer ( IK ), intent ( in ) :: s ( * ) !! state vector integer ( IK ), intent ( inout ) :: z ( * ) !! memory integer ( IK ) :: nmol associate ( & & stree => s_POINTER_TO_S_TREE , & & qtree => q ( INDEX_TO_Q_TREE ), & & qmol => q_POINTER_TO_Q_MOL & & ) nmol = mol_block_nmol ( q ( qmol )) z (: nmol ) = tree_current_sequence ( q ( qtree ), s ( stree )) end associate end subroutine bb_block_save_state ! !| swap Y by saved state z. pure subroutine bb_block_swap_y ( q , s , z , Y ) integer ( IK ), intent ( in ) :: q ( * ) !! header integer ( IK ), intent ( in ) :: s ( * ) !! state integer ( IK ), intent ( in ) :: z ( * ) !! saved state (not state vector) real ( RK ), intent ( inout ) :: Y ( * ) !! target coordinate integer ( IK ) :: nmol , napm associate ( & & qcov => q ( INDEX_TO_Q_COV ), & & scov => q ( INDEX_TO_S_COV ), & & qtree => q ( INDEX_TO_Q_TREE ), & & qmol => q_POINTER_TO_Q_MOL & & ) nmol = mol_block_nmol ( q ( qmol )) napm = mol_block_napm ( q ( qmol )) block integer ( IK ) :: iper ( nmol ), imap ( nmol ) call c_matrix_swap_indices ( & & q ( qcov ), & & s ( scov ), & & tree_sequence_to_permutation ( q ( qtree ), z ), & & iper ) imap = tree_sequence_to_mapping ( q ( qtree ), z ) call swap_y ( nmol , napm , iper , imap , q ( qmol ), Y ) end block end associate contains pure subroutine swap_y ( nmol , napm , iper , imap , b , Y ) integer ( IK ), intent ( in ) :: nmol , napm , iper ( nmol ), imap ( nmol ), b ( * ) real ( RK ), intent ( inout ) :: Y ( D , napm , nmol ) real ( RK ) :: T ( D , napm , nmol ) integer ( IK ) :: i , dm , dmn dm = D * napm dmn = dm * nmol do concurrent ( i = 1 : nmol ) call copy ( dm , Y (:, :, i ), T (:, :, iper ( i ))) call mol_block_swap ( b , imap ( i ), T ( 1 , 1 , iper ( i ))) end do call copy ( dmn , T , Y ) end subroutine swap_y end subroutine bb_block_swap_y ! !| Sum covariance matrix by saved state z. pure subroutine bb_block_covmat_add ( q , z , W , G , C ) integer ( IK ), intent ( in ) :: q ( * ) !! integer array integer ( IK ), intent ( in ) :: z ( * ) !! saved state (not state vector) real ( RK ), intent ( in ) :: W ( * ) !! main memory real ( RK ), intent ( inout ) :: G !! autovariance real ( RK ), intent ( inout ) :: C ( * ) !! covariance matrix integer ( IK ) :: nmol associate ( & & qcov => q ( INDEX_TO_Q_COV ), & & qtree => q ( INDEX_TO_Q_TREE ), & & xcov => w_POINTER_TO_X_COV , & & qmol => q_POINTER_TO_Q_MOL & & ) nmol = mol_block_nmol ( q ( qmol )) block integer ( IK ) :: i , iper ( nmol ), imap ( nmol ) iper = tree_sequence_to_permutation ( q ( qtree ), z ) imap = tree_sequence_to_mapping ( q ( qtree ), z ) + 1 do i = 1 , nmol call c_matrix_add ( q ( qcov ), i , iper ( i ), imap ( i ), W ( xcov ), G , C ) end do end block end associate end subroutine bb_block_covmat_add ! ! util ! !| destructer pure elemental subroutine bb_block_destroy ( this ) type ( bb_block ), intent ( inout ) :: this if ( ALLOCATED ( this % q )) deallocate ( this % q ) if ( ALLOCATED ( this % s )) deallocate ( this % s ) end subroutine bb_block_destroy ! pure subroutine copy ( N , X , Y ) integer ( IK ), intent ( in ) :: N real ( RK ), intent ( in ) :: X ( * ) real ( RK ), intent ( inout ) :: Y ( * ) integer ( IK ) :: i do concurrent ( i = 1 : N ) Y ( i ) = X ( i ) end do end subroutine copy ! end module mod_bb_block","tags":"","loc":"sourcefile/mod_bb_block.f90.html"},{"title":"mod_dimspec_functions.f90 – mobbrmsd","text":"Contents Modules mod_dimspec_functions Subroutines DGEMM SGEMM Source Code mod_dimspec_functions.f90 Source Code !| Define spatial dimension, D=2, !  and provide optimized functions for dimension. module mod_dimspec_functions use mod_kinds , only : RK , IK implicit none private public :: D , DD , ND public :: setup_dimension public :: compute_com public :: compute_cov public :: covcopy ! !| Spatial dimension integer ( IK ), parameter :: D = 2 !| Square spatial dimension integer ( IK ), parameter :: DD = 4 !| Node memory size, defined by 1 + 1 + D&#94;2. !  Let [L, G, \\mathbf{C}] be a node, !  where L, G\\in\\mathbb{R} and \\mathbf{C}\\in\\mathbb{R}&#94;{D\\times D}. integer ( IK ), parameter :: ND = DD + 2 ! real ( RK ), parameter :: ZERO = 0.0_RK real ( RK ), parameter :: HALF = 0.5_RK real ( RK ), parameter :: ONETHIRD = 1.0_RK / 3.0_RK real ( RK ), parameter :: ONE = 1.0_RK ! interface include 'dgemm.h' include 'sgemm.h' end interface ! contains !| Sets the dimensions of the space. <br> !  This is dummy interface. subroutine setup_dimension ( d_ ) integer ( IK ), intent ( in ) :: d_ end subroutine setup_dimension ! !| Calculate center of mass for D=2 pure subroutine compute_com ( d , n , X , C ) integer ( IK ), intent ( in ) :: d , n real ( RK ), intent ( in ) :: X ( d , * ) real ( RK ), intent ( inout ) :: C ( d ) real ( RK ) :: rn integer ( IK ) :: i if ( n < 0 ) then C ( 1 ) = ZERO C ( 2 ) = ZERO return elseif ( n == 1 ) then C ( 1 ) = X ( 1 , 1 ) C ( 2 ) = X ( 2 , 1 ) return elseif ( n == 2 ) then C ( 1 ) = ( X ( 1 , 1 ) + X ( 1 , 2 )) * HALF C ( 2 ) = ( X ( 2 , 1 ) + X ( 2 , 2 )) * HALF return elseif ( n == 3 ) then C ( 1 ) = ( X ( 1 , 1 ) + X ( 1 , 2 ) + X ( 1 , 3 )) * ONETHIRD C ( 2 ) = ( X ( 2 , 1 ) + X ( 2 , 2 ) + X ( 2 , 3 )) * ONETHIRD return end if C ( 1 ) = ZERO C ( 2 ) = ZERO do i = 2 , n , 2 C ( 1 ) = C ( 1 ) + X ( 1 , i - 1 ) C ( 2 ) = C ( 2 ) + X ( 2 , i - 1 ) C ( 1 ) = C ( 1 ) + X ( 1 , i - 0 ) C ( 2 ) = C ( 2 ) + X ( 2 , i - 0 ) end do if ( MODULO ( n , 2 ) == 1 ) then C ( 1 ) = C ( 1 ) + X ( 1 , n ) C ( 2 ) = C ( 2 ) + X ( 2 , n ) end if rn = ONE / real ( n , RK ) C ( 1 ) = C ( 1 ) * rn C ( 2 ) = C ( 2 ) * rn end subroutine compute_com ! !| Calculate covariance matrix. pure subroutine compute_cov ( d , n , X , Y , C ) integer ( IK ), intent ( in ) :: d , n real ( RK ), intent ( in ) :: X ( d , * ), Y ( d , * ) real ( RK ), intent ( inout ) :: C ( d , d ) #ifdef REAL32 call SGEMM ( 'N' , 'T' , D , D , n , ONE , Y , D , X , D , ZERO , C , D ) #else call DGEMM ( 'N' , 'T' , D , D , n , ONE , Y , D , X , D , ZERO , C , D ) #endif end subroutine compute_cov ! !| Compute \\mathbf{Y} \\gets \\mathbf{X}-\\bar{\\mathbf{X}}  !  for D=2 pure subroutine covcopy ( d , n , X , CX , Y ) integer ( IK ), intent ( in ) :: d , n real ( RK ), intent ( in ) :: X ( d , * ), CX ( d ) real ( RK ), intent ( inout ) :: Y ( d , * ) integer ( IK ) :: i do concurrent ( i = 1 : n ) Y ( 1 , i ) = X ( 1 , i ) - CX ( 1 ) Y ( 2 , i ) = X ( 2 , i ) - CX ( 2 ) end do end subroutine covcopy ! end module mod_dimspec_functions ! !| DGEMM for M=N=2. <br> !  N and M are provided for compatibility with BLAS and are not used here. <br> !  @warning !    This is not a full-featured routine for GEMM. <br> !    Do not use this routine for anything other than calculating the covariance matrix. <br> !    Calculate only operations with  \\mathbf{C} = \\mathbf{A} \\mathbf{B}&#94;\\top . !  @endwarning pure subroutine DGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) use , intrinsic :: ISO_FORTRAN_ENV , only : RK => REAL64 character ( 1 ), intent ( in ) :: TRANSA !! IF TRANSA(1)='T', transpose A. character ( 1 ), intent ( in ) :: TRANSB !! IF TRANSB(1)='T', transpose B. integer , intent ( in ) :: M !! matrix dimension, not used. integer , intent ( in ) :: N !! matrix dimension, not used. integer , intent ( in ) :: K !! matrix dimension, not used. real ( RK ), intent ( in ) :: ALPHA !! A coefficient, not used. integer , intent ( in ) :: LDA !! leading dimension of A, must be >1. real ( RK ), intent ( in ) :: A ( LDA , * ) !! matrix A. integer , intent ( in ) :: LDB !! leading dimension of B, must be >1. real ( RK ), intent ( in ) :: B ( LDA , * ) !! matrix B. real ( RK ), intent ( in ) :: BETA !! A coefficient, not used. integer , intent ( in ) :: LDC !! leading dimension of C, must be >1. real ( RK ), intent ( inout ) :: C ( LDA , * ) !! matrix C. integer :: i ! C ( 1 , 1 ) = 0.0_RK C ( 2 , 1 ) = 0.0_RK C ( 1 , 2 ) = 0.0_RK C ( 2 , 2 ) = 0.0_RK ! do i = 4 , K , 4 C ( 1 , 1 ) = C ( 1 , 1 ) + A ( 1 , i - 3 ) * B ( 1 , i - 3 ) & & + A ( 1 , i - 2 ) * B ( 1 , i - 2 ) & & + A ( 1 , i - 1 ) * B ( 1 , i - 1 ) & & + A ( 1 , i - 0 ) * B ( 1 , i - 0 ) C ( 2 , 1 ) = C ( 2 , 1 ) + A ( 2 , i - 3 ) * B ( 1 , i - 3 ) & & + A ( 2 , i - 2 ) * B ( 1 , i - 2 ) & & + A ( 2 , i - 1 ) * B ( 1 , i - 1 ) & & + A ( 2 , i - 0 ) * B ( 1 , i - 0 ) C ( 1 , 2 ) = C ( 1 , 2 ) + A ( 1 , i - 3 ) * B ( 2 , i - 3 ) & & + A ( 1 , i - 2 ) * B ( 2 , i - 2 ) & & + A ( 1 , i - 1 ) * B ( 2 , i - 1 ) & & + A ( 1 , i - 0 ) * B ( 2 , i - 0 ) C ( 2 , 2 ) = C ( 2 , 2 ) + A ( 2 , i - 3 ) * B ( 2 , i - 3 ) & & + A ( 2 , i - 2 ) * B ( 2 , i - 2 ) & & + A ( 2 , i - 1 ) * B ( 2 , i - 1 ) & & + A ( 2 , i - 0 ) * B ( 2 , i - 0 ) end do ! select case ( MODULO ( K , 4 )) case ( 1 ) C ( 1 , 1 ) = C ( 1 , 1 ) + A ( 1 , K ) * B ( 1 , K ) C ( 2 , 1 ) = C ( 2 , 1 ) + A ( 2 , K ) * B ( 1 , K ) C ( 1 , 2 ) = C ( 1 , 2 ) + A ( 1 , K ) * B ( 2 , K ) C ( 2 , 2 ) = C ( 2 , 2 ) + A ( 2 , K ) * B ( 2 , K ) case ( 2 ) C ( 1 , 1 ) = C ( 1 , 1 ) + A ( 1 , K - 1 ) * B ( 1 , K - 1 ) + A ( 1 , K ) * B ( 1 , K ) C ( 2 , 1 ) = C ( 2 , 1 ) + A ( 2 , K - 1 ) * B ( 1 , K - 1 ) + A ( 2 , K ) * B ( 1 , K ) C ( 1 , 2 ) = C ( 1 , 2 ) + A ( 1 , K - 1 ) * B ( 2 , K - 1 ) + A ( 1 , K ) * B ( 2 , K ) C ( 2 , 2 ) = C ( 2 , 2 ) + A ( 2 , K - 1 ) * B ( 2 , K - 1 ) + A ( 2 , K ) * B ( 2 , K ) case ( 3 ) C ( 1 , 1 ) = C ( 1 , 1 ) + A ( 1 , K - 2 ) * B ( 1 , K - 2 ) + A ( 1 , K - 1 ) * B ( 1 , K - 1 ) + A ( 1 , K ) * B ( 1 , K ) C ( 2 , 1 ) = C ( 2 , 1 ) + A ( 2 , K - 2 ) * B ( 1 , K - 2 ) + A ( 2 , K - 1 ) * B ( 1 , K - 1 ) + A ( 2 , K ) * B ( 1 , K ) C ( 1 , 2 ) = C ( 1 , 2 ) + A ( 1 , K - 2 ) * B ( 2 , K - 2 ) + A ( 1 , K - 1 ) * B ( 2 , K - 1 ) + A ( 1 , K ) * B ( 2 , K ) C ( 2 , 2 ) = C ( 2 , 2 ) + A ( 2 , K - 2 ) * B ( 2 , K - 2 ) + A ( 2 , K - 1 ) * B ( 2 , K - 1 ) + A ( 2 , K ) * B ( 2 , K ) end select ! ! do i = 2, K, 2 !   C(1, 1) = C(1, 1) + A(1, i - 1) * B(1, i - 1) + A(1, i) * B(1, i) !   C(2, 1) = C(2, 1) + A(2, i - 1) * B(1, i - 1) + A(2, i) * B(1, i) ! enddo ! do i = 2, K, 2 !   C(1, 2) = C(1, 2) + A(1, i - 1) * B(2, i - 1) + A(1, i) * B(2, i) !   C(2, 2) = C(2, 2) + A(2, i - 1) * B(2, i - 1) + A(2, i) * B(2, i) ! enddo ! if (MODULO(K, 2) == 1) then !   C(1, 1) = C(1, 1) + A(1, K) * B(1, K) !   C(2, 1) = C(2, 1) + A(2, K) * B(1, K) !   C(1, 2) = C(1, 2) + A(1, K) * B(2, K) !   C(2, 2) = C(2, 2) + A(2, K) * B(2, K) ! end if ! ! do i = 1, K !   C(1, 1) = C(1, 1) + A(1, i) * B(1, i) !   C(2, 1) = C(2, 1) + A(2, i) * B(1, i) ! enddo ! do i = 1, K !   C(1, 2) = C(1, 2) + A(1, i) * B(2, i) !   C(2, 2) = C(2, 2) + A(2, i) * B(2, i) ! enddo ! ! do i = 1, K !   C(1, 1) = C(1, 1) + A(1, i) * B(1, i) !   C(2, 1) = C(2, 1) + A(2, i) * B(1, i) !   C(1, 2) = C(1, 2) + A(1, i) * B(2, i) !   C(2, 2) = C(2, 2) + A(2, i) * B(2, i) ! enddo ! end subroutine DGEMM !| SGEMM for M=N=2. <br> !  N and M are provided for compatibility with BLAS and are not used here. <br> !  @warning !    This is not a full-featured routine for GEMM. <br> !    Do not use this routine for anything other than calculating the covariance matrix. <br> !    Calculate only operations with  \\mathbf{C} = \\mathbf{A} \\mathbf{B}&#94;\\top . !  @endwarning pure subroutine SGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) use , intrinsic :: ISO_FORTRAN_ENV , only : RK => REAL32 character ( 1 ), intent ( in ) :: TRANSA !! IF TRANSA(1)='T', transpose A. character ( 1 ), intent ( in ) :: TRANSB !! IF TRANSB(1)='T', transpose B. integer , intent ( in ) :: M !! matrix dimension, not used. integer , intent ( in ) :: N !! matrix dimension, not used. integer , intent ( in ) :: K !! matrix dimension, not used. real ( RK ), intent ( in ) :: ALPHA !! A coefficient, not used. integer , intent ( in ) :: LDA !! leading dimension of A, must be >1. real ( RK ), intent ( in ) :: A ( LDA , * ) !! matrix A. integer , intent ( in ) :: LDB !! leading dimension of B, must be >1. real ( RK ), intent ( in ) :: B ( LDB , * ) !! matrix B. real ( RK ), intent ( in ) :: BETA !! A coefficient, not used. integer , intent ( in ) :: LDC !! leading dimension of C, must be >1. real ( RK ), intent ( inout ) :: C ( LDC , * ) !! matrix C. integer :: i ! C ( 1 , 1 ) = 0.0_RK C ( 2 , 1 ) = 0.0_RK C ( 1 , 2 ) = 0.0_RK C ( 2 , 2 ) = 0.0_RK ! do i = 4 , K , 4 C ( 1 , 1 ) = C ( 1 , 1 ) + A ( 1 , i - 3 ) * B ( 1 , i - 3 ) + A ( 1 , i - 2 ) * B ( 1 , i - 2 ) & & + A ( 1 , i - 1 ) * B ( 1 , i - 1 ) + A ( 1 , i - 0 ) * B ( 1 , i - 0 ) C ( 2 , 1 ) = C ( 2 , 1 ) + A ( 2 , i - 3 ) * B ( 1 , i - 3 ) + A ( 2 , i - 2 ) * B ( 1 , i - 2 ) & & + A ( 2 , i - 1 ) * B ( 1 , i - 1 ) + A ( 2 , i - 0 ) * B ( 1 , i - 0 ) C ( 1 , 2 ) = C ( 1 , 2 ) + A ( 1 , i - 3 ) * B ( 2 , i - 3 ) + A ( 1 , i - 2 ) * B ( 2 , i - 2 ) & & + A ( 1 , i - 1 ) * B ( 2 , i - 1 ) + A ( 1 , i - 0 ) * B ( 2 , i - 0 ) C ( 2 , 2 ) = C ( 2 , 2 ) + A ( 2 , i - 3 ) * B ( 2 , i - 3 ) + A ( 2 , i - 2 ) * B ( 2 , i - 2 ) & & + A ( 2 , i - 1 ) * B ( 2 , i - 1 ) + A ( 2 , i - 0 ) * B ( 2 , i - 0 ) end do ! select case ( MODULO ( K , 4 )) case ( 1 ) C ( 1 , 1 ) = C ( 1 , 1 ) + A ( 1 , K ) * B ( 1 , K ) C ( 2 , 1 ) = C ( 2 , 1 ) + A ( 2 , K ) * B ( 1 , K ) C ( 1 , 2 ) = C ( 1 , 2 ) + A ( 1 , K ) * B ( 2 , K ) C ( 2 , 2 ) = C ( 2 , 2 ) + A ( 2 , K ) * B ( 2 , K ) case ( 2 ) C ( 1 , 1 ) = C ( 1 , 1 ) + A ( 1 , K - 1 ) * B ( 1 , K - 1 ) + A ( 1 , K ) * B ( 1 , K ) C ( 2 , 1 ) = C ( 2 , 1 ) + A ( 2 , K - 1 ) * B ( 1 , K - 1 ) + A ( 2 , K ) * B ( 1 , K ) C ( 1 , 2 ) = C ( 1 , 2 ) + A ( 1 , K - 1 ) * B ( 2 , K - 1 ) + A ( 1 , K ) * B ( 2 , K ) C ( 2 , 2 ) = C ( 2 , 2 ) + A ( 2 , K - 1 ) * B ( 2 , K - 1 ) + A ( 2 , K ) * B ( 2 , K ) case ( 3 ) C ( 1 , 1 ) = C ( 1 , 1 ) + A ( 1 , K - 2 ) * B ( 1 , K - 2 ) + A ( 1 , K - 1 ) * B ( 1 , K - 1 ) + A ( 1 , K ) * B ( 1 , K ) C ( 2 , 1 ) = C ( 2 , 1 ) + A ( 2 , K - 2 ) * B ( 1 , K - 2 ) + A ( 2 , K - 1 ) * B ( 1 , K - 1 ) + A ( 2 , K ) * B ( 1 , K ) C ( 1 , 2 ) = C ( 1 , 2 ) + A ( 1 , K - 2 ) * B ( 2 , K - 2 ) + A ( 1 , K - 1 ) * B ( 2 , K - 1 ) + A ( 1 , K ) * B ( 2 , K ) C ( 2 , 2 ) = C ( 2 , 2 ) + A ( 2 , K - 2 ) * B ( 2 , K - 2 ) + A ( 2 , K - 1 ) * B ( 2 , K - 1 ) + A ( 2 , K ) * B ( 2 , K ) end select ! end subroutine SGEMM","tags":"","loc":"sourcefile/mod_dimspec_functions.f90.html"},{"title":"mod_rotation.f90 – mobbrmsd","text":"Contents Modules mod_rotation Source Code mod_rotation.f90 Source Code !| Calculate the rotation matrix that minimizes |X-RY|&#94;2 for D=2. <br> !  Here, RR&#94;T=I and det(R)=1 are satisfied. <br> !  This code is based on the method of Theobald. !  doi : [10.1107/S0108767305015266](https://scripts.iucr.org/cgi-bin/paper?S0108767305015266) module mod_rotation use mod_kinds , only : IK , RK implicit none private public :: sdmin_worksize public :: estimate_rcmax public :: estimate_sdmin public :: rotation_worksize public :: estimate_rotation ! real ( RK ), parameter :: ZERO = 0.0_RK real ( RK ), parameter :: HALF = 0.5_RK real ( RK ), parameter :: ONE = 1.0_RK real ( RK ), parameter :: THRESHOLD = 1E-14_RK ! contains ! !| Inquire function for memory size of estimate_sdmin. pure elemental function sdmin_worksize () result ( res ) integer ( IK ) :: res res = 2 end function sdmin_worksize ! !| Compute \\min_{R}\\text{tr}[\\mathbf{R}\\mathbf{C}]. pure subroutine estimate_rcmax ( g , cov , w ) real ( RK ), intent ( in ) :: g !! sum of auto covariance matrix real ( RK ), intent ( in ) :: cov ( * ) !! target d*n array real ( RK ), intent ( inout ) :: w ( * ) !! work array, must be larger than worksize_sdmin(). ! if ( g < THRESHOLD ) then w ( 1 ) = ZERO else w ( 1 ) = cov ( 1 ) + cov ( 4 ) w ( 1 ) = w ( 1 ) * w ( 1 ) w ( 2 ) = cov ( 2 ) - cov ( 3 ) w ( 2 ) = w ( 2 ) * w ( 2 ) w ( 1 ) = SQRT ( w ( 1 ) + w ( 2 )) end if ! end subroutine estimate_rcmax ! !| Compute the least-squares sum_i&#94;n |x_i-Ry_i|&#94;2 from cov = YX&#94;T and g = tr[XX&#94;T] + tr[YY&#94;T]. pure subroutine estimate_sdmin ( g , cov , w ) real ( RK ), intent ( in ) :: g !! sum of auto covariance matrix real ( RK ), intent ( in ) :: cov ( * ) !! target d*d array real ( RK ), intent ( inout ) :: w ( * ) !! work array, must be larger than worksize_sdmin(). ! if ( g < THRESHOLD ) then w ( 1 ) = ZERO else w ( 1 ) = cov ( 1 ) + cov ( 4 ) w ( 1 ) = w ( 1 ) * w ( 1 ) w ( 2 ) = cov ( 2 ) - cov ( 3 ) w ( 2 ) = w ( 2 ) * w ( 2 ) w ( 1 ) = SQRT ( w ( 1 ) + w ( 2 )) w ( 1 ) = w ( 1 ) + w ( 1 ) w ( 1 ) = g - w ( 1 ) end if ! end subroutine estimate_sdmin ! !| Inquire function for memory size of rotation. pure elemental function rotation_worksize () result ( res ) integer ( IK ) :: res res = 0 end function rotation_worksize ! !| Compute the transpose rotation matrix for minimize tr[CR] from cov = YX&#94;T and g = tr[XX&#94;T] + tr[YY&#94;T]. pure subroutine estimate_rotation ( g , cov , rot , w ) real ( RK ), intent ( in ) :: g !! g = tr[XX&#94;T] + tr[YY&#94;T] real ( RK ), intent ( in ) :: cov ( * ) !! covariance dxd matrix, YX&#94;T real ( RK ), intent ( inout ) :: rot ( * ) !! rotation dxd matrix real ( RK ), intent ( inout ) :: w ( * ) !! work array, must be larger than worksize_rotation(). ! if ( g < THRESHOLD ) then rot ( 1 ) = ONE ; rot ( 2 ) = ZERO rot ( 3 ) = ZERO ; rot ( 4 ) = ONE return end if ! rot ( 1 ) = cov ( 1 ) + cov ( 4 ) rot ( 2 ) = cov ( 3 ) - cov ( 2 ) rot ( 3 ) = rot ( 1 ) * rot ( 1 ) + rot ( 2 ) * rot ( 2 ) ! if ( rot ( 3 ) < THRESHOLD ) then rot ( 1 ) = ONE ; rot ( 2 ) = ZERO rot ( 3 ) = ZERO ; rot ( 4 ) = ONE return end if ! rot ( 3 ) = SQRT ( ONE / rot ( 3 )) rot ( 1 ) = rot ( 1 ) * rot ( 3 ) ! cos theta rot ( 3 ) = HALF + HALF * rot ( 1 ) ! cos&#94;2 theta/2 rot ( 4 ) = rot ( 3 ) - ONE ! - sin&#94;2 theta/2 rot ( 1 ) = rot ( 4 ) + rot ( 3 ) ! cos&#94;2 theta/2 - sin&#94;2 theta/2 rot ( 4 ) = rot ( 4 ) * rot ( 3 ) ! cos&#94;2 theta/2 * sin&#94;2 theta/2 rot ( 4 ) = rot ( 4 ) + rot ( 4 ) ! 2 * cos&#94;2 theta/2 * sin&#94;2 theta/2 rot ( 4 ) = rot ( 4 ) + rot ( 4 ) ! 4 * cos&#94;2 theta/2 * sin&#94;2 theta/2 rot ( 2 ) = rot ( 4 ) * rot ( 2 ) rot ( 2 ) = SIGN ( ONE , rot ( 2 )) * SQRT ( ABS ( rot ( 4 ))) rot ( 3 ) = - rot ( 2 ) rot ( 4 ) = rot ( 1 ) ! end subroutine estimate_rotation ! end module mod_rotation","tags":"","loc":"sourcefile/mod_rotation.f90.html"},{"title":"mod_dimspec_functions.f90 – mobbrmsd","text":"Contents Modules mod_dimspec_functions Subroutines DGEMM SGEMM Source Code mod_dimspec_functions.f90 Source Code !| Define spatial dimension, D=3, !  and provide an optimized blas/lapack interface. module mod_dimspec_functions use mod_kinds , only : RK , IK implicit none private public :: D , DD , ND public :: setup_dimension public :: compute_com public :: compute_cov public :: covcopy ! !| Spatial dimension. integer ( IK ), parameter :: D = 3 !| Square spatial dimension. integer ( IK ), parameter :: DD = 9 !| Node memory size, defined by 1 + 1 + D&#94;2. !  Let [L, G, \\mathbf{C}] be a node, !  where L, G\\in\\mathbb{R} and \\mathbf{C}\\in\\mathbb{R}&#94;{D\\times D}. integer ( IK ), parameter :: ND = DD + 2 ! real ( RK ), parameter :: ZERO = 0.0_RK real ( RK ), parameter :: HALF = 0.5_RK real ( RK ), parameter :: ONETHIRD = 1.0_RK / 3.0_RK real ( RK ), parameter :: ONE = 1.0_RK ! interface include 'dgemm.h' include 'sgemm.h' end interface ! contains !| Sets the dimensions of the space. <br> !  Caution, this routine affects global. subroutine setup_dimension ( d_ ) integer ( IK ), intent ( in ) :: d_ end subroutine setup_dimension ! !| Calculate center of mass for D=3 pure subroutine compute_com ( d , n , X , C ) integer ( IK ), intent ( in ) :: d , n real ( RK ), intent ( in ) :: X ( d , * ) real ( RK ), intent ( inout ) :: C ( d ) real ( RK ) :: rn integer ( IK ) :: i if ( n < 0 ) then C ( 1 ) = ZERO C ( 2 ) = ZERO C ( 3 ) = ZERO return elseif ( n == 1 ) then C ( 1 ) = X ( 1 , 1 ) C ( 2 ) = X ( 2 , 1 ) C ( 3 ) = X ( 3 , 1 ) return elseif ( n == 2 ) then C ( 1 ) = ( X ( 1 , 1 ) + X ( 1 , 2 )) * HALF C ( 2 ) = ( X ( 2 , 1 ) + X ( 2 , 2 )) * HALF C ( 3 ) = ( X ( 3 , 1 ) + X ( 3 , 2 )) * HALF return elseif ( n == 3 ) then C ( 1 ) = ( X ( 1 , 1 ) + X ( 1 , 2 ) + X ( 1 , 3 )) * ONETHIRD C ( 2 ) = ( X ( 2 , 1 ) + X ( 2 , 2 ) + X ( 2 , 3 )) * ONETHIRD C ( 3 ) = ( X ( 3 , 1 ) + X ( 3 , 2 ) + X ( 3 , 3 )) * ONETHIRD return end if C ( 1 ) = ZERO C ( 2 ) = ZERO C ( 3 ) = ZERO do i = 2 , n , 2 C ( 1 ) = C ( 1 ) + X ( 1 , i - 1 ) C ( 2 ) = C ( 2 ) + X ( 2 , i - 1 ) C ( 3 ) = C ( 3 ) + X ( 3 , i - 1 ) C ( 1 ) = C ( 1 ) + X ( 1 , i - 0 ) C ( 2 ) = C ( 2 ) + X ( 2 , i - 0 ) C ( 3 ) = C ( 3 ) + X ( 3 , i - 0 ) end do if ( MODULO ( n , 2 ) == 1 ) then C ( 1 ) = C ( 1 ) + X ( 1 , n ) C ( 2 ) = C ( 2 ) + X ( 2 , n ) C ( 3 ) = C ( 3 ) + X ( 3 , n ) end if !   do i = 4, n, 4 !     C(1) = C(1) + X(1, i - 3) + X(1, i - 2) + X(1, i - 1) + X(1, i - 0) !     C(2) = C(2) + X(2, i - 3) + X(2, i - 2) + X(2, i - 1) + X(2, i - 0) !     C(3) = C(3) + X(3, i - 3) + X(3, i - 2) + X(3, i - 1) + X(3, i - 0) !   end do !   do i = 4, n, 4 !     C(1) = C(1) + X(1, i - 3) !     C(2) = C(2) + X(2, i - 3) !     C(3) = C(3) + X(3, i - 3) !     C(1) = C(1) + X(1, i - 2) !     C(2) = C(2) + X(2, i - 2) !     C(3) = C(3) + X(3, i - 2) !     C(1) = C(1) + X(1, i - 1) !     C(2) = C(2) + X(2, i - 1) !     C(3) = C(3) + X(3, i - 1) !     C(1) = C(1) + X(1, i - 0) !     C(2) = C(2) + X(2, i - 0) !     C(3) = C(3) + X(3, i - 0) !   end do !   if (MODULO(n, 4) == 1) then !     C(1) = C(1) + X(1, n) !     C(2) = C(2) + X(2, n) !     C(3) = C(3) + X(3, n) !   elseif (MODULO(n, 4) == 2) then !     C(1) = C(1) + X(1, n - 1) + X(1, n) !     C(2) = C(2) + X(2, n - 1) + X(2, n) !     C(3) = C(3) + X(3, n - 1) + X(3, n) !   elseif (MODULO(n, 4) == 3) then !     C(1) = C(1) + X(1, n - 2) + X(1, n - 1) + X(1, n) !     C(2) = C(2) + X(2, n - 2) + X(2, n - 1) + X(2, n) !     C(3) = C(3) + X(3, n - 2) + X(3, n - 1) + X(3, n) !   end if !   do i = 8, n, 8 !     C(1) = C(1) + X(1, i - 7) !     C(2) = C(2) + X(2, i - 7) !     C(3) = C(3) + X(3, i - 7) !     C(1) = C(1) + X(1, i - 6) !     C(2) = C(2) + X(2, i - 6) !     C(3) = C(3) + X(3, i - 6) !     C(1) = C(1) + X(1, i - 5) !     C(2) = C(2) + X(2, i - 5) !     C(3) = C(3) + X(3, i - 5) !     C(1) = C(1) + X(1, i - 4) !     C(2) = C(2) + X(2, i - 4) !     C(3) = C(3) + X(3, i - 4) !     C(1) = C(1) + X(1, i - 3) !     C(2) = C(2) + X(2, i - 3) !     C(3) = C(3) + X(3, i - 3) !     C(1) = C(1) + X(1, i - 2) !     C(2) = C(2) + X(2, i - 2) !     C(3) = C(3) + X(3, i - 2) !     C(1) = C(1) + X(1, i - 1) !     C(2) = C(2) + X(2, i - 1) !     C(3) = C(3) + X(3, i - 1) !     C(1) = C(1) + X(1, i - 0) !     C(2) = C(2) + X(2, i - 0) !     C(3) = C(3) + X(3, i - 0) !   end do !   if (MODULO(n, 8) == 1) then !     C(1) = C(1) + X(1, n) !     C(2) = C(2) + X(2, n) !     C(3) = C(3) + X(3, n) !   elseif (MODULO(n, 8) == 2) then !     C(1) = C(1) + X(1, n - 1) + X(1, n) !     C(2) = C(2) + X(2, n - 1) + X(2, n) !     C(3) = C(3) + X(3, n - 1) + X(3, n) !   elseif (MODULO(n, 8) == 3) then !     C(1) = C(1) + X(1, n - 2) + X(1, n - 1) + X(1, n) !     C(2) = C(2) + X(2, n - 2) + X(2, n - 1) + X(2, n) !     C(3) = C(3) + X(3, n - 2) + X(3, n - 1) + X(3, n) !   elseif (MODULO(n, 8) == 4) then !     C(1) = C(1) + X(1, n - 3) + X(1, n - 2) + X(1, n - 1) + X(1, n) !     C(2) = C(2) + X(2, n - 3) + X(2, n - 2) + X(2, n - 1) + X(2, n) !     C(3) = C(3) + X(3, n - 3) + X(3, n - 2) + X(3, n - 1) + X(3, n) !   elseif (MODULO(n, 8) == 5) then !     C(1) = C(1) + X(1, n - 4) + X(1, n - 3) + X(1, n - 2) + X(1, n - 1) + X(1, n) !     C(2) = C(2) + X(2, n - 4) + X(2, n - 3) + X(2, n - 2) + X(2, n - 1) + X(2, n) !     C(3) = C(3) + X(3, n - 4) + X(3, n - 3) + X(3, n - 2) + X(3, n - 1) + X(3, n) !   elseif (MODULO(n, 8) == 6) then !     C(1) = C(1) + X(1, n - 5) + X(1, n - 4) + X(1, n - 3) + X(1, n - 2) + X(1, n - 1) + X(1, n) !     C(2) = C(2) + X(2, n - 5) + X(2, n - 4) + X(2, n - 3) + X(2, n - 2) + X(2, n - 1) + X(2, n) !     C(3) = C(3) + X(3, n - 5) + X(3, n - 4) + X(3, n - 3) + X(3, n - 2) + X(3, n - 1) + X(3, n) !   elseif (MODULO(n, 8) == 7) then !     C(1) = C(1) + X(1, n - 6) + X(1, n - 5) + X(1, n - 4) + X(1, n - 3) + X(1, n - 2) + X(1, n - 1) + X(1, n) !     C(2) = C(2) + X(2, n - 6) + X(2, n - 5) + X(2, n - 4) + X(2, n - 3) + X(2, n - 2) + X(2, n - 1) + X(2, n) !     C(3) = C(3) + X(3, n - 6) + X(3, n - 5) + X(3, n - 4) + X(3, n - 3) + X(3, n - 2) + X(3, n - 1) + X(3, n) !   end if rn = ONE / real ( n , RK ) C ( 1 ) = C ( 1 ) * rn C ( 2 ) = C ( 2 ) * rn C ( 3 ) = C ( 3 ) * rn end subroutine compute_com ! !| Calculate covariance matrix. pure subroutine compute_cov ( d , n , X , Y , C ) integer ( IK ), intent ( in ) :: d , n real ( RK ), intent ( in ) :: X ( d , * ), Y ( d , * ) real ( RK ), intent ( inout ) :: C ( d , d ) #ifdef REAL32 call SGEMM ( 'N' , 'T' , d , d , n , ONE , Y , d , X , d , ZERO , C , D ) #else call DGEMM ( 'N' , 'T' , d , d , n , ONE , Y , d , X , d , ZERO , C , D ) #endif end subroutine compute_cov ! !| Compute \\mathbf{Y} \\gets \\mathbf{X}-\\bar{\\mathbf{X}}  !  for D=3 pure subroutine covcopy ( d , n , X , CX , Y ) integer ( IK ), intent ( in ) :: d , n real ( RK ), intent ( in ) :: X ( d , * ), CX ( d ) real ( RK ), intent ( inout ) :: Y ( d , * ) integer ( IK ) :: i do concurrent ( i = 1 : n ) Y ( 1 , i ) = X ( 1 , i ) - CX ( 1 ) Y ( 2 , i ) = X ( 2 , i ) - CX ( 2 ) Y ( 3 , i ) = X ( 3 , i ) - CX ( 3 ) end do end subroutine covcopy ! end module mod_dimspec_functions ! !| DGEMM for M=N=3. <br> !  N and M are provided for compatibility with BLAS and are not used here. <br> !  @warning !    This is not a full-featured routine for GEMM. <br> !    Do not use this routine for anything other than calculating the covariance matrix. <br> !    Calculate only operations with  \\mathbf{C} = \\mathbf{A} \\mathbf{B}&#94;\\top . !  @endwarning pure subroutine DGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) use , intrinsic :: ISO_FORTRAN_ENV , only : RK => REAL64 character ( 1 ), intent ( in ) :: TRANSA !! IF TRANSA(1)='T', transpose A. character ( 1 ), intent ( in ) :: TRANSB !! IF TRANSB(1)='T', transpose B. integer , intent ( in ) :: M !! matrix dimension, not used. integer , intent ( in ) :: N !! matrix dimension, not used. integer , intent ( in ) :: K !! matrix dimension, not used. real ( RK ), intent ( in ) :: ALPHA !! A coefficient, not used. integer , intent ( in ) :: LDA !! leading dimension of A, must be >1. real ( RK ), intent ( in ) :: A ( LDA , * ) !! matrix A. integer , intent ( in ) :: LDB !! leading dimension of B, must be >1. real ( RK ), intent ( in ) :: B ( LDB , * ) !! matrix B. real ( RK ), intent ( in ) :: BETA !! A coefficient, not used. integer , intent ( in ) :: LDC !! leading dimension of C, must be >1. real ( RK ), intent ( inout ) :: C ( LDC , * ) !! matrix C. integer :: i C ( 1 , 1 ) = 0.0_RK C ( 2 , 1 ) = 0.0_RK C ( 3 , 1 ) = 0.0_RK C ( 1 , 2 ) = 0.0_RK C ( 2 , 2 ) = 0.0_RK C ( 3 , 2 ) = 0.0_RK C ( 1 , 3 ) = 0.0_RK C ( 2 , 3 ) = 0.0_RK C ( 3 , 3 ) = 0.0_RK ! do i = 4 , K , 4 C ( 1 , 1 ) = C ( 1 , 1 ) + A ( 1 , i - 3 ) * B ( 1 , i - 3 ) & & + A ( 1 , i - 2 ) * B ( 1 , i - 2 ) & & + A ( 1 , i - 1 ) * B ( 1 , i - 1 ) & & + A ( 1 , i - 0 ) * B ( 1 , i - 0 ) C ( 2 , 1 ) = C ( 2 , 1 ) + A ( 2 , i - 3 ) * B ( 1 , i - 3 ) & & + A ( 2 , i - 2 ) * B ( 1 , i - 2 ) & & + A ( 2 , i - 1 ) * B ( 1 , i - 1 ) & & + A ( 2 , i - 0 ) * B ( 1 , i - 0 ) C ( 3 , 1 ) = C ( 3 , 1 ) + A ( 3 , i - 3 ) * B ( 1 , i - 3 ) & & + A ( 3 , i - 2 ) * B ( 1 , i - 2 ) & & + A ( 3 , i - 1 ) * B ( 1 , i - 1 ) & & + A ( 3 , i - 0 ) * B ( 1 , i - 0 ) C ( 1 , 2 ) = C ( 1 , 2 ) + A ( 1 , i - 3 ) * B ( 2 , i - 3 ) & & + A ( 1 , i - 2 ) * B ( 2 , i - 2 ) & & + A ( 1 , i - 1 ) * B ( 2 , i - 1 ) & & + A ( 1 , i - 0 ) * B ( 2 , i - 0 ) C ( 2 , 2 ) = C ( 2 , 2 ) + A ( 2 , i - 3 ) * B ( 2 , i - 3 ) & & + A ( 2 , i - 2 ) * B ( 2 , i - 2 ) & & + A ( 2 , i - 1 ) * B ( 2 , i - 1 ) & & + A ( 2 , i - 0 ) * B ( 2 , i - 0 ) C ( 3 , 2 ) = C ( 3 , 2 ) + A ( 3 , i - 3 ) * B ( 2 , i - 3 ) & & + A ( 3 , i - 2 ) * B ( 2 , i - 2 ) & & + A ( 3 , i - 1 ) * B ( 2 , i - 1 ) & & + A ( 3 , i - 0 ) * B ( 2 , i - 0 ) C ( 1 , 3 ) = C ( 1 , 3 ) + A ( 1 , i - 3 ) * B ( 3 , i - 3 ) & & + A ( 1 , i - 2 ) * B ( 3 , i - 2 ) & & + A ( 1 , i - 1 ) * B ( 3 , i - 1 ) & & + A ( 1 , i - 0 ) * B ( 3 , i - 0 ) C ( 2 , 3 ) = C ( 2 , 3 ) + A ( 2 , i - 3 ) * B ( 3 , i - 3 ) & & + A ( 2 , i - 2 ) * B ( 3 , i - 2 ) & & + A ( 2 , i - 1 ) * B ( 3 , i - 1 ) & & + A ( 2 , i - 0 ) * B ( 3 , i - 0 ) C ( 3 , 3 ) = C ( 3 , 3 ) + A ( 3 , i - 3 ) * B ( 3 , i - 3 ) & & + A ( 3 , i - 2 ) * B ( 3 , i - 2 ) & & + A ( 3 , i - 1 ) * B ( 3 , i - 1 ) & & + A ( 3 , i - 0 ) * B ( 3 , i - 0 ) end do ! select case ( MODULO ( K , 4 )) case ( 1 ) C ( 1 , 1 ) = C ( 1 , 1 ) + A ( 1 , K ) * B ( 1 , K ) C ( 2 , 1 ) = C ( 2 , 1 ) + A ( 2 , K ) * B ( 1 , K ) C ( 3 , 1 ) = C ( 3 , 1 ) + A ( 3 , K ) * B ( 1 , K ) C ( 1 , 2 ) = C ( 1 , 2 ) + A ( 1 , K ) * B ( 2 , K ) C ( 2 , 2 ) = C ( 2 , 2 ) + A ( 2 , K ) * B ( 2 , K ) C ( 3 , 2 ) = C ( 3 , 2 ) + A ( 3 , K ) * B ( 2 , K ) C ( 1 , 3 ) = C ( 1 , 3 ) + A ( 1 , K ) * B ( 3 , K ) C ( 2 , 3 ) = C ( 2 , 3 ) + A ( 2 , K ) * B ( 3 , K ) C ( 3 , 3 ) = C ( 3 , 3 ) + A ( 3 , K ) * B ( 3 , K ) case ( 2 ) C ( 1 , 1 ) = C ( 1 , 1 ) + A ( 1 , K - 1 ) * B ( 1 , K - 1 ) & & + A ( 1 , K - 0 ) * B ( 1 , K - 0 ) C ( 2 , 1 ) = C ( 2 , 1 ) + A ( 2 , K - 1 ) * B ( 1 , K - 1 ) & & + A ( 2 , K - 0 ) * B ( 1 , K - 0 ) C ( 3 , 1 ) = C ( 3 , 1 ) + A ( 3 , K - 1 ) * B ( 1 , K - 1 ) & & + A ( 3 , K - 0 ) * B ( 1 , K - 0 ) C ( 1 , 2 ) = C ( 1 , 2 ) + A ( 1 , K - 1 ) * B ( 2 , K - 1 ) & & + A ( 1 , K - 0 ) * B ( 2 , K - 0 ) C ( 2 , 2 ) = C ( 2 , 2 ) + A ( 2 , K - 1 ) * B ( 2 , K - 1 ) & & + A ( 2 , K - 0 ) * B ( 2 , K - 0 ) C ( 3 , 2 ) = C ( 3 , 2 ) + A ( 3 , K - 1 ) * B ( 2 , K - 1 ) & & + A ( 3 , K - 0 ) * B ( 2 , K - 0 ) C ( 1 , 3 ) = C ( 1 , 3 ) + A ( 1 , K - 1 ) * B ( 3 , K - 1 ) & & + A ( 1 , K - 0 ) * B ( 3 , K - 0 ) C ( 2 , 3 ) = C ( 2 , 3 ) + A ( 2 , K - 1 ) * B ( 3 , K - 1 ) & & + A ( 2 , K - 0 ) * B ( 3 , K - 0 ) C ( 3 , 3 ) = C ( 3 , 3 ) + A ( 3 , K - 1 ) * B ( 3 , K - 1 ) & & + A ( 3 , K - 0 ) * B ( 3 , K - 0 ) case ( 3 ) C ( 1 , 1 ) = C ( 1 , 1 ) + A ( 1 , K - 2 ) * B ( 1 , K - 2 ) & & + A ( 1 , K - 1 ) * B ( 1 , K - 1 ) & & + A ( 1 , K - 0 ) * B ( 1 , K - 0 ) C ( 2 , 1 ) = C ( 2 , 1 ) + A ( 2 , K - 2 ) * B ( 1 , K - 2 ) & & + A ( 2 , K - 1 ) * B ( 1 , K - 1 ) & & + A ( 2 , K - 0 ) * B ( 1 , K - 0 ) C ( 3 , 1 ) = C ( 3 , 1 ) + A ( 3 , K - 2 ) * B ( 1 , K - 2 ) & & + A ( 3 , K - 1 ) * B ( 1 , K - 1 ) & & + A ( 3 , K - 0 ) * B ( 1 , K - 0 ) C ( 1 , 2 ) = C ( 1 , 2 ) + A ( 1 , K - 2 ) * B ( 2 , K - 2 ) & & + A ( 1 , K - 1 ) * B ( 2 , K - 1 ) & & + A ( 1 , K - 0 ) * B ( 2 , K - 0 ) C ( 2 , 2 ) = C ( 2 , 2 ) + A ( 2 , K - 2 ) * B ( 2 , K - 2 ) & & + A ( 2 , K - 1 ) * B ( 2 , K - 1 ) & & + A ( 2 , K - 0 ) * B ( 2 , K - 0 ) C ( 3 , 2 ) = C ( 3 , 2 ) + A ( 3 , K - 2 ) * B ( 2 , K - 2 ) & & + A ( 3 , K - 1 ) * B ( 2 , K - 1 ) & & + A ( 3 , K - 0 ) * B ( 2 , K - 0 ) C ( 1 , 3 ) = C ( 1 , 3 ) + A ( 1 , K - 2 ) * B ( 3 , K - 2 ) & & + A ( 1 , K - 1 ) * B ( 3 , K - 1 ) & & + A ( 1 , K - 0 ) * B ( 3 , K - 0 ) C ( 2 , 3 ) = C ( 2 , 3 ) + A ( 2 , K - 2 ) * B ( 3 , K - 2 ) & & + A ( 2 , K - 1 ) * B ( 3 , K - 1 ) & & + A ( 2 , K - 0 ) * B ( 3 , K - 0 ) C ( 3 , 3 ) = C ( 3 , 3 ) + A ( 3 , K - 2 ) * B ( 3 , K - 2 ) & & + A ( 3 , K - 1 ) * B ( 3 , K - 1 ) & & + A ( 3 , K - 0 ) * B ( 3 , K - 0 ) end select ! ! if (MODULO(K, 2) == 1) then !   C(1, 1) = C(1, 1) + A(1, K) * B(1, K) !   C(2, 1) = C(2, 1) + A(2, K) * B(1, K) !   C(3, 1) = C(3, 1) + A(3, K) * B(1, K) !   C(1, 2) = C(1, 2) + A(1, K) * B(2, K) !   C(2, 2) = C(2, 2) + A(2, K) * B(2, K) !   C(3, 2) = C(3, 2) + A(3, K) * B(2, K) !   C(1, 3) = C(1, 3) + A(1, K) * B(3, K) !   C(2, 3) = C(2, 3) + A(2, K) * B(3, K) !   C(3, 3) = C(3, 3) + A(3, K) * B(3, K) ! end if ! ! do i = 2, K, 2 !   C(1, 1) = C(1, 1) + A(1, i - 1) * B(1, i - 1) + A(1, i) * B(1, i) !   C(2, 1) = C(2, 1) + A(2, i - 1) * B(1, i - 1) + A(2, i) * B(1, i) !   C(3, 1) = C(3, 1) + A(3, i - 1) * B(1, i - 1) + A(3, i) * B(1, i) !   C(1, 2) = C(1, 2) + A(1, i - 1) * B(2, i - 1) + A(1, i) * B(2, i) !   C(2, 2) = C(2, 2) + A(2, i - 1) * B(2, i - 1) + A(2, i) * B(2, i) !   C(3, 2) = C(3, 2) + A(3, i - 1) * B(2, i - 1) + A(3, i) * B(2, i) !   C(1, 3) = C(1, 3) + A(1, i - 1) * B(3, i - 1) + A(1, i) * B(3, i) !   C(2, 3) = C(2, 3) + A(2, i - 1) * B(3, i - 1) + A(2, i) * B(3, i) !   C(3, 3) = C(3, 3) + A(3, i - 1) * B(3, i - 1) + A(3, i) * B(3, i) ! end do ! ! if (MODULO(K, 2) == 1) then !   C(1, 1) = C(1, 1) + A(1, K) * B(1, K) !   C(2, 1) = C(2, 1) + A(2, K) * B(1, K) !   C(3, 1) = C(3, 1) + A(3, K) * B(1, K) !   C(1, 2) = C(1, 2) + A(1, K) * B(2, K) !   C(2, 2) = C(2, 2) + A(2, K) * B(2, K) !   C(3, 2) = C(3, 2) + A(3, K) * B(2, K) !   C(1, 3) = C(1, 3) + A(1, K) * B(3, K) !   C(2, 3) = C(2, 3) + A(2, K) * B(3, K) !   C(3, 3) = C(3, 3) + A(3, K) * B(3, K) ! end if ! ! ! do i = 1, K !   C(1, 1) = C(1, 1) + A(1, i) * B(1, i) !   C(2, 1) = C(2, 1) + A(2, i) * B(1, i) !   C(3, 1) = C(3, 1) + A(3, i) * B(1, i) !   C(1, 2) = C(1, 2) + A(1, i) * B(2, i) !   C(2, 2) = C(2, 2) + A(2, i) * B(2, i) !   C(3, 2) = C(3, 2) + A(3, i) * B(2, i) !   C(1, 3) = C(1, 3) + A(1, i) * B(3, i) !   C(2, 3) = C(2, 3) + A(2, i) * B(3, i) !   C(3, 3) = C(3, 3) + A(3, i) * B(3, i) ! end do ! end subroutine DGEMM !| SGEMM for M=N=3. <br> !  N and M are provided for compatibility with BLAS and are not used here. <br> !  @warning !    This is not a full-featured routine for GEMM. <br> !    Do not use this routine for anything other than calculating the covariance matrix. <br> !    Calculate only operations with  \\mathbf{C} = \\mathbf{A} \\mathbf{B}&#94;\\top . pure subroutine SGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) use , intrinsic :: ISO_FORTRAN_ENV , only : RK => REAL32 character ( 1 ), intent ( in ) :: TRANSA !! IF TRANSA(1)='T', transpose A. character ( 1 ), intent ( in ) :: TRANSB !! IF TRANSB(1)='T', transpose B. integer , intent ( in ) :: M !! matrix dimension, not used. integer , intent ( in ) :: N !! matrix dimension, not used. integer , intent ( in ) :: K !! matrix dimension, not used. real ( RK ), intent ( in ) :: ALPHA !! A coefficient, not used. integer , intent ( in ) :: LDA !! leading dimension of A, must be >1. real ( RK ), intent ( in ) :: A ( LDA , * ) !! matrix A. integer , intent ( in ) :: LDB !! leading dimension of B, must be >1. real ( RK ), intent ( in ) :: B ( LDB , * ) !! matrix B. real ( RK ), intent ( in ) :: BETA !! A coefficient, not used. integer , intent ( in ) :: LDC !! leading dimension of C, must be >1. real ( RK ), intent ( inout ) :: C ( LDC , * ) !! matrix C. integer :: i ! C ( 1 , 1 ) = 0.0_RK C ( 2 , 1 ) = 0.0_RK C ( 3 , 1 ) = 0.0_RK C ( 1 , 2 ) = 0.0_RK C ( 2 , 2 ) = 0.0_RK C ( 3 , 2 ) = 0.0_RK C ( 1 , 3 ) = 0.0_RK C ( 2 , 3 ) = 0.0_RK C ( 3 , 3 ) = 0.0_RK ! do i = 4 , K , 4 C ( 1 , 1 ) = C ( 1 , 1 ) + A ( 1 , i - 3 ) * B ( 1 , i - 3 ) & & + A ( 1 , i - 2 ) * B ( 1 , i - 2 ) & & + A ( 1 , i - 1 ) * B ( 1 , i - 1 ) & & + A ( 1 , i - 0 ) * B ( 1 , i - 0 ) C ( 2 , 1 ) = C ( 2 , 1 ) + A ( 2 , i - 3 ) * B ( 1 , i - 3 ) & & + A ( 2 , i - 2 ) * B ( 1 , i - 2 ) & & + A ( 2 , i - 1 ) * B ( 1 , i - 1 ) & & + A ( 2 , i - 0 ) * B ( 1 , i - 0 ) C ( 3 , 1 ) = C ( 3 , 1 ) + A ( 3 , i - 3 ) * B ( 1 , i - 3 ) & & + A ( 3 , i - 2 ) * B ( 1 , i - 2 ) & & + A ( 3 , i - 1 ) * B ( 1 , i - 1 ) & & + A ( 3 , i - 0 ) * B ( 1 , i - 0 ) C ( 1 , 2 ) = C ( 1 , 2 ) + A ( 1 , i - 3 ) * B ( 2 , i - 3 ) & & + A ( 1 , i - 2 ) * B ( 2 , i - 2 ) & & + A ( 1 , i - 1 ) * B ( 2 , i - 1 ) & & + A ( 1 , i - 0 ) * B ( 2 , i - 0 ) C ( 2 , 2 ) = C ( 2 , 2 ) + A ( 2 , i - 3 ) * B ( 2 , i - 3 ) & & + A ( 2 , i - 2 ) * B ( 2 , i - 2 ) & & + A ( 2 , i - 1 ) * B ( 2 , i - 1 ) & & + A ( 2 , i - 0 ) * B ( 2 , i - 0 ) C ( 3 , 2 ) = C ( 3 , 2 ) + A ( 3 , i - 3 ) * B ( 2 , i - 3 ) & & + A ( 3 , i - 2 ) * B ( 2 , i - 2 ) & & + A ( 3 , i - 1 ) * B ( 2 , i - 1 ) & & + A ( 3 , i - 0 ) * B ( 2 , i - 0 ) C ( 1 , 3 ) = C ( 1 , 3 ) + A ( 1 , i - 3 ) * B ( 3 , i - 3 ) & & + A ( 1 , i - 2 ) * B ( 3 , i - 2 ) & & + A ( 1 , i - 1 ) * B ( 3 , i - 1 ) & & + A ( 1 , i - 0 ) * B ( 3 , i - 0 ) C ( 2 , 3 ) = C ( 2 , 3 ) + A ( 2 , i - 3 ) * B ( 3 , i - 3 ) & & + A ( 2 , i - 2 ) * B ( 3 , i - 2 ) & & + A ( 2 , i - 1 ) * B ( 3 , i - 1 ) & & + A ( 2 , i - 0 ) * B ( 3 , i - 0 ) C ( 3 , 3 ) = C ( 3 , 3 ) + A ( 3 , i - 3 ) * B ( 3 , i - 3 ) & & + A ( 3 , i - 2 ) * B ( 3 , i - 2 ) & & + A ( 3 , i - 1 ) * B ( 3 , i - 1 ) & & + A ( 3 , i - 0 ) * B ( 3 , i - 0 ) end do ! select case ( MODULO ( K , 4 )) case ( 1 ) C ( 1 , 1 ) = C ( 1 , 1 ) + A ( 1 , K ) * B ( 1 , K ) C ( 2 , 1 ) = C ( 2 , 1 ) + A ( 2 , K ) * B ( 1 , K ) C ( 3 , 1 ) = C ( 3 , 1 ) + A ( 3 , K ) * B ( 1 , K ) C ( 1 , 2 ) = C ( 1 , 2 ) + A ( 1 , K ) * B ( 2 , K ) C ( 2 , 2 ) = C ( 2 , 2 ) + A ( 2 , K ) * B ( 2 , K ) C ( 3 , 2 ) = C ( 3 , 2 ) + A ( 3 , K ) * B ( 2 , K ) C ( 1 , 3 ) = C ( 1 , 3 ) + A ( 1 , K ) * B ( 3 , K ) C ( 2 , 3 ) = C ( 2 , 3 ) + A ( 2 , K ) * B ( 3 , K ) C ( 3 , 3 ) = C ( 3 , 3 ) + A ( 3 , K ) * B ( 3 , K ) case ( 2 ) C ( 1 , 1 ) = C ( 1 , 1 ) + A ( 1 , K - 1 ) * B ( 1 , K - 1 ) & & + A ( 1 , K - 0 ) * B ( 1 , K - 0 ) C ( 2 , 1 ) = C ( 2 , 1 ) + A ( 2 , K - 1 ) * B ( 1 , K - 1 ) & & + A ( 2 , K - 0 ) * B ( 1 , K - 0 ) C ( 3 , 1 ) = C ( 3 , 1 ) + A ( 3 , K - 1 ) * B ( 1 , K - 1 ) & & + A ( 3 , K - 0 ) * B ( 1 , K - 0 ) C ( 1 , 2 ) = C ( 1 , 2 ) + A ( 1 , K - 1 ) * B ( 2 , K - 1 ) & & + A ( 1 , K - 0 ) * B ( 2 , K - 0 ) C ( 2 , 2 ) = C ( 2 , 2 ) + A ( 2 , K - 1 ) * B ( 2 , K - 1 ) & & + A ( 2 , K - 0 ) * B ( 2 , K - 0 ) C ( 3 , 2 ) = C ( 3 , 2 ) + A ( 3 , K - 1 ) * B ( 2 , K - 1 ) & & + A ( 3 , K - 0 ) * B ( 2 , K - 0 ) C ( 1 , 3 ) = C ( 1 , 3 ) + A ( 1 , K - 1 ) * B ( 3 , K - 1 ) & & + A ( 1 , K - 0 ) * B ( 3 , K - 0 ) C ( 2 , 3 ) = C ( 2 , 3 ) + A ( 2 , K - 1 ) * B ( 3 , K - 1 ) & & + A ( 2 , K - 0 ) * B ( 3 , K - 0 ) C ( 3 , 3 ) = C ( 3 , 3 ) + A ( 3 , K - 1 ) * B ( 3 , K - 1 ) & & + A ( 3 , K - 0 ) * B ( 3 , K - 0 ) case ( 3 ) C ( 1 , 1 ) = C ( 1 , 1 ) + A ( 1 , K - 2 ) * B ( 1 , K - 2 ) & & + A ( 1 , K - 1 ) * B ( 1 , K - 1 ) & & + A ( 1 , K - 0 ) * B ( 1 , K - 0 ) C ( 2 , 1 ) = C ( 2 , 1 ) + A ( 2 , K - 2 ) * B ( 1 , K - 2 ) & & + A ( 2 , K - 1 ) * B ( 1 , K - 1 ) & & + A ( 2 , K - 0 ) * B ( 1 , K - 0 ) C ( 3 , 1 ) = C ( 3 , 1 ) + A ( 3 , K - 2 ) * B ( 1 , K - 2 ) & & + A ( 3 , K - 1 ) * B ( 1 , K - 1 ) & & + A ( 3 , K - 0 ) * B ( 1 , K - 0 ) C ( 1 , 2 ) = C ( 1 , 2 ) + A ( 1 , K - 2 ) * B ( 2 , K - 2 ) & & + A ( 1 , K - 1 ) * B ( 2 , K - 1 ) & & + A ( 1 , K - 0 ) * B ( 2 , K - 0 ) C ( 2 , 2 ) = C ( 2 , 2 ) + A ( 2 , K - 2 ) * B ( 2 , K - 2 ) & & + A ( 2 , K - 1 ) * B ( 2 , K - 1 ) & & + A ( 2 , K - 0 ) * B ( 2 , K - 0 ) C ( 3 , 2 ) = C ( 3 , 2 ) + A ( 3 , K - 2 ) * B ( 2 , K - 2 ) & & + A ( 3 , K - 1 ) * B ( 2 , K - 1 ) & & + A ( 3 , K - 0 ) * B ( 2 , K - 0 ) C ( 1 , 3 ) = C ( 1 , 3 ) + A ( 1 , K - 2 ) * B ( 3 , K - 2 ) & & + A ( 1 , K - 1 ) * B ( 3 , K - 1 ) & & + A ( 1 , K - 0 ) * B ( 3 , K - 0 ) C ( 2 , 3 ) = C ( 2 , 3 ) + A ( 2 , K - 2 ) * B ( 3 , K - 2 ) & & + A ( 2 , K - 1 ) * B ( 3 , K - 1 ) & & + A ( 2 , K - 0 ) * B ( 3 , K - 0 ) C ( 3 , 3 ) = C ( 3 , 3 ) + A ( 3 , K - 2 ) * B ( 3 , K - 2 ) & & + A ( 3 , K - 1 ) * B ( 3 , K - 1 ) & & + A ( 3 , K - 0 ) * B ( 3 , K - 0 ) end select end subroutine SGEMM","tags":"","loc":"sourcefile/mod_dimspec_functions.f90~2.html"},{"title":"mod_rotation.f90 – mobbrmsd","text":"Contents Modules mod_rotation Source Code mod_rotation.f90 Source Code !| Calculate the rotation matrix that minimizes |\\mathbf{X}-\\mathbf{R}\\mathbf{Y}|&#94;2 for D=3. <br> !  Here, \\mathbf{R}\\mathbf{R}&#94;\\top=\\mathbf{I} and \\det(\\mathbf{R})=1 are satisfied. <br> !  This code is based on the method of Coutsias et.al. !  doi : [10.1002/jcc.25802](https://onlinelibrary.wiley.com/doi/10.1002/jcc.25802) module mod_rotation use mod_kinds , only : IK , RK implicit none private public :: sdmin_worksize public :: estimate_rcmax public :: estimate_sdmin public :: rotation_worksize public :: estimate_rotation ! real ( RK ), parameter :: ZERO = 0.0_RK real ( RK ), parameter :: HALF = 0.5_RK real ( RK ), parameter :: ONE = 1.0_RK real ( RK ), parameter :: TWO = 2.0_RK real ( RK ), parameter :: FOUR = 4.0_RK real ( RK ), parameter :: EIGHT = 8.0_RK real ( RK ), parameter :: THRESHOLD = 1E-14_RK real ( RK ), parameter :: DEGENERACY = 1E-6_RK integer ( IK ), parameter :: MAXITER = 100000 ! contains ! !| Inquire function for memory size of estimate_sdmin. pure elemental function sdmin_worksize () result ( res ) integer ( IK ) :: res res = 8 end function sdmin_worksize ! !| Compute \\min_{R}\\text{tr}[\\mathbf{R}\\mathbf{C}]. pure subroutine estimate_rcmax ( g , cov , w ) real ( RK ), intent ( in ) :: g !! sum of auto covariance matrix real ( RK ), intent ( in ) :: cov ( * ) !! target d*n array real ( RK ), intent ( inout ) :: w ( * ) !! work array, must be larger than worksize_sdmin(). call find_lambda_max ( g , cov , w ) end subroutine estimate_rcmax ! !| Compute the least-squares sum_i&#94;n |x_i-Ry_i|&#94;2 from cov = YX&#94;T and g = tr[XX&#94;T] + tr[YY&#94;T]. pure subroutine estimate_sdmin ( g , cov , w ) real ( RK ), intent ( in ) :: g !! sum of auto covariance matrix real ( RK ), intent ( in ) :: cov ( * ) !! target d*n array real ( RK ), intent ( inout ) :: w ( * ) !! work array, must be larger than worksize_sdmin(). call find_lambda_max ( g , cov , w ) w ( 1 ) = g - w ( 1 ) - w ( 1 ) end subroutine estimate_sdmin ! !| Inquire function for memory size of rotation. pure elemental function rotation_worksize () result ( res ) integer ( IK ) :: res res = 18 end function rotation_worksize ! !| Compute the transpose rotation matrix for minimize tr[CR] from cov = YX&#94;T and g = tr[XX&#94;T] + tr[YY&#94;T]. !  This subroutine is based on the method of Coutsias et.al. 10.1002/jcc.25802 pure subroutine estimate_rotation ( g , cov , rot , w ) real ( RK ), intent ( in ) :: g !! g = tr[XX&#94;T] + tr[YY&#94;T] real ( RK ), intent ( in ) :: cov ( * ) !! covariance dxd matrix, YX&#94;T real ( RK ), intent ( inout ) :: rot ( * ) !! rotation dxd matrix real ( RK ), intent ( inout ) :: w ( * ) !! work array, must be larger than worksize_rotation(). integer ( IK ), parameter :: l2 = 1 , l3 = 2 , l4 = 3 integer ( IK ), parameter :: y2 = 4 , y3 = 5 , y4 = 6 integer ( IK ), parameter :: dg1 = 1 , dg2 = 2 , dg3 = 3 , dg4 = 18 integer ( IK ), parameter :: aa1 = 1 , aa2 = 2 , aa3 = 2 , aa4 = 1 integer ( IK ), parameter :: a11 = 4 , a21 = 5 , a31 = 6 , a41 = 12 integer ( IK ), parameter :: a22 = 13 , a32 = 14 , a42 = 15 , a33 = 16 , a43 = 17 , a44 = 18 integer ( IK ), parameter :: s22 = 7 , s23 = 8 , s24 = 9 , s33 = 10 , s34 = 11 , s44 = 12 integer ( IK ), parameter :: v1 = 3 , v2 = 4 , v3 = 5 , v4 = 6 integer ( IK ), parameter :: v11 = 7 , v21 = 8 , v31 = 9 , v41 = 10 integer ( IK ), parameter :: v22 = 11 , v32 = 12 , v42 = 13 , v33 = 14 , v43 = 15 , v44 = 16 if ( g < THRESHOLD ) then rot ( 1 ) = ONE ; rot ( 2 ) = ZERO ; rot ( 3 ) = ZERO rot ( 4 ) = ZERO ; rot ( 5 ) = ONE ; rot ( 6 ) = ZERO rot ( 7 ) = ZERO ; rot ( 8 ) = ZERO ; rot ( 9 ) = ONE return end if ! call find_lambda_max ( g , cov , w ) ! !   A = L - lambda_max * I ! !   L = (R11+R22+R33  R23-R32      R31-R13      R12-R21    ) !       (R23-R32      R11-R22-R33  R12+R21      R13+R31    ) !       (R31-R13      R12+R21     -R11+R22-R33  R23+R32    ) !       (R12-R21      R13+R31      R23+R32     -R11-R22+R33) ! w ( dg4 ) = cov ( 9 ) - w ( 1 ) w ( dg3 ) = cov ( 9 ) + w ( 1 ) w ( dg2 ) = cov ( 1 ) - cov ( 5 ) w ( dg1 ) = cov ( 1 ) + cov ( 5 ) w ( a11 ) = w ( dg1 ) + w ( dg4 ) w ( a21 ) = cov ( 8 ) - cov ( 6 ) w ( a31 ) = cov ( 3 ) - cov ( 7 ) w ( a41 ) = cov ( 4 ) - cov ( 2 ) w ( a22 ) = w ( dg2 ) - w ( dg3 ) w ( a32 ) = cov ( 4 ) + cov ( 2 ) w ( a42 ) = cov ( 7 ) + cov ( 3 ) w ( a33 ) = - w ( dg2 ) - w ( dg3 ) w ( a43 ) = cov ( 8 ) + cov ( 6 ) w ( a44 ) = - w ( dg1 ) + w ( dg4 ) ! w ( aa1 ) = ABS ( w ( a11 )) w ( aa3 ) = ABS ( w ( a33 )) ! if ( w ( aa1 ) > w ( aa3 )) then w ( aa2 ) = ABS ( w ( a22 )) if ( w ( aa1 ) > w ( aa2 )) then w ( l4 ) = ONE / w ( a11 ) w ( l2 ) = w ( a21 ) * w ( l4 ) w ( l3 ) = w ( a31 ) * w ( l4 ) w ( l4 ) = w ( a41 ) * w ( l4 ) w ( s22 ) = w ( a22 ) - w ( a21 ) * w ( l2 ) w ( s23 ) = w ( a32 ) - w ( a21 ) * w ( l3 ) w ( s33 ) = w ( a33 ) - w ( a31 ) * w ( l3 ) w ( s24 ) = w ( a42 ) - w ( a21 ) * w ( l4 ) w ( s34 ) = w ( a43 ) - w ( a31 ) * w ( l4 ) w ( s44 ) = w ( a44 ) - w ( a41 ) * w ( l4 ) call find_null_vector ( w ) w ( v1 ) = - w ( l2 ) * w ( y2 ) - w ( l3 ) * w ( Y3 ) - w ( l4 ) * w ( y4 ) else w ( l4 ) = ONE / w ( a22 ) w ( l2 ) = w ( A21 ) * w ( l4 ) w ( l3 ) = w ( A32 ) * w ( l4 ) w ( l4 ) = w ( A42 ) * w ( l4 ) w ( s22 ) = w ( a11 ) - w ( a21 ) * w ( l2 ) w ( s23 ) = w ( a31 ) - w ( a21 ) * w ( l3 ) w ( s33 ) = w ( a33 ) - w ( a32 ) * w ( l3 ) w ( s24 ) = w ( a41 ) - w ( a21 ) * w ( l4 ) w ( s34 ) = w ( a43 ) - w ( a32 ) * w ( l4 ) w ( s44 ) = w ( a44 ) - w ( a42 ) * w ( l4 ) call find_null_vector ( w ) w ( l2 ) = - w ( l2 ) * w ( y2 ) - w ( l3 ) * w ( Y3 ) - w ( l4 ) * w ( y4 ) w ( v1 ) = w ( y2 ) w ( v2 ) = w ( l2 ) end if else w ( aa4 ) = ABS ( w ( a44 )) if ( w ( aa3 ) > w ( aa4 )) then w ( l4 ) = ONE / w ( a33 ) w ( l2 ) = w ( a31 ) * w ( l4 ) w ( l3 ) = w ( a32 ) * w ( l4 ) w ( l4 ) = w ( a43 ) * w ( l4 ) w ( s22 ) = w ( a11 ) - w ( a31 ) * w ( l2 ) w ( s23 ) = w ( a21 ) - w ( a31 ) * w ( l3 ) w ( s33 ) = w ( a22 ) - w ( a32 ) * w ( l3 ) w ( s24 ) = w ( a41 ) - w ( a31 ) * w ( l4 ) w ( s34 ) = w ( a42 ) - w ( a32 ) * w ( l4 ) w ( s44 ) = w ( a44 ) - w ( a43 ) * w ( l4 ) call find_null_vector ( w ) w ( l2 ) = - w ( l2 ) * w ( y2 ) - w ( l3 ) * w ( y3 ) - w ( l4 ) * w ( y4 ) w ( v1 ) = w ( y2 ) w ( v2 ) = w ( y3 ) w ( v3 ) = w ( l2 ) else w ( l4 ) = ONE / w ( a44 ) w ( l2 ) = w ( a41 ) * w ( l4 ) w ( l3 ) = w ( a42 ) * w ( l4 ) w ( l4 ) = w ( a43 ) * w ( l4 ) w ( s22 ) = w ( a11 ) - w ( a41 ) * w ( l2 ) w ( s23 ) = w ( a21 ) - w ( a41 ) * w ( l3 ) w ( s33 ) = w ( a22 ) - w ( a42 ) * w ( l3 ) w ( s24 ) = w ( a31 ) - w ( a41 ) * w ( l4 ) w ( s34 ) = w ( a32 ) - w ( a42 ) * w ( l4 ) w ( s44 ) = w ( a33 ) - w ( a43 ) * w ( l4 ) call find_null_vector ( w ) w ( l2 ) = - w ( l2 ) * w ( y2 ) - w ( l3 ) * w ( Y3 ) - w ( l4 ) * w ( y4 ) w ( v1 ) = w ( y2 ) w ( v2 ) = w ( y3 ) w ( v3 ) = w ( y4 ) w ( v4 ) = w ( l2 ) end if end if ! w ( v11 ) = w ( v1 ) * w ( v1 ) w ( v22 ) = w ( v2 ) * w ( v2 ) w ( v33 ) = w ( v3 ) * w ( v3 ) w ( v44 ) = w ( v4 ) * w ( v4 ) w ( v21 ) = w ( v1 ) * w ( v2 ) w ( v31 ) = w ( v1 ) * w ( v3 ) w ( v41 ) = w ( v1 ) * w ( v4 ) w ( v32 ) = w ( v2 ) * w ( v3 ) w ( v42 ) = w ( v2 ) * w ( v4 ) w ( v43 ) = w ( v3 ) * w ( v4 ) ! w ( l2 ) = ONE / ( w ( v11 ) + w ( v22 ) + w ( v33 ) + w ( v44 )) w ( l3 ) = w ( l2 ) + w ( l2 ) ! rot ( 1 ) = w ( l2 ) * ( w ( v11 ) + w ( v22 ) - w ( v33 ) - w ( v44 )) rot ( 2 ) = w ( l3 ) * ( w ( v32 ) - w ( v41 )) rot ( 3 ) = w ( l3 ) * ( w ( v42 ) + w ( v31 )) rot ( 4 ) = w ( l3 ) * ( w ( v32 ) + w ( v41 )) rot ( 5 ) = w ( l2 ) * ( w ( v11 ) - w ( v22 ) + w ( v33 ) - w ( v44 )) rot ( 6 ) = w ( l3 ) * ( w ( v43 ) - w ( v21 )) rot ( 7 ) = w ( l3 ) * ( w ( v42 ) - w ( v31 )) rot ( 8 ) = w ( l3 ) * ( w ( v43 ) + w ( v21 )) rot ( 9 ) = w ( l2 ) * ( w ( v11 ) - w ( v22 ) - w ( v33 ) + w ( v44 )) end subroutine estimate_rotation ! !| Compute maximum eigen value of S. <br> !  This subroutine is based on the method of Coutsias et.al. 10.1002/jcc.25802 pure subroutine find_lambda_max ( g , cov , w ) real ( RK ), intent ( in ) :: g !! sum of auto covariance matrix real ( RK ), intent ( in ) :: cov ( * ) !! target d*n array real ( RK ), intent ( inout ) :: w ( * ) integer ( IK ), parameter :: k1 = 2 , k0 = 3 , k2 = 4 integer ( IK ), parameter :: xk = 1 , s = 5 , xx = 6 integer ( IK ), parameter :: a = 8 , f = 7 , df = 8 integer ( IK ), parameter :: d11 = 3 , d22 = 4 , d33 = 5 , d21 = 6 , d31 = 7 , d32 = 8 integer ( IK ), parameter :: a1 = 6 , a2 = 5 integer ( IK ) :: k ! if ( g < THRESHOLD ) then w ( 1 ) = ZERO return end if ! !   K1 = - 8 det|R| ! w ( k1 ) = - cov ( 1 ) * ( cov ( 5 ) * cov ( 9 ) - cov ( 8 ) * cov ( 6 )) & & - cov ( 4 ) * ( cov ( 8 ) * cov ( 3 ) - cov ( 2 ) * cov ( 9 )) & & - cov ( 7 ) * ( cov ( 2 ) * cov ( 6 ) - cov ( 5 ) * cov ( 3 )) w ( k1 ) = EIGHT * w ( k1 ) ! !   D = RR&#94;T ! w ( d11 ) = cov ( 1 ) * cov ( 1 ) + cov ( 2 ) * cov ( 2 ) + cov ( 3 ) * cov ( 3 ) w ( d22 ) = cov ( 4 ) * cov ( 4 ) + cov ( 5 ) * cov ( 5 ) + cov ( 6 ) * cov ( 6 ) w ( d33 ) = cov ( 7 ) * cov ( 7 ) + cov ( 8 ) * cov ( 8 ) + cov ( 9 ) * cov ( 9 ) w ( d21 ) = cov ( 4 ) * cov ( 1 ) + cov ( 5 ) * cov ( 2 ) + cov ( 6 ) * cov ( 3 ) w ( d31 ) = cov ( 7 ) * cov ( 1 ) + cov ( 8 ) * cov ( 2 ) + cov ( 9 ) * cov ( 3 ) w ( d32 ) = cov ( 4 ) * cov ( 7 ) + cov ( 5 ) * cov ( 8 ) + cov ( 6 ) * cov ( 9 ) ! !   A1 = D11 * (D22+D33) + D22 * D33 - D12**2 - D13**2 - D23**2 !   A2 = tr[D] ! w ( a1 ) = w ( d11 ) * ( w ( d22 ) + w ( d33 )) + w ( d22 ) * w ( d33 ) - w ( d21 ) ** 2 - w ( d31 ) ** 2 - w ( d32 ) ** 2 w ( a1 ) = FOUR * w ( a1 ) w ( a2 ) = w ( d11 ) + w ( d22 ) + w ( d33 ) ! !   K0 = 16 * (A2**2 - 4*A1) !   K2 = -8 * A2 ! w ( k0 ) = w ( a2 ) * w ( a2 ) - w ( a1 ) w ( k2 ) = - TWO * w ( a2 ) ! if ( ABS ( w ( k1 )) < THRESHOLD ) then ! !     find solution of x**4 + K2 * x**2 + K0 = 0 !     that is x**2 = (K2 + sqrt{K2**2 - 4 * K0}) / 2 ! w ( xk ) = w ( k2 ) * w ( k2 ) - FOUR * w ( k0 ) ! if ( w ( xk ) < ZERO ) then if ( w ( k2 ) < ZERO ) then w ( xk ) = SQRT ( - HALF * w ( k2 )) else w ( xk ) = ZERO end if else w ( xk ) = SQRT ( w ( xk )) - w ( k2 ) if ( w ( xk ) < ZERO ) then w ( xk ) = ZERO else w ( xk ) = SQRT ( HALF * w ( xk )) end if end if ! else ! !     find solution of x**4 + K2 * x**2 + K1 * x + K0 = 0 ! w ( s ) = ONE w ( xk ) = HALF * g ! do k = 1 , MAXITER w ( xx ) = w ( xk ) * w ( xk ) w ( a ) = w ( k2 ) + w ( xx ) w ( f ) = w ( a ) * w ( xx ) + w ( k1 ) * w ( xk ) + w ( k0 ) w ( df ) = w ( k1 ) + ( w ( xk ) + w ( xk )) * ( w ( a ) + w ( xx )) if ( ABS ( w ( df )) < THRESHOLD . and . ABS ( w ( f )) < THRESHOLD ) exit w ( s ) = w ( f ) / w ( df ) w ( xk ) = w ( xk ) - w ( s ) if ( w ( s ) < THRESHOLD * ABS ( w ( xk ))) exit end do end if ! end subroutine find_lambda_max ! !| Find null vector of S. <br> !  This subroutine is based on the method of Coutsias et.al. 10.1002/jcc.25802 pure subroutine find_null_vector ( w ) real ( RK ), intent ( inout ) :: w ( * ) integer ( IK ), parameter :: y2 = 4 , y3 = 5 , y4 = 6 integer ( IK ), parameter :: s22 = 7 , s23 = 8 , s24 = 9 integer ( IK ), parameter :: s33 = 10 , s34 = 11 , s44 = 12 integer ( IK ), parameter :: m22 = 13 , m23 = 14 , m24 = 15 integer ( IK ), parameter :: m33 = 16 , m34 = 17 , m44 = 18 integer ( IK ), parameter :: mm2 = 4 , mm3 = 5 , mm4 = 6 ! w ( m22 ) = w ( s33 ) * w ( s44 ) - w ( s34 ) * w ( s34 ) w ( m23 ) = w ( s34 ) * w ( s24 ) - w ( s23 ) * w ( s44 ) w ( m24 ) = w ( s23 ) * w ( s34 ) - w ( s33 ) * w ( s24 ) ! w ( mm2 ) = w ( m22 ) * w ( m22 ) w ( mm3 ) = w ( m23 ) * w ( m23 ) w ( mm4 ) = w ( m24 ) * w ( m24 ) w ( m33 ) = w ( mm2 ) + w ( mm3 ) + w ( mm4 ) ! if ( w ( m33 ) < DEGENERACY ) then w ( m44 ) = w ( m33 ) - w ( mm2 ) w ( m33 ) = w ( s22 ) * w ( s44 ) - w ( mm4 ) w ( m34 ) = w ( s22 ) * w ( s34 ) - w ( s23 ) * w ( s24 ) if ( w ( m44 ) < DEGENERACY ) then w ( mm4 ) = w ( m44 ) - w ( mm3 ) w ( m44 ) = w ( s22 ) * w ( s33 ) - w ( s23 ) * w ( s23 ) if ( w ( mm4 ) < DEGENERACY ) then ! double degeneracy if ( ABS ( w ( s22 )) > DEGENERACY ) then w ( y2 ) = - w ( s23 ) w ( y3 ) = w ( s22 ) w ( y4 ) = ZERO elseif ( ABS ( w ( s33 )) > DEGENERACY ) then w ( y2 ) = w ( s33 ) w ( y3 ) = - w ( s23 ) w ( y4 ) = ZERO elseif ( ABS ( w ( s44 )) > DEGENERACY ) then w ( y2 ) = w ( s44 ) w ( y3 ) = ZERO w ( y4 ) = - w ( s24 ) else w ( y2 ) = ONE w ( y3 ) = ZERO w ( y4 ) = ZERO end if else ! Triple degeneracy w ( y2 ) = ZERO w ( y3 ) = ZERO w ( y4 ) = w ( m44 ) end if else w ( y2 ) = ZERO w ( y3 ) = w ( m33 ) w ( y4 ) = w ( m34 ) end if else w ( y2 ) = w ( m22 ) w ( y3 ) = w ( m23 ) w ( y4 ) = w ( m24 ) end if ! end subroutine find_null_vector ! end module mod_rotation","tags":"","loc":"sourcefile/mod_rotation.f90~2.html"},{"title":"mod_dimspec_functions.f90 – mobbrmsd","text":"Contents Modules mod_dimspec_functions Source Code mod_dimspec_functions.f90 Source Code !| Define spatial dimension, D, !  and provide optimized functions for dimension. module mod_dimspec_functions use mod_kinds , only : RK , IK implicit none private public :: D , DD , ND public :: setup_dimension public :: compute_com public :: compute_cov public :: covcopy !| Spatial dimension, D. integer ( IK ), protected , save :: D = 3 !| Square spatial dimension, D&#94;2. integer ( IK ), protected , save :: DD = 9 !| Node memory size, defined by 1 + 1 + D&#94;2. !  Let [L, G, \\mathbf{C}] be a node, !  where L, G\\in\\mathbb{R} and \\mathbf{C}\\in\\mathbb{R}&#94;{D\\times D}. integer ( IK ), protected , save :: ND = 9 + 2 ! real ( RK ), parameter :: ZERO = 0.0_RK real ( RK ), parameter :: HALF = 0.5_RK real ( RK ), parameter :: ONETHIRD = 1.0_RK / 3.0_RK real ( RK ), parameter :: ONE = 1.0_RK ! interface include 'dgemm.h' include 'sgemm.h' end interface ! contains !| Sets the dimensions of the space. <br> !  Caution, this routine affects global. subroutine setup_dimension ( d_ ) integer ( IK ), intent ( in ) :: d_ D = MAX ( 1 , d_ ) DD = D * D ND = DD + 2 end subroutine setup_dimension ! !| Calculate center of mass. pure subroutine compute_com ( d , n , X , C ) integer ( IK ), intent ( in ) :: d , n real ( RK ), intent ( in ) :: X ( d , * ) real ( RK ), intent ( inout ) :: C ( d ) real ( RK ) :: rn integer ( IK ) :: i , j if ( n < 0 ) then do concurrent ( i = 1 : d ) C ( i ) = ZERO end do return elseif ( n == 1 ) then do concurrent ( i = 1 : d ) C ( i ) = X ( i , 1 ) end do return elseif ( n == 2 ) then do concurrent ( i = 1 : d ) C ( i ) = ( X ( i , 1 ) + X ( i , 2 )) * HALF end do return elseif ( n == 3 ) then do concurrent ( i = 1 : d ) C ( i ) = ( X ( i , 1 ) + X ( i , 2 ) + X ( i , 3 )) * ONETHIRD end do return end if do concurrent ( i = 1 : d ) C ( i ) = ZERO end do do j = 2 , n , 2 do concurrent ( i = 1 : d ) C ( i ) = C ( i ) + X ( i , j - 1 ) end do do concurrent ( i = 1 : d ) C ( i ) = C ( i ) + X ( i , j - 0 ) end do end do if ( MODULO ( n , 2 ) == 1 ) then do concurrent ( i = 1 : d ) C ( i ) = C ( i ) + X ( i , n ) end do end if rn = ONE / real ( n , RK ) do concurrent ( i = 1 : d ) C ( i ) = C ( i ) * rn end do end subroutine compute_com ! !| Calculate covariance matrix. pure subroutine compute_cov ( d , n , X , Y , C ) integer ( IK ), intent ( in ) :: d , n real ( RK ), intent ( in ) :: X ( d , * ), Y ( d , * ) real ( RK ), intent ( inout ) :: C ( d , d ) #ifdef REAL32 call SGEMM ( 'N' , 'T' , D , D , n , ONE , Y , D , X , D , ZERO , C , D ) #else call DGEMM ( 'N' , 'T' , D , D , n , ONE , Y , D , X , D , ZERO , C , D ) #endif end subroutine compute_cov !| Compute \\mathbf{Y} \\gets \\mathbf{X}-\\bar{\\mathbf{X}}. pure subroutine covcopy ( d , n , X , CX , Y ) integer ( IK ), intent ( in ) :: d , n real ( RK ), intent ( in ) :: X ( d , * ), CX ( d ) real ( RK ), intent ( inout ) :: Y ( d , * ) integer ( IK ) :: i , j do concurrent ( i = 1 : d , j = 1 : n ) Y ( i , j ) = X ( i , j ) - CX ( i ) end do end subroutine covcopy end module mod_dimspec_functions","tags":"","loc":"sourcefile/mod_dimspec_functions.f90~3.html"},{"title":"mod_rotation.f90 – mobbrmsd","text":"Contents Modules mod_rotation Source Code mod_rotation.f90 Source Code !| Calculate the rotation matrix that minimizes |\\mathbf{X}-\\mathbf{R}\\mathbf{Y}|&#94;2. <br> !  Here, \\mathbf{R}\\mathbf{R}&#94;\\top=\\mathbf{I} and \\det(\\mathbf{R})=1 are satisfied. <br> !  This code is based on the Kabsch algorithm. !  doi : [10.1107/S0567739476001873](https://scripts.iucr.org/cgi-bin/paper?S0567739476001873) module mod_rotation use mod_kinds , only : IK , RK use mod_dimspec_functions , only : D , DD implicit none private public :: sdmin_worksize public :: estimate_rcmax public :: estimate_sdmin public :: rotation_worksize public :: estimate_rotation ! interface include 'dgemm.h' include 'sgemm.h' include 'dgesvd.h' include 'sgesvd.h' include 'dgetrf.h' include 'sgetrf.h' end interface ! real ( RK ), parameter :: ZERO = 0.0_RK real ( RK ), parameter :: ONE = 1.0_RK ! contains ! !| Inquire function for memory size of estimate_sdmin. pure elemental function sdmin_worksize () result ( res ) integer ( IK ) :: res res = worksize_Kabsch () + DD + 1 end function sdmin_worksize ! !| Compute \\max_{\\mathbf{R}}\\text{tr}[\\mathbf{R}\\mathbf{C}]. pure subroutine estimate_rcmax ( g , cov , w ) real ( RK ), intent ( in ) :: g !! sum of auto covariance matrix real ( RK ), intent ( in ) :: cov ( * ) !! target d*n array real ( RK ), intent ( inout ) :: w ( * ) !! work array, must be larger than worksize_sdmin(). ! call Kabsch ( cov , w ( 2 ), w ( DD + 2 )) w ( 1 ) = dot ( DD , cov , w ( 2 )) ! end subroutine estimate_rcmax ! !| Compute \\min_{\\mathbf{R}}(g-2\\text{tr}[\\mathbf{R}\\mathbf{C}]), !  where g = tr[\\mathbf{X}\\mathbf{X}&#94;\\top] + tr[\\mathbf{Y}\\mathbf{Y}&#94;\\top] pure subroutine estimate_sdmin ( g , cov , w ) real ( RK ), intent ( in ) :: g !! sum of auto covariance matrix real ( RK ), intent ( in ) :: cov ( * ) !! target d*n array real ( RK ), intent ( inout ) :: w ( * ) !! work array, must be larger than worksize_sdmin(). ! call Kabsch ( cov , w ( 2 ), w ( DD + 2 )) w ( 1 ) = dot ( DD , cov , w ( 2 )) w ( 1 ) = w ( 1 ) + w ( 1 ) w ( 1 ) = g - w ( 1 ) ! end subroutine estimate_sdmin ! !| Inquire function for memory size of estimate_rotation(). pure elemental function rotation_worksize () result ( res ) integer ( IK ) :: res res = worksize_Kabsch () end function rotation_worksize ! !| Compute the transpose of rotation matrix \\mathbf{R} !  that maximize \\text{tr}[\\mathbf{R}\\mathbf{Y}\\mathbf{X}&#94;\\top]. pure subroutine estimate_rotation ( g , cov , rot , w ) real ( RK ), intent ( in ) :: g !! g=\\text{tr}[\\mathbf{X}\\mathbf{X}&#94;\\top}]+\\text{tr}[\\mathbf{X}\\mathbf{X}&#94;\\top}]. real ( RK ), intent ( in ) :: cov ( * ) !! covariance matrix \\mathbf{C}=\\mathbf{Y}\\mathbf{X}&#94;\\top\\in\\mathbb R&#94;{D\\times D} !! rotation real ( RK ), intent ( inout ) :: rot ( * ) !! rotation matrix, \\mathbf{R}\\in\\mathbb R&#94;{D\\times D}. real ( RK ), intent ( inout ) :: w ( * ) !! work array, must be larger than worksize_rotation(). call Kabsch ( cov , rot , w ) end subroutine estimate_rotation ! !| work array size for Kabsch algorithm. pure elemental function worksize_Kabsch () result ( res ) real ( RK ) :: w ( 1 ) integer ( IK ) :: res , info #ifdef REAL32 call SGESVD ( 'A' , 'A' , D , D , w , D , w , w , D , w , D , w , - 1 , info ) #else call DGESVD ( 'A' , 'A' , D , D , w , D , w , w , D , w , D , w , - 1 , info ) #endif res = NINT ( w ( 1 )) + DD * 3 + D end function worksize_Kabsch ! pure subroutine Kabsch ( cov , rot , w ) real ( RK ), intent ( in ) :: cov ( * ) !! target d*n array real ( RK ), intent ( inout ) :: rot ( * ) !! rotation d*d matrix real ( RK ), intent ( inout ) :: w ( * ) !! work array, must be larger than Kabsch_worksize(d) !! if row_major, must be larger than Kabsch_worksize(n) integer ( IK ), parameter :: m = 1 integer ( IK ) :: s , u , vt , iw , lw , info ! u = m + DD vt = u + DD s = vt + DD iw = s + D #ifdef REAL32 call SGESVD ( 'A' , 'A' , D , D , w ( m ), D , w ( s ), w ( u ), D , w ( vt ), D , w ( iw ), - 1 , info ) lw = NINT ( w ( iw )) ! call copy ( DD , cov , w ( m )) call SGESVD ( 'A' , 'A' , D , D , w ( m ), D , w ( s ), w ( u ), D , w ( vt ), D , w ( iw ), lw , info ) ! call SGEMM ( 'N' , 'N' , D , D , D , ONE , w ( u ), D , w ( vt ), D , ZERO , w ( s ), D ) call det_sign ( w ( s )) if ( w ( s ) < ZERO ) call neg ( d , w ( u + DD - D )) call SGEMM ( 'N' , 'N' , D , D , D , ONE , w ( u ), D , w ( vt ), D , ZERO , w ( s ), D ) call copy ( DD , w ( s ), rot ( 1 )) #else call DGESVD ( 'A' , 'A' , D , D , w ( m ), D , w ( s ), w ( u ), D , w ( vt ), D , w ( iw ), - 1 , info ) lw = NINT ( w ( iw )) ! call copy ( DD , cov , w ( m )) call DGESVD ( 'A' , 'A' , D , D , w ( m ), D , w ( s ), w ( u ), D , w ( vt ), D , w ( iw ), lw , info ) ! call DGEMM ( 'N' , 'N' , D , D , D , ONE , w ( u ), D , w ( vt ), D , ZERO , w ( s ), D ) call det_sign ( w ( s )) if ( w ( s ) < ZERO ) call neg ( d , w ( u + DD - D )) call DGEMM ( 'N' , 'N' , D , D , D , ONE , w ( u ), D , w ( vt ), D , ZERO , w ( s ), D ) call copy ( DD , w ( s ), rot ( 1 )) #endif end subroutine Kabsch ! !| calculate determinant sign of square matrix x, with leading dimension. pure subroutine det_sign ( x ) real ( RK ), intent ( inout ) :: x ( * ) !! square matrix, on exit, x(1) is assigned the determinant sign of x, <br> !! and the other elements are undefined. ! if ( D < 1 ) then return elseif ( D == 1 ) then x ( 1 ) = SIGN ( ONE , x ( 1 )) elseif ( D == 2 ) then x ( 1 ) = SIGN ( ONE , x ( 1 ) * x ( 4 ) - x ( 2 ) * x ( 3 )) elseif ( D == 3 ) then x ( 1 ) = SIGN ( ONE , x ( 1 ) * ( x ( 5 ) * x ( 9 ) - x ( 8 ) * x ( 6 )) + & & x ( 4 ) * ( x ( 8 ) * x ( 3 ) - x ( 2 ) * x ( 9 )) + & & x ( 7 ) * ( x ( 2 ) * x ( 6 ) - x ( 5 ) * x ( 3 ))) else block integer ( IK ) :: i , j , k , ipiv ( D ) call DGETRF ( D , D , x , D , ipiv , j ) ipiv ( 1 ) = COUNT ([( ipiv ( i ) == i , i = 1 , D )]) j = 1 k = D + 1 do i = 1 , D if ( x ( j ) <= ZERO ) ipiv ( 1 ) = ipiv ( 1 ) + 1 j = j + k end do if ( MODULO ( ipiv ( 1 ), 2 ) == 0 ) then x ( 1 ) = ONE else x ( 1 ) = - ONE end if end block end if ! end subroutine det_sign ! pure subroutine neg ( N , X ) integer ( IK ), intent ( in ) :: N real ( RK ), intent ( inout ) :: X ( * ) integer ( IK ) :: i do concurrent ( i = 1 : N ) X ( i ) = - X ( i ) end do end subroutine neg ! pure function dot ( N , X , Y ) result ( res ) integer ( IK ), intent ( in ) :: N real ( RK ), intent ( in ) :: X ( * ), Y ( * ) real ( RK ) :: res , tmp integer ( IK ) :: i res = ZERO tmp = ZERO do i = 2 , N , 2 res = res + X ( i - 1 ) * Y ( i - 1 ) tmp = tmp + X ( i - 0 ) * Y ( i - 0 ) end do res = res + tmp if ( MODULO ( N , 2 ) == 1 ) res = res + X ( N ) * Y ( N ) end function dot ! pure subroutine copy ( N , X , Y ) integer ( IK ), intent ( in ) :: N real ( RK ), intent ( in ) :: X ( * ) real ( RK ), intent ( inout ) :: Y ( * ) integer ( IK ) :: i do concurrent ( i = 1 : N ) Y ( i ) = X ( i ) end do end subroutine copy ! end module mod_rotation","tags":"","loc":"sourcefile/mod_rotation.f90~3.html"}]}